<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>开发一个本地MCP Server进行code review</title>
    <link href="/2025/03/28/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0MCP%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81review/"/>
    <url>/2025/03/28/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0MCP%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81review/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前开发团队会定期使用AI提效进行code review，但由于每个开发人员使用的不同的AI编程工具，有不同的LLM和IDE，各自提交的审查报告风格和统计会因为LLM的不同而不统一。<br>尝试开发一个本地的MCP工具，这样大家可以用统一模型、统一工具进行code review工作，以保证使用相同的AI模型输出结果的质量和风格是区别不大的。<br>之所以开发本地的，是因为前期需要实验这个mcp工具的实际效果，不需要在工具中再调用git工具去线上取代码提交记录中的文件。</p><blockquote><p><strong>此工具的完整代码和使用示例已上传git，欢迎给个Star~~</strong><br>  <a href="https://github.com/wenkil/mcp_review_code_tool">https://github.com/wenkil/mcp_review_code_tool</a></p></blockquote><h2 id="开发调试过程"><a href="#开发调试过程" class="headerlink" title="开发调试过程"></a>开发调试过程</h2><p>先通过官方文档改造一个mcp 服务器的ts代码（注意这里使用的新版SDK里的McpServer不是Server）：<br><a href="https://github.com/modelcontextprotocol/typescript-sdk">https://github.com/modelcontextprotocol/typescript-sdk</a></p><details><summary>展开/收起</summary><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; McpServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/mcp.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; StdioServerTransport &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/stdio.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; z &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zod&quot;</span>;<span class="hljs-keyword">import</span> &#123; promises <span class="hljs-keyword">as</span> fs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 日志级别枚举</span><span class="hljs-comment"> * <span class="hljs-doctag">@enum <span class="hljs-type">&#123;string&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-built_in">enum</span> LogLevel &#123;  DEBUG = <span class="hljs-string">&quot;DEBUG&quot;</span>,  INFO = <span class="hljs-string">&quot;INFO&quot;</span>,  WARN = <span class="hljs-string">&quot;WARN&quot;</span>,  ERROR = <span class="hljs-string">&quot;ERROR&quot;</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 是否启用控制台日志</span><span class="hljs-comment"> * <span class="hljs-doctag">@type <span class="hljs-type">&#123;boolean&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> ENABLE_CONSOLE_LOG = <span class="hljs-literal">true</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 日志文件路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@type <span class="hljs-type">&#123;string&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> LOG_FILE_PATH = <span class="hljs-string">&quot;code-review-mcp.log&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 代码评审的结果接口</span><span class="hljs-comment"> * <span class="hljs-doctag">@interface <span class="hljs-variable">ReviewResult</span></span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">interface</span> ReviewResult &#123;  <span class="hljs-attr">filePath</span>: <span class="hljs-built_in">string</span>;  llmResponse: <span class="hljs-built_in">string</span>;  message: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 记录日志到文件和控制台</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">message</span></span> - 要记录的消息</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;LogLevel&#125;</span> <span class="hljs-variable">level</span></span> - 日志级别</span><span class="hljs-comment"> */</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logToFile</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span>, level: LogLevel = LogLevel.INFO</span>) </span>&#123;  <span class="hljs-keyword">const</span> timestamp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString();  <span class="hljs-keyword">const</span> logMessage = <span class="hljs-string">`[<span class="hljs-subst">$&#123;timestamp&#125;</span>] [<span class="hljs-subst">$&#123;level&#125;</span>]: <span class="hljs-subst">$&#123;message&#125;</span>`</span>;    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">await</span> fs.appendFile(LOG_FILE_PATH, <span class="hljs-string">`<span class="hljs-subst">$&#123;logMessage&#125;</span>\n`</span>);        <span class="hljs-comment">// 同时输出到控制台，方便调试</span>    <span class="hljs-keyword">if</span> (ENABLE_CONSOLE_LOG) &#123;      <span class="hljs-keyword">switch</span> (level) &#123;        <span class="hljs-keyword">case</span> LogLevel.ERROR:          <span class="hljs-built_in">console</span>.error(logMessage);          <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> LogLevel.WARN:          <span class="hljs-built_in">console</span>.warn(logMessage);          <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> LogLevel.DEBUG:          <span class="hljs-built_in">console</span>.debug(logMessage);          <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:          <span class="hljs-built_in">console</span>.log(logMessage);      &#125;    &#125;  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`日志记录失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 读取文件内容</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">filePath</span></span> - 文件的绝对路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;string&gt;&#125;</span> </span>文件内容</span><span class="hljs-comment"> */</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readFileContent</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">string</span>&gt; </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`开始读取文件: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>, LogLevel.DEBUG);    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> fs.readFile(filePath, <span class="hljs-string">&quot;utf-8&quot;</span>);    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`成功读取文件: <span class="hljs-subst">$&#123;filePath&#125;</span>，大小: <span class="hljs-subst">$&#123;content.length&#125;</span> 字节`</span>, LogLevel.DEBUG);    <span class="hljs-keyword">return</span> content;  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`无法读取文件 <span class="hljs-subst">$&#123;filePath&#125;</span>: <span class="hljs-subst">$&#123;error&#125;</span>`</span>, LogLevel.ERROR);    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`无法读取文件 <span class="hljs-subst">$&#123;filePath&#125;</span>: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 检查文件是否存在</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">filePath</span></span> - 文件的绝对路径 </span><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;boolean&gt;&#125;</span> </span>文件是否存在</span><span class="hljs-comment"> */</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fileExists</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">boolean</span>&gt; </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">await</span> fs.access(filePath);    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`文件存在: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>, LogLevel.DEBUG);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125; <span class="hljs-keyword">catch</span> &#123;    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`文件不存在: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>, LogLevel.WARN);    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 使用大语言模型分析代码</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">filePath</span></span> - 文件路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">content</span></span> - 文件内容</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;ReviewResult&gt;&#125;</span> </span>代码分析结果</span><span class="hljs-comment"> */</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">analyzeLLM</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span>, content: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ReviewResult</span>&gt; </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`开始使用LLM分析文件: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>, LogLevel.INFO);        <span class="hljs-comment">// 提取文件类型</span>    <span class="hljs-keyword">const</span> extension = path.extname(filePath).toLowerCase();    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`文件类型: <span class="hljs-subst">$&#123;extension&#125;</span>`</span>, LogLevel.DEBUG);    <span class="hljs-comment">// 构建提示词</span>    <span class="hljs-keyword">const</span> prompt = <span class="hljs-string">`</span><span class="hljs-string">    ## 根据要求对以下<span class="hljs-subst">$&#123;extension&#125;</span>代码进行代码评审，识别潜在的问题。要求：</span><span class="hljs-string">    1.**统计代码行数及注释率**：</span><span class="hljs-string">      - 计算该文件的总行数。</span><span class="hljs-string">      - 计算注释行数（如//、#或/* */等注释方式）。</span><span class="hljs-string">      - 计算注释率 = 注释行数 / 总行数。</span><span class="hljs-string">    2.**评价代码质量**：</span><span class="hljs-string">      在以下六个方面进行评分（0到10分），并给出平均分：</span><span class="hljs-string">      - **可读性（Readability）**：代码易于理解程度。</span><span class="hljs-string">      - **一致性（Consistency）**：编码风格和命名的一致性。</span><span class="hljs-string">      - **模块化（Modularity）**：代码分块和功能单元划分。</span><span class="hljs-string">      - **可维护性（Maintainability）**：代码易于修改和扩展的能力。</span><span class="hljs-string">      - **性能（Performance）**：代码执行效率。</span><span class="hljs-string">      - **文档化（Documentation）**：代码附带的说明和文档质量。</span><span class="hljs-string">    3. **生成总体报告**：</span><span class="hljs-string">      - 将所有分步信息整理成一个markdown结构。</span><span class="hljs-string">      - 内容应包括：第一部分：文件列表汇总（每个文件的总行数、注释率评分， 6维评分，得分比较低或者行数比较多，或者注释率比较低的用颜色高亮出来，比如黄色和红色）；第二部分每一个文件的功能描述，以及在六个质量因素上的评分以及说明；第三部分，总结</span><span class="hljs-string"></span><span class="hljs-string">      以下是要评审的代码：</span><span class="hljs-string">      \`\`\`</span><span class="hljs-string">      <span class="hljs-subst">$&#123;extension&#125;</span></span><span class="hljs-string">      <span class="hljs-subst">$&#123;content&#125;</span></span><span class="hljs-string">      \`\`\`</span><span class="hljs-string">    `</span>;    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`准备调用OpenRouter API`</span>, LogLevel.DEBUG);        <span class="hljs-comment">// 调用免费OpenRouter API进行演示，实际可使用公司内部购买的LLM api</span>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;https://openrouter.ai/api/v1/chat/completions&#x27;</span>, &#123;      <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,      <span class="hljs-attr">headers</span>: &#123;        <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer 这里需要去申请你自己的key&#x27;</span>,        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,      &#125;,      <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(&#123;        <span class="hljs-comment">// &quot;model&quot;: &quot;qwen/qwen-2.5-coder-32b-instruct:free&quot;,</span>        <span class="hljs-string">&quot;model&quot;</span>: <span class="hljs-string">&quot;deepseek/deepseek-chat-v3-0324:free&quot;</span>,        <span class="hljs-attr">messages</span>: [          &#123;            <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>,            <span class="hljs-attr">content</span>: prompt,          &#125;,        ],      &#125;),    &#125;);    <span class="hljs-keyword">if</span> (!response.ok) &#123;      <span class="hljs-keyword">const</span> errorText = <span class="hljs-string">`API请求失败: <span class="hljs-subst">$&#123;response.status&#125;</span> <span class="hljs-subst">$&#123;response.statusText&#125;</span>`</span>;      <span class="hljs-keyword">await</span> logToFile(errorText, LogLevel.ERROR);      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(errorText);    &#125;    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`OpenRouter API响应成功`</span>, LogLevel.DEBUG);        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();    <span class="hljs-keyword">const</span> llmResponse = data.choices[<span class="hljs-number">0</span>].message.content;    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`获取到LLM响应，响应长度: <span class="hljs-subst">$&#123;llmResponse.length&#125;</span>字符`</span>, LogLevel.DEBUG);    <span class="hljs-keyword">return</span> &#123;      filePath,      llmResponse,      <span class="hljs-attr">message</span>: <span class="hljs-string">`对 <span class="hljs-subst">$&#123;path.basename(filePath)&#125;</span> 的代码评审完成`</span>,    &#125;;  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`LLM分析失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>, LogLevel.ERROR);    <span class="hljs-keyword">return</span> &#123;      filePath,      <span class="hljs-attr">llmResponse</span>: <span class="hljs-string">``</span>,      <span class="hljs-attr">message</span>: <span class="hljs-string">`LLM分析失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>,    &#125;;  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建MCP服务器实例</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> McpServer(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;代码评审工具&quot;</span>,  <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,&#125;);<span class="hljs-comment">// 记录服务器启动日志</span>logToFile(<span class="hljs-string">&quot;MCP代码评审服务器正在启动...&quot;</span>, LogLevel.INFO);<span class="hljs-comment">/**</span><span class="hljs-comment"> * 代码评审工具</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">filePaths</span></span> - 文件的绝对路径数组</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;&#123; content: &#123; type: string, text: string &#125;</span></span>[] &#125;&gt;&#125; 代码评审结果</span><span class="hljs-comment"> */</span>server.tool(  <span class="hljs-string">&quot;reviewCode_tool&quot;</span>,  <span class="hljs-string">&quot;根据要求进行代码评审，总结代码质量&quot;</span>,  &#123; <span class="hljs-attr">filePaths</span>: z.array(z.string()) &#125;,  <span class="hljs-keyword">async</span> (&#123; filePaths &#125;) =&gt; &#123;    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`代码评审工具被调用，文件数量: <span class="hljs-subst">$&#123;filePaths.length&#125;</span>`</span>, LogLevel.INFO);    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`文件列表: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(filePaths)&#125;</span>`</span>, LogLevel.DEBUG);    <span class="hljs-keyword">const</span> results: ReviewResult[] = [];    <span class="hljs-keyword">const</span> errors: <span class="hljs-built_in">string</span>[] = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> filePath <span class="hljs-keyword">of</span> filePaths) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`开始处理文件: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>, LogLevel.INFO);        <span class="hljs-comment">// 检查文件是否存在</span>        <span class="hljs-keyword">const</span> exists = <span class="hljs-keyword">await</span> fileExists(filePath);        <span class="hljs-keyword">if</span> (!exists) &#123;          <span class="hljs-keyword">const</span> errorMsg = <span class="hljs-string">`文件不存在: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>;          errors.push(errorMsg);          <span class="hljs-keyword">await</span> logToFile(errorMsg, LogLevel.ERROR);          <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 读取文件内容</span>        <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> readFileContent(filePath);        <span class="hljs-comment">// 使用LLM分析所有类型的文件</span>        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> analyzeLLM(filePath, content);        <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`完成文件分析: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>, LogLevel.INFO);        results.push(result);      &#125; <span class="hljs-keyword">catch</span> (error) &#123;        <span class="hljs-keyword">const</span> errorMsg = <span class="hljs-string">`处理文件时出错 <span class="hljs-subst">$&#123;filePath&#125;</span>: <span class="hljs-subst">$&#123;error&#125;</span>`</span>;        <span class="hljs-keyword">await</span> logToFile(errorMsg, LogLevel.ERROR);        errors.push(errorMsg);      &#125;    &#125;    <span class="hljs-comment">// 构建响应</span>    <span class="hljs-keyword">const</span> response = &#123;      results,      errors,      <span class="hljs-attr">message</span>: <span class="hljs-string">`已分析 <span class="hljs-subst">$&#123;results.length&#125;</span> 个文件，失败 <span class="hljs-subst">$&#123;errors.length&#125;</span> 个文件`</span>,    &#125;;    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`代码评审完成，结果: <span class="hljs-subst">$&#123;response.message&#125;</span>`</span>, LogLevel.INFO);        <span class="hljs-keyword">return</span> &#123;      <span class="hljs-attr">content</span>: [&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-built_in">JSON</span>.stringify(response, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>) &#125;],    &#125;;  &#125;);<span class="hljs-comment">// 注册服务器连接事件</span><span class="hljs-comment">// server.on(&quot;connected&quot;, () =&gt; &#123;</span><span class="hljs-comment">//   logToFile(&quot;MCP服务器已连接，等待请求...&quot;, LogLevel.INFO);</span><span class="hljs-comment">// &#125;);</span><span class="hljs-comment">// server.on(&quot;error&quot;, (error) =&gt; &#123;</span><span class="hljs-comment">//   logToFile(`MCP服务器错误: $&#123;error&#125;`, LogLevel.ERROR);</span><span class="hljs-comment">// &#125;);</span><span class="hljs-keyword">const</span> transport = <span class="hljs-keyword">new</span> StdioServerTransport();<span class="hljs-comment">// 连接服务器并记录日志</span><span class="hljs-keyword">try</span> &#123;  <span class="hljs-keyword">await</span> server.connect(transport);  <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">&quot;MCP服务器已启动并连接&quot;</span>, LogLevel.INFO);&#125; <span class="hljs-keyword">catch</span> (error) &#123;  <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`MCP服务器连接失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>, LogLevel.ERROR);&#125;</code></pre></div></details><h3 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h3><p>经过多次测试，claude偶尔会出现路径主动把文件路径做了转换，导致tool找不到该文件进行读取：</p><details><summary>展开/收起</summary><div class="code-wrapper"><pre><code class="hljs json">工具参数&#123;  <span class="hljs-attr">&quot;filePaths&quot;</span>: [    <span class="hljs-string">&quot;/e:/DDI/project/Leader_Coach/src/views/home/component/chatScrollButton/chatScrollButton.vue&quot;</span>,    <span class="hljs-string">&quot;/e:/DDI/project/Leader_Coach/src/views/recommend/recommend.ts&quot;</span>  ]&#125;工具的返回&#123;  <span class="hljs-attr">&quot;results&quot;</span>: [],  <span class="hljs-attr">&quot;errors&quot;</span>: [    <span class="hljs-string">&quot;文件不存在: /e:/DDI/project/Leader_Coach/src/views/home/component/chatScrollButton/chatScrollButton.vue&quot;</span>,    <span class="hljs-string">&quot;文件不存在: /e:/DDI/project/Leader_Coach/src/views/recommend/recommend.ts&quot;</span>  ],  <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;已分析 0 个文件，失败 0 个文件&quot;</span>&#125;</code></pre></div></details><br>这时候找不到文件，message就不会显示分析了几个文件，失败了几个文件的提示;<p>优化方式，在tool代码增加路由格式转换：</p><details><summary>展开/收起</summary><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<span class="hljs-comment">// 示例路径（包含不同格式）</span><span class="hljs-keyword">const</span> testPaths = [    <span class="hljs-string">&quot;E:\\DDI\\project\\Leader_Coach\\src\\views\\recommend\\recommend.ts&quot;</span>, <span class="hljs-comment">// Windows原生</span>    <span class="hljs-string">&quot;/e:/DDI/project/Leader_Coach/src/views/home/component/chatScrollButton/chatScrollButton.vue&quot;</span>, <span class="hljs-comment">// 类Unix风格</span>];<span class="hljs-comment">// 路径规范化函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeCrossPlatformPath</span>(<span class="hljs-params">rawPath</span>) </span>&#123;    <span class="hljs-keyword">if</span> (rawPath.startsWith(<span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp; <span class="hljs-regexp">/^\/[a-zA-Z]:\//</span>.test(rawPath)) &#123;        rawPath = rawPath.substring(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> path.normalize(rawPath.replace(<span class="hljs-regexp">/[\\/]+/g</span>, path.sep));&#125;<span class="hljs-comment">// 检查文件是否存在</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkFileExists</span>(<span class="hljs-params">filePath</span>) </span>&#123;    <span class="hljs-keyword">const</span> normalizedPath = normalizeCrossPlatformPath(filePath);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`规范化结果: <span class="hljs-subst">$&#123;normalizedPath&#125;</span>`</span>);    <span class="hljs-keyword">return</span> fs.existsSync(normalizedPath);&#125;<span class="hljs-comment">// 测试所有路径</span>testPaths.forEach(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`原始路径: <span class="hljs-subst">$&#123;p&#125;</span>`</span>);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`是否存在: <span class="hljs-subst">$&#123;checkFileExists(p)&#125;</span>\n`</span>);&#125;);<span class="hljs-comment">// 打印结果</span><span class="hljs-comment">// 原始路径: E:\DDI\project\Leader_Coach\src\views\recommend\recommend.ts</span><span class="hljs-comment">// 规范化结果: E:\DDI\project\Leader_Coach\src\views\recommend\recommend.ts</span><span class="hljs-comment">// 是否存在: true</span><span class="hljs-comment">// 原始路径: /e:/DDI/project/Leader_Coach/src/views/home/component/chatScrollButton/chatScrollButton.vue</span><span class="hljs-comment">// 规范化结果: e:\DDI\project\Leader_Coach\src\views\home\component\chatScrollButton\chatScrollButton.vue</span><span class="hljs-comment">// 是否存在: true</span></code></pre></div></details><br>此时工具的完整调用记录：<details><summary>展开/收起</summary><div class="code-wrapper"><pre><code class="hljs json">ai调用工具传的参数：&#123;  <span class="hljs-attr">&quot;filePaths&quot;</span>: [    <span class="hljs-string">&quot;/e:/DDI/project/Leader_Coach/src/views/home/component/chatScrollButton/chatScrollButton.vue&quot;</span>,    <span class="hljs-string">&quot;/e:/DDI/project/Leader_Coach/src/views/recommend/recommend.ts&quot;</span>  ]&#125;工具的返回&#123;  <span class="hljs-attr">&quot;results&quot;</span>: [    &#123;      <span class="hljs-attr">&quot;filePath&quot;</span>: <span class="hljs-string">&quot;e:/DDI/project/Leader_Coach/src/views/home/component/chatScrollButton/chatScrollButton.vue&quot;</span>,      <span class="hljs-attr">&quot;llmResponse&quot;</span>: <span class="hljs-string">&quot;```markdown\n# 代码评审报告\n\n## 第一部分：文件汇总\n\n| 文件名 | 总行数 | 注释行数 | 注释率 | 可读性 | 一致性 | 模块化 | 可维护性 | 性能 | 文档化 | 平均分 |\n|--------|--------|----------|--------|--------|--------|--------|----------|------|--------|--------|\n| ChatScrollButton.vue | 56 | 7 | 12.5% | 9 | 9 | 8 | 8 | 8 | 8 | 8.3 |\n\n## 第二部分：详细评审\n\n### 文件功能描述\n这是一个Vue 3单文件组件，实现了一个带渐变边框效果的圆形滚动按钮，主要功能包括：\n- 通过`showGradient`属性控制是否显示旋转渐变边框\n- 内置悬停效果和默认边框样式\n- 包含向下的箭头图标\n\n### 质量评分说明\n\n1. **可读性（9/10）**\n   - 代码结构清晰，模板/脚本/样式分离良好\n   - CSS选择器命名语义化明确（如`.scroll-bottom-button-default`）\n   - 改进建议：动画关键帧可以添加注释说明\n\n2. **一致性（9/10）**\n   - 整体遵循Vue 3组合式API规范\n   - CSS变量命名风格统一（`--color-*`）\n   - 少量不一致：模板中同时使用了`:class`和`:style`绑定，建议统一使用一种方式\n\n3. **模块化（8/10）**\n   - 组件功能单一且完整\n   - 可以进一步拆分：将复杂的渐变边框CSS提取为mixin或工具类\n\n4. **可维护性（8/10）**\n   - 类型定义完善（TypeScript接口）\n   - 默认值处理规范\n   - 改进点：缺少emit事件定义说明\n\n5. **性能（8/10）**\n   - 使用了CSS动画而非JS动画\n   - 建议：`background-image`使用雪碧图优化\n\n6. **文档化（8/10）**\n   - 组件级注释完整（包含@description和@example）\n   - 属性有TSDoc注释\n   - 缺少：CSS复杂效果的实现原理说明\n\n## 第三部分：总结\n\n该组件整体质量较高，主要优点：\n- 良好的类型定义和文档注释\n- 视觉效果实现优雅（CSS渐变+遮罩技巧）\n- 响应式交互设计完整\n\n改进建议：\n1. 补充CSS动画实现的原理注释\n2. 统一样式控制方式（优先使用class）\n3. 考虑添加点击事件发射处理\n4. 图片资源建议使用雪碧图优化\n\n总体评分：8.3/10（优质组件，小优化空间）\n```&quot;</span>,      <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;对 chatScrollButton.vue 的代码评审完成&quot;</span>    &#125;,    &#123;      <span class="hljs-attr">&quot;filePath&quot;</span>: <span class="hljs-string">&quot;e:/DDI/project/Leader_Coach/src/views/recommend/recommend.ts&quot;</span>,      <span class="hljs-attr">&quot;llmResponse&quot;</span>: <span class="hljs-string">&quot;## 代码评审报告\n\n### 第一部分：文件汇总\n\n| 文件类型 | 总行数 | 注释行数 | 注释率 | 可读性 | 一致性 | 模块化 | 可维护性 | 性能 | 文档化 | 平均分 |\n|----------|--------|----------|--------|--------|--------|--------|----------|------|--------|--------|\n| .ts      | 252    | 10       | 3.97%  | 7      | 8      | 6      | 7        | 8    | 5      | 6.8    |\n\n### 第二部分：详细分析\n\n#### 1. 文件功能描述\n这是一个Vue 3组件，主要功能是：\n- 实现一个推荐教练的表单页面\n- 包含职位选择、教练风格选择、管理话题选择等表单字段\n- 处理表单验证和提交\n- 与后端API交互获取推荐结果\n\n#### 2. 质量评分及说明\n\n**可读性 (7/10)**\n- 优点：变量命名清晰，基本能反映其用途\n- 缺点：长数组定义影响可读性，部分逻辑可以进一步拆分\n\n**一致性 (8/10)**\n- 优点：整体编码风格一致，使用Vue 3组合式API\n- 缺点：部分方法使用选项式API(methods)，与setup()混合使用\n\n**模块化 (6/10)**\n- 优点：组件导入清晰\n- 缺点：大量选项数据直接定义在组件中，可以考虑外部化\n\n**可维护性 (7/10)**\n- 优点：功能划分明确\n- 缺点：表单验证逻辑较复杂，可以提取为独立函数\n\n**性能 (8/10)**\n- 优点：合理使用响应式数据\n- 缺点：watch中使用JSON.parse(JSON.stringify())可能影响性能\n\n**文档化 (5/10)**\n- 优点：关键方法有注释说明\n- 缺点：整体注释率低(3.97%)，部分复杂逻辑缺乏解释\n\n### 第三部分：总结与建议\n\n1. **主要问题**：\n   - 注释率偏低(3.97%)\n   - 长数组定义影响可读性\n   - 混合使用组合式API和选项式API\n   - 表单验证逻辑可以优化\n\n2. **改进建议**：\n   - 将长数组(jobOptions等)提取到单独的文件或配置中\n   - 增加关键逻辑的注释说明\n   - 统一使用组合式API\n   - 提取表单验证逻辑为独立函数\n   - 考虑使用TypeScript接口定义复杂数据结构\n\n3. **亮点**：\n   - 整体结构清晰\n   - 响应式数据处理得当\n   - 错误处理机制完善\n\n总体评分为6.8分，是一个质量中等的组件，通过一些重构可以显著提高可维护性和可读性。&quot;</span>,      <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;对 recommend.ts 的代码评审完成&quot;</span>    &#125;  ],  <span class="hljs-attr">&quot;errors&quot;</span>: [],  <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;已分析 2 个文件，失败 0 个文件&quot;</span>&#125;</code></pre></div></details><br>可以看到分析结果和分析记录（分析了几个文件等）输出结果的markdown格式：<details><summary>展开/收起</summary><div class="code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 代码评审报告</span><span class="hljs-section">## 第一部分：文件汇总</span>| 文件名 | 总行数 | 注释行数 | 注释率 | 可读性 | 一致性 | 模块化 | 可维护性 | 性能 | 文档化 | 平均分 ||--------|--------|----------|--------|--------|--------|--------|----------|------|--------|--------|| ChatScrollButton.vue | 56 | 7 | 12.5% | 9 | 9 | 8 | 8 | 8 | 8 | 8.3 |<span class="hljs-section">## 第二部分：详细评审</span><span class="hljs-section">### 文件功能描述</span>这是一个Vue 3单文件组件，实现了一个带渐变边框效果的圆形滚动按钮，主要功能包括：<span class="hljs-bullet">-</span> 通过<span class="hljs-code">`showGradient`</span>属性控制是否显示旋转渐变边框<span class="hljs-bullet">-</span> 内置悬停效果和默认边框样式<span class="hljs-bullet">-</span> 包含向下的箭头图标<span class="hljs-section">### 质量评分说明</span><span class="hljs-bullet">1.</span> <span class="hljs-strong">**可读性（9/10）**</span><span class="hljs-bullet">   -</span> 代码结构清晰，模板/脚本/样式分离良好<span class="hljs-bullet">   -</span> CSS选择器命名语义化明确（如<span class="hljs-code">`.scroll-bottom-button-default`</span>）<span class="hljs-bullet">   -</span> 改进建议：动画关键帧可以添加注释说明<span class="hljs-bullet">2.</span> <span class="hljs-strong">**一致性（9/10）**</span><span class="hljs-bullet">   -</span> 整体遵循Vue 3组合式API规范<span class="hljs-bullet">   -</span> CSS变量命名风格统一（<span class="hljs-code">`--color-*`</span>）<span class="hljs-bullet">   -</span> 少量不一致：模板中同时使用了<span class="hljs-code">`:class`</span>和<span class="hljs-code">`:style`</span>绑定，建议统一使用一种方式<span class="hljs-bullet">3.</span> <span class="hljs-strong">**模块化（8/10）**</span><span class="hljs-bullet">   -</span> 组件功能单一且完整<span class="hljs-bullet">   -</span> 可以进一步拆分：将复杂的渐变边框CSS提取为mixin或工具类<span class="hljs-bullet">4.</span> <span class="hljs-strong">**可维护性（8/10）**</span><span class="hljs-bullet">   -</span> 类型定义完善（TypeScript接口）<span class="hljs-bullet">   -</span> 默认值处理规范<span class="hljs-bullet">   -</span> 改进点：缺少emit事件定义说明<span class="hljs-bullet">5.</span> <span class="hljs-strong">**性能（8/10）**</span><span class="hljs-bullet">   -</span> 使用了CSS动画而非JS动画<span class="hljs-bullet">   -</span> 建议：<span class="hljs-code">`background-image`</span>使用雪碧图优化<span class="hljs-bullet">6.</span> <span class="hljs-strong">**文档化（8/10）**</span><span class="hljs-bullet">   -</span> 组件级注释完整（包含@description和@example）<span class="hljs-bullet">   -</span> 属性有TSDoc注释<span class="hljs-bullet">   -</span> 缺少：CSS复杂效果的实现原理说明<span class="hljs-section">## 第三部分：总结</span>该组件整体质量较高，主要优点：<span class="hljs-bullet">-</span> 良好的类型定义和文档注释<span class="hljs-bullet">-</span> 视觉效果实现优雅（CSS渐变+遮罩技巧）<span class="hljs-bullet">-</span> 响应式交互设计完整改进建议：<span class="hljs-bullet">1.</span> 补充CSS动画实现的原理注释<span class="hljs-bullet">2.</span> 统一样式控制方式（优先使用class）<span class="hljs-bullet">3.</span> 考虑添加点击事件发射处理<span class="hljs-bullet">4.</span> 图片资源建议使用雪碧图优化总体评分：8.3/10（优质组件，小优化空间）---<span class="hljs-section">## recommend.ts 代码评审报告</span><span class="hljs-section">### 第一部分：文件汇总</span>| 文件类型 | 总行数 | 注释行数 | 注释率 | 可读性 | 一致性 | 模块化 | 可维护性 | 性能 | 文档化 | 平均分 ||----------|--------|----------|--------|--------|--------|--------|----------|------|--------|--------|| .ts      | 252    | 10       | 3.97%  | 7      | 8      | 6      | 7        | 8    | 5      | 6.8    |<span class="hljs-section">### 第二部分：详细分析</span><span class="hljs-section">#### 1. 文件功能描述</span>这是一个Vue 3组件，主要功能是：<span class="hljs-bullet">-</span> 实现一个推荐教练的表单页面<span class="hljs-bullet">-</span> 包含职位选择、教练风格选择、管理话题选择等表单字段<span class="hljs-bullet">-</span> 处理表单验证和提交<span class="hljs-bullet">-</span> 与后端API交互获取推荐结果<span class="hljs-section">#### 2. 质量评分及说明</span><span class="hljs-strong">**可读性 (7/10)**</span><span class="hljs-bullet">-</span> 优点：变量命名清晰，基本能反映其用途<span class="hljs-bullet">-</span> 缺点：长数组定义影响可读性，部分逻辑可以进一步拆分<span class="hljs-strong">**一致性 (8/10)**</span><span class="hljs-bullet">-</span> 优点：整体编码风格一致，使用Vue 3组合式API<span class="hljs-bullet">-</span> 缺点：部分方法使用选项式API(methods)，与setup()混合使用<span class="hljs-strong">**模块化 (6/10)**</span><span class="hljs-bullet">-</span> 优点：组件导入清晰<span class="hljs-bullet">-</span> 缺点：大量选项数据直接定义在组件中，可以考虑外部化<span class="hljs-strong">**可维护性 (7/10)**</span><span class="hljs-bullet">-</span> 优点：功能划分明确<span class="hljs-bullet">-</span> 缺点：表单验证逻辑较复杂，可以提取为独立函数<span class="hljs-strong">**性能 (8/10)**</span><span class="hljs-bullet">-</span> 优点：合理使用响应式数据<span class="hljs-bullet">-</span> 缺点：watch中使用JSON.parse(JSON.stringify())可能影响性能<span class="hljs-strong">**文档化 (5/10)**</span><span class="hljs-bullet">-</span> 优点：关键方法有注释说明<span class="hljs-bullet">-</span> 缺点：整体注释率低(3.97%)，部分复杂逻辑缺乏解释<span class="hljs-section">### 第三部分：总结与建议</span><span class="hljs-bullet">1.</span> <span class="hljs-strong">**主要问题**</span>：<span class="hljs-bullet">   -</span> 注释率偏低(3.97%)<span class="hljs-bullet">   -</span> 长数组定义影响可读性<span class="hljs-bullet">   -</span> 混合使用组合式API和选项式API<span class="hljs-bullet">   -</span> 表单验证逻辑可以优化<span class="hljs-bullet">2.</span> <span class="hljs-strong">**改进建议**</span>：<span class="hljs-bullet">   -</span> 将长数组(jobOptions等)提取到单独的文件或配置中<span class="hljs-bullet">   -</span> 增加关键逻辑的注释说明<span class="hljs-bullet">   -</span> 统一使用组合式API<span class="hljs-bullet">   -</span> 提取表单验证逻辑为独立函数<span class="hljs-bullet">   -</span> 考虑使用TypeScript接口定义复杂数据结构<span class="hljs-bullet">3.</span> <span class="hljs-strong">**亮点**</span>：<span class="hljs-bullet">   -</span> 整体结构清晰<span class="hljs-bullet">   -</span> 响应式数据处理得当<span class="hljs-bullet">   -</span> 错误处理机制完善总体评分为6.8分，是一个质量中等的组件，通过一些重构可以显著提高可维护性和可读性。</code></pre></div></details><br><h3 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h3><p>再次经过多次测试，每次LLM统计行数和注释率都不一样，这里引入一个node-sloc的npm包进行处理文件统计的不规律的问题：</p><details><summary>展开/收起</summary><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; sloc &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node-sloc&#x27;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 代码行数统计结果接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">interface</span> SlocResult &#123;  <span class="hljs-comment">/** 统计的文件路径列表 */</span>  <span class="hljs-attr">paths</span>: <span class="hljs-built_in">string</span>[];  <span class="hljs-comment">/** 统计的文件数量 */</span>  files: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">/** 代码行数（不包含注释和空行） */</span>  sloc: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">/** 注释行数 */</span>  comments: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">/** 空行数 */</span>  blank: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">/** 总行数（代码+注释+空行） */</span>  loc: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 扩展的统计结果接口，包含注释率计算</span><span class="hljs-comment"> */</span><span class="hljs-keyword">interface</span> ExtendedSlocResult <span class="hljs-keyword">extends</span> SlocResult &#123;  <span class="hljs-comment">/** 注释行数占总行数的比率 */</span>  <span class="hljs-attr">commentsToTotalRatio</span>: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">/** 注释行数占代码行数的比率 */</span>  commentsToCodeRatio: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 统计指定文件的代码行数和注释比率</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">filePath</span></span> - 需要统计的文件路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>Promise&lt;ExtendedSlocResult&gt; 返回统计结果，包含代码行数、注释行数、空行数及注释比率</span><span class="hljs-comment"> */</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countCodeLines</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ExtendedSlocResult</span>&gt; </span>&#123;  <span class="hljs-keyword">const</span> options = &#123;    <span class="hljs-attr">path</span>: filePath  &#125;;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> sloc(options);        <span class="hljs-keyword">if</span>(!result) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;统计结果为空&#x27;</span>);    &#125;    <span class="hljs-comment">// 计算注释比率</span>    <span class="hljs-keyword">const</span> commentsToTotalRatio = <span class="hljs-built_in">Number</span>((result.comments / result.loc).toFixed(<span class="hljs-number">2</span>));    <span class="hljs-keyword">const</span> commentsToCodeRatio = <span class="hljs-built_in">Number</span>((result.comments / result.sloc).toFixed(<span class="hljs-number">2</span>));    <span class="hljs-keyword">return</span> &#123;      ...result,      commentsToTotalRatio,      commentsToCodeRatio    &#125;;  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`统计代码行数失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);  &#125;&#125;<span class="hljs-keyword">export</span> &#123; countCodeLines &#125;;<span class="hljs-comment">// 使用示例</span><span class="hljs-comment">// const filePath = &#x27;E:\\DDI\\project\\Leader_Coach\\src\\views\\recommend\\recommend.ts&#x27;;</span><span class="hljs-comment">// countCodeLines(filePath)</span><span class="hljs-comment">//   .then((result) =&gt; &#123;</span><span class="hljs-comment">//     console.log(&#x27;文件路径:&#x27;, result.paths);</span><span class="hljs-comment">//     console.log(&#x27;文件数量:&#x27;, result.files);</span><span class="hljs-comment">//     console.log(&#x27;代码行数:&#x27;, result.sloc);</span><span class="hljs-comment">//     console.log(&#x27;注释行数:&#x27;, result.comments);</span><span class="hljs-comment">//     console.log(&#x27;空行数:&#x27;, result.blank);</span><span class="hljs-comment">//     console.log(&#x27;总行数:&#x27;, result.loc);</span><span class="hljs-comment">//     console.log(&#x27;注释行数/总行数:&#x27;, `$&#123;result.commentsToTotalRatio * 100&#125;%`);</span><span class="hljs-comment">//     console.log(&#x27;注释行数/代码行数:&#x27;, `$&#123;result.commentsToCodeRatio * 100&#125;%`);</span><span class="hljs-comment">//   &#125;)</span><span class="hljs-comment">//   .catch((error) =&gt; &#123;</span><span class="hljs-comment">//     console.error(&#x27;错误:&#x27;, error);</span><span class="hljs-comment">//   &#125;); </span></code></pre></div></details><br>同一个文件两种效果对比：<p><img src="/img/blog/AI/review_code_mcp/1.png"></p><h3 id="第三个问题"><a href="#第三个问题" class="headerlink" title="第三个问题"></a>第三个问题</h3><p>再次测试，发现node-sloc默认不支持 .vue 文件，见文档地址：<a href="https://github.com/edvinh/node-sloc">https://github.com/edvinh/node-sloc</a><br><img src="/img/blog/AI/review_code_mcp/2.png"><br>这里经过配置，解决AI统计行数和注释率高低飘忽不定的这个问题：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> options = &#123;  <span class="hljs-attr">path</span>: filePath,  <span class="hljs-comment">// 手动添加对Vue文件的支持</span>  <span class="hljs-attr">extensions</span>: [ <span class="hljs-string">&#x27;.vue&#x27;</span>],  <span class="hljs-attr">ignorePaths</span>: [<span class="hljs-string">&#x27;node_modules&#x27;</span>, <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-string">&#x27;build&#x27;</span>]&#125;;</code></pre></div><p><img src="/img/blog/AI/review_code_mcp/3.png"><br><img src="/img/blog/AI/review_code_mcp/4.png"></p><h3 id="第四个问题"><a href="#第四个问题" class="headerlink" title="第四个问题"></a>第四个问题</h3><p>将这个mcp server给别人使用的问题：目前vscode（需要装插件）和cursor（新版本支持）支持MCP的json配置，也有一些集成工具比如Cherry Studio支持MCP配置（<a href="https://docs.cherry-ai.com/advanced-basic/mcp">https://docs.cherry-ai.com/advanced-basic/mcp</a> ），但目前看上去jetbrains的IDE还未支持，如果开发人员目前使用的是jetbrains公司下的IDE的话就没法使用这种json配置方式了，但可以通过本地启动一个调试工具页面来使用：</p><p>通过官方MCP Inspector调试工具（<a href="https://github.com/modelcontextprotocol/inspector">https://github.com/modelcontextprotocol/inspector</a> ）进行调试和使用MCP Server</p><p>先build ts文件，然后运行命令（node后面的参数为构建后的js路径）：</p><div class="code-wrapper"><pre><code class="hljs bash">npx -y @modelcontextprotocol/inspector node <span class="hljs-string">&quot;dist/mcp_code_review_sse.js&quot;</span></code></pre></div><p>控制台输出：</p><div class="code-wrapper"><pre><code class="hljs bash">Starting MCP inspector...Proxy server listening on port 3000🔍 MCP Inspector is up and running at http://localhost:5173 🚀</code></pre></div><p>访问<a href="http://localhost:5173/">http://localhost:5173</a></p><p><img src="/img/blog/AI/review_code_mcp/5.png"><br><img src="/img/blog/AI/review_code_mcp/6.png"><br>这里报错【文件不存在】是因为参数里有双引号：<br><img src="/img/blog/AI/review_code_mcp/7.png"></p><h3 id="第五个问题"><a href="#第五个问题" class="headerlink" title="第五个问题"></a>第五个问题</h3><p>日志调试问题：server端打印的console.log代码不生效，且cursor配置server里带有console.log的mcp后会报错，但流程不影响，可以正常调用和输出，网上搜索也没有找到相关讨论；<br>然后看下面文档的要求像是需要由客户端来进行接收打印消息来调试的；</p><p><img src="/img/blog/AI/review_code_mcp/8.png"><br><img src="/img/blog/AI/review_code_mcp/9.png"></p><p>开发client文档<br><a href="https://github.com/cyanheads/model-context-protocol-resources/blob/main/guides/mcp-client-development-guide.md">https://github.com/cyanheads/model-context-protocol-resources/blob/main/guides/mcp-client-development-guide.md</a></p><p>开发server文档<br><a href="https://github.com/cyanheads/model-context-protocol-resources/blob/main/guides/mcp-server-development-guide.md">https://github.com/cyanheads/model-context-protocol-resources/blob/main/guides/mcp-server-development-guide.md</a></p><p>通过查看文档和源码，其实默认是可以通过consoel.error打印的内容被输出在页面上的，用这种方式把执行的每一步都用error的方式打印出来；官方目前只支持’debug’ | ‘info’ | ‘warn’ | ‘error’ ；</p><p><strong>不同SDK的推送日志的方式</strong> ：</p><h4 id="McpServer-SDK"><a href="#McpServer-SDK" class="headerlink" title="McpServer SDK"></a>McpServer SDK</h4><p>如果是使用官网demo里的的McpServer sdk:</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; McpServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/mcp.js&quot;</span>;</code></pre></div><p>第一种方式：</p><p>打印error</p><p>如果想要有其他log level，需要自行查看源码或文档进行处理，这里只演示error</p><p>第二种方式，配置server的option：</p><p>首先对MCPserver的option进行设置：</p><p>设置logging 的 message 设置为true：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> McpServer(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;代码评审工具&quot;</span>,  <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;0.1.0&quot;</span>,&#125;, &#123;  <span class="hljs-attr">capabilities</span>: &#123;      <span class="hljs-attr">tools</span>: &#123;&#125;,      <span class="hljs-attr">logging</span>: &#123;          <span class="hljs-attr">message</span>: <span class="hljs-literal">true</span>      &#125;  &#125;&#125;);</code></pre></div><p>在代码里tool接受参数的地方打印传参：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> exists = <span class="hljs-keyword">await</span> fileExists(filePath);<span class="hljs-built_in">console</span>.error(filePaths);server.server.sendLoggingMessage(&#123;  <span class="hljs-attr">level</span>: <span class="hljs-string">&quot;info&quot;</span>,  <span class="hljs-attr">data</span>: <span class="hljs-string">`文件存在: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>,&#125;);</code></pre></div><p><img src="/img/blog/AI/review_code_mcp/10.png"></p><h4 id="低版本Server-SDK"><a href="#低版本Server-SDK" class="headerlink" title="低版本Server SDK"></a>低版本Server SDK</h4><p>然后通过查看<a href="https://github.com/modelcontextprotocol/servers">https://github.com/modelcontextprotocol/servers</a>   一些开源的MCP Server的源码，发现他们使用的typescript sdk不是官网的方式</p><p>而是使用下面这种方式自行编写tool调用规则和参数校验等，这种也是支持使用console.error进行打印的，同时也可以使用推送log的方式：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Server &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/index.js&quot;</span>;</code></pre></div><p>如果是使用这种SDK，和上面McpServer一样对server进行配置：</p><p>把logging 的 message 设置为true：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> Server(  &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;代码评审工具&quot;</span>,    <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;0.1.0&quot;</span>,  &#125;,  &#123;    <span class="hljs-attr">capabilities</span>: &#123;      <span class="hljs-attr">tools</span>: &#123;&#125;,      <span class="hljs-attr">logging</span>: &#123;        <span class="hljs-attr">message</span>: <span class="hljs-literal">true</span>      &#125;    &#125;  &#125;);</code></pre></div><p>然后再使用这种方式推送log到客户端：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> &#123; filePaths &#125; = args;server.sendLoggingMessage(&#123;  <span class="hljs-attr">level</span>: <span class="hljs-string">&quot;info&quot;</span>,  <span class="hljs-attr">message</span>: <span class="hljs-string">`开始评审文件: <span class="hljs-subst">$&#123;filePaths&#125;</span>`</span>&#125;);</code></pre></div><p><img src="/img/blog/AI/review_code_mcp/11.png"></p><p>使用这种自定义的SDK（非上面的McpServer）在cursor里也是可以正常使用的：<br><img src="/img/blog/AI/review_code_mcp/12.png"></p><h3 id="第六个问题"><a href="#第六个问题" class="headerlink" title="第六个问题"></a>第六个问题</h3><p>这一版改完，测试时偶尔会碰到页面执行超时，但cursor里测试流程正常：<br><img src="/img/blog/AI/review_code_mcp/13.png"></p><p>神奇的是再稍等几分钟就能看到服务器推送到log到调试平台，里面是有打印LLM的审查结果输出的，但在页面上却是等不到LLM的返回就报timeout了，不确定是不是这个调试工具的延迟设置的问题还是代码上的某些地方的异步调用问题；（待深入排查）</p><p><img src="/img/blog/AI/review_code_mcp/14.png"></p><p>经过查看和运行官方调试工具的源码<a href="https://github.com/modelcontextprotocol/inspector/tree/main">https://github.com/modelcontextprotocol/inspector/tree/main</a> </p><p>发现在APP.tsx里调用了工具方法，但没传超时时间，在封装的useConnection.ts脚本里设置的默认是10s，我手动改成100s，然后尝试：<br><img src="/img/blog/AI/review_code_mcp/15.png"></p><p>正常的输出位置是在这里的，所以应该是官方需要解决的一个问题：<br><img src="/img/blog/AI/review_code_mcp/16.png"></p><p>这个timeout暂时先忽略吧，看官方是否优化，如果要想在页面上知道是否已经结束（页面连个loading也没有，体验差劲哈哈哈），可以通过编写一个定时器，每隔一秒推送以下消息来知道当前还没结束：</p><div class="code-wrapper"><pre><code class="hljs typescript">server.server.sendLoggingMessage(&#123;      <span class="hljs-attr">level</span>: <span class="hljs-string">&quot;info&quot;</span>,      <span class="hljs-attr">data</span>: <span class="hljs-string">`等待LLM返回中`</span>    &#125;);</code></pre></div><h3 id="待发展问题-："><a href="#待发展问题-：" class="headerlink" title="待发展问题 ："></a>待发展问题 ：</h3><p>1.是否要部署到公司服务器，如果部署到网上需要的优化项</p><ul><li>mcp.json需要带上token，加一层防护</li><li>服务器上如何读取要review的代码</li><li>服务器上需要将结果进行保存到某个地方</li></ul><h2 id="解决所有问题后完整代码"><a href="#解决所有问题后完整代码" class="headerlink" title="解决所有问题后完整代码"></a>解决所有问题后完整代码</h2><p>主文件：mcp_code_review.ts</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> OpenAI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;openai&#x27;</span>;<span class="hljs-keyword">import</span> &#123; McpServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/mcp.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; StdioServerTransport &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/stdio.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; z &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zod&quot;</span>;<span class="hljs-keyword">import</span> &#123; promises <span class="hljs-keyword">as</span> fs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;<span class="hljs-keyword">import</span> &#123; countCodeLines &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./sloc_tool.js&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建MCP服务器实例</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> McpServer(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;代码评审工具&quot;</span>,  <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;0.1.0&quot;</span>,&#125;, &#123;  <span class="hljs-attr">capabilities</span>: &#123;    <span class="hljs-attr">tools</span>: &#123;&#125;,    <span class="hljs-attr">logging</span>: &#123;      <span class="hljs-attr">message</span>: <span class="hljs-literal">true</span>    &#125;  &#125;&#125;);<span class="hljs-comment">// Check for API key and baseURL</span><span class="hljs-comment">// 这里调试时可以手动替换掉来自env的配置</span><span class="hljs-comment">//  || &quot;11111111111111111111111&quot;</span><span class="hljs-comment">//  || &quot;https://xxxxxx/api/v1&quot;</span><span class="hljs-comment">//  || &quot;qwen/qwen-2.5-coder-32b-instruct:free&quot;</span><span class="hljs-keyword">const</span> OPENAI_API_KEY = process.env.OPENAI_API_KEY!;<span class="hljs-keyword">const</span> OPENAI_API_BASE = process.env.OPENAI_API_BASE!;<span class="hljs-keyword">const</span> OPENAI_API_MODEL = process.env.OPENAI_API_MODEL!;<span class="hljs-keyword">if</span> (!OPENAI_API_KEY || !OPENAI_API_BASE) &#123;  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Error: OPENAI_API_KEY or OPENAI_API_BASE environment variable is required&quot;</span>);  process.exit(<span class="hljs-number">1</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 读取文件内容</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">filePath</span></span> - 文件的绝对路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;string&gt;&#125;</span> </span>文件内容</span><span class="hljs-comment"> */</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readFileContent</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">string</span>&gt; </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> fs.readFile(filePath, <span class="hljs-string">&quot;utf-8&quot;</span>);    <span class="hljs-keyword">return</span> content;  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`无法读取文件 <span class="hljs-subst">$&#123;filePath&#125;</span>: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 路径规范化函数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">rawPath</span></span> - 原始路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;string&#125;</span> </span>规范化后的路径</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeCrossPlatformPath</span>(<span class="hljs-params">rawPath: <span class="hljs-built_in">string</span></span>) </span>&#123;  <span class="hljs-keyword">if</span> (rawPath.startsWith(<span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp; <span class="hljs-regexp">/^\/[a-zA-Z]:\//</span>.test(rawPath)) &#123;    rawPath = rawPath.substring(<span class="hljs-number">1</span>);  &#125;  <span class="hljs-keyword">return</span> path.normalize(rawPath.replace(<span class="hljs-regexp">/[\\/]+/g</span>, path.sep));&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 检查文件是否存在</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">filePath</span></span> - 文件的绝对路径 </span><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;boolean&gt;&#125;</span> </span>文件是否存在</span><span class="hljs-comment"> */</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fileExists</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">boolean</span>&gt; </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">await</span> fs.access(filePath);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 使用大语言模型分析代码</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">filePath</span></span> - 文件路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">content</span></span> - 文件内容</span><span class="hljs-comment"> */</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">analyzeLLM</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span>, content: <span class="hljs-built_in">string</span></span>) </span>&#123;  <span class="hljs-comment">// 提取文件类型</span>  <span class="hljs-keyword">const</span> extension = path.extname(filePath).toLowerCase();  <span class="hljs-comment">// 统计代码行数和注释率</span>  <span class="hljs-keyword">const</span> &#123; sloc, comments, blank, loc, commentsToTotalRatio, commentsToCodeRatio &#125; = <span class="hljs-keyword">await</span> countCodeLines(filePath);  <span class="hljs-comment">// 构建提示词</span>  <span class="hljs-keyword">const</span> prompt = <span class="hljs-string">`</span><span class="hljs-string">    ## 根据要求对以下<span class="hljs-subst">$&#123;extension&#125;</span>代码进行代码评审，识别潜在的问题。</span><span class="hljs-string">    以下是代码行数和注释率：</span><span class="hljs-string">    文件名：<span class="hljs-subst">$&#123;path.basename(filePath)&#125;</span></span><span class="hljs-string">    总行数：<span class="hljs-subst">$&#123;loc&#125;</span></span><span class="hljs-string">    注释行数：<span class="hljs-subst">$&#123;comments&#125;</span></span><span class="hljs-string">    代码行数：<span class="hljs-subst">$&#123;sloc&#125;</span></span><span class="hljs-string">    总注释率（注释行数/总行数）：<span class="hljs-subst">$&#123;commentsToTotalRatio&#125;</span></span><span class="hljs-string">    代码行数注释率（注释行数/代码行数）：<span class="hljs-subst">$&#123;commentsToCodeRatio&#125;</span></span><span class="hljs-string">    要求：</span><span class="hljs-string">    1.**评价代码质量**：</span><span class="hljs-string">      在以下六个方面进行评分（0到10分），并给出平均分：</span><span class="hljs-string">      - **可读性（Readability）**：代码易于理解程度。</span><span class="hljs-string">      - **一致性（Consistency）**：编码风格和命名的一致性。</span><span class="hljs-string">      - **模块化（Modularity）**：代码分块和功能单元划分。</span><span class="hljs-string">      - **可维护性（Maintainability）**：代码易于修改和扩展的能力。</span><span class="hljs-string">      - **性能（Performance）**：代码执行效率。</span><span class="hljs-string">      - **文档化（Documentation）**：代码附带的说明和文档质量。</span><span class="hljs-string">    2. **生成总体报告**：</span><span class="hljs-string">      - 将所有分步信息整理成一个markdown结构。</span><span class="hljs-string">      - 内容应包括：第一部分：文件列表汇总（每个文件的总行数、注释行数、代码行数、总注释率、代码行数注释率评分， 6维评分，得分比较低或者行数比较多；第二部分每一个文件的功能描述，以及在六个质量因素上的评分以及说明；第三部分，总结</span><span class="hljs-string"></span><span class="hljs-string">      以下是要评审的代码：</span><span class="hljs-string">      \`\`\`</span><span class="hljs-string">      <span class="hljs-subst">$&#123;extension&#125;</span></span><span class="hljs-string">      <span class="hljs-subst">$&#123;content&#125;</span></span><span class="hljs-string">      \`\`\`</span><span class="hljs-string">    `</span>;  <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> OpenAI(&#123;    <span class="hljs-attr">apiKey</span>: OPENAI_API_KEY,    <span class="hljs-attr">baseURL</span>: OPENAI_API_BASE,  &#125;);  <span class="hljs-keyword">const</span> llmResponse = <span class="hljs-keyword">await</span> client.chat.completions.create(&#123;    <span class="hljs-attr">model</span>: OPENAI_API_MODEL,    <span class="hljs-attr">temperature</span>: <span class="hljs-number">0.1</span>,    <span class="hljs-attr">messages</span>: [      &#123;        <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>,        <span class="hljs-attr">content</span>: prompt,      &#125;,    ],  &#125;);  server.server.sendLoggingMessage(&#123;    <span class="hljs-attr">level</span>: <span class="hljs-string">&quot;info&quot;</span>,    <span class="hljs-attr">data</span>: <span class="hljs-string">`llm结束: <span class="hljs-subst">$&#123;llmResponse.choices[<span class="hljs-number">0</span>].message.content&#125;</span>`</span>  &#125;);  <span class="hljs-keyword">let</span> llmMessage = llmResponse.choices &amp;&amp; llmResponse.choices.length &gt; <span class="hljs-number">0</span> ? llmResponse.choices[<span class="hljs-number">0</span>].message.content : <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">if</span> (!llmMessage) &#123;    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`LLM响应内容为空`</span>);    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;LLM响应为空&quot;</span>);  &#125;  <span class="hljs-keyword">return</span> &#123;    filePath,    <span class="hljs-attr">llmResponse</span>: llmMessage,    <span class="hljs-attr">message</span>: <span class="hljs-string">`对 <span class="hljs-subst">$&#123;path.basename(filePath)&#125;</span> 的代码评审完成`</span>,  &#125;;&#125;<span class="hljs-comment">// 分离结果和错误</span><span class="hljs-comment">// 定义结果类型</span><span class="hljs-keyword">type</span> ProcessResult = &#123;  <span class="hljs-attr">filePath</span>: <span class="hljs-built_in">string</span>;  llmResponse: <span class="hljs-built_in">string</span>;  message: <span class="hljs-built_in">string</span>;  error?: <span class="hljs-built_in">string</span>;&#125;;<span class="hljs-comment">// 将文件处理逻辑封装成独立函数</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFile</span>(<span class="hljs-params">fp: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ProcessResult</span>&gt; </span>&#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">let</span> rawPath = <span class="hljs-built_in">String</span>.raw<span class="hljs-string">`<span class="hljs-subst">$&#123;fp&#125;</span>`</span>;<span class="hljs-comment">// 使用原始字符串标记</span>    <span class="hljs-keyword">let</span> filePath = normalizeCrossPlatformPath(rawPath);<span class="hljs-comment">// 将所有反斜杠替换为正斜杠，Node.js可以在所有平台上理解</span>    <span class="hljs-comment">// 检查文件是否存在</span>    <span class="hljs-keyword">const</span> exists = <span class="hljs-keyword">await</span> fileExists(filePath);    server.server.sendLoggingMessage(&#123;      <span class="hljs-attr">level</span>: <span class="hljs-string">&quot;info&quot;</span>,      <span class="hljs-attr">data</span>: <span class="hljs-string">`需要review的文件是否存在: <span class="hljs-subst">$&#123;exists&#125;</span>`</span>,    &#125;);    <span class="hljs-keyword">if</span> (!exists) &#123;      <span class="hljs-keyword">const</span> errorMsg = <span class="hljs-string">`文件不存在: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>;      <span class="hljs-built_in">console</span>.error(errorMsg);      <span class="hljs-keyword">return</span> &#123;        <span class="hljs-attr">filePath</span>: fp,        <span class="hljs-attr">llmResponse</span>: <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-attr">message</span>: <span class="hljs-string">`LLM分析失败: <span class="hljs-subst">$&#123;errorMsg&#125;</span>`</span>,        <span class="hljs-attr">error</span>: errorMsg      &#125;;    &#125;    <span class="hljs-comment">// 读取文件内容</span>    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> readFileContent(filePath);    <span class="hljs-comment">// 使用LLM分析文件</span>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> analyzeLLM(filePath, content);    <span class="hljs-keyword">return</span> result;  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-keyword">const</span> errorMsg = <span class="hljs-string">`LLM分析失败： <span class="hljs-subst">$&#123;fp&#125;</span>: <span class="hljs-subst">$&#123;error&#125;</span>`</span>;    <span class="hljs-built_in">console</span>.error(errorMsg);    <span class="hljs-keyword">return</span> &#123;      <span class="hljs-attr">filePath</span>: fp,      <span class="hljs-attr">llmResponse</span>: <span class="hljs-string">&quot;&quot;</span>,      <span class="hljs-attr">message</span>: <span class="hljs-string">`LLM分析失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>,      <span class="hljs-attr">error</span>: errorMsg    &#125;;  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 代码评审工具</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">filePaths</span></span> - 文件的绝对路径数组</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;&#123; content: &#123; type: string, text: string &#125;</span></span>[] &#125;&gt;&#125; 代码评审结果</span><span class="hljs-comment"> */</span>server.tool(  <span class="hljs-string">&quot;reviewCode_tool&quot;</span>,  <span class="hljs-string">&quot;工具描述：根据要求进行代码评审，总结代码质量，传参为filePaths数组，数组元素是每个文件的完整地址&quot;</span>,  &#123; <span class="hljs-attr">filePaths</span>: z.array(z.string()) &#125;,  <span class="hljs-keyword">async</span> (&#123; filePaths &#125;) =&gt; &#123;    <span class="hljs-comment">// 使用 Promise.all 并行处理所有文件</span>    <span class="hljs-keyword">const</span> processResults = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(      filePaths.map(<span class="hljs-function"><span class="hljs-params">fp</span> =&gt;</span> processFile(fp))    );    <span class="hljs-keyword">const</span> results = processResults <span class="hljs-keyword">as</span> ProcessResult[];    <span class="hljs-keyword">const</span> errors = processResults      .filter((r: ProcessResult): r is ProcessResult &amp; &#123; <span class="hljs-attr">error</span>: <span class="hljs-built_in">string</span> &#125; =&gt; <span class="hljs-built_in">Boolean</span>(r.error))      .map(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.error);    server.server.sendLoggingMessage(&#123;      <span class="hljs-attr">level</span>: <span class="hljs-string">&quot;info&quot;</span>,      <span class="hljs-attr">data</span>: <span class="hljs-string">`当前的results：<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(results)&#125;</span>`</span>    &#125;);    <span class="hljs-comment">// 构建响应</span>    <span class="hljs-keyword">const</span> failedCount = results.filter(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.llmResponse === <span class="hljs-string">&quot;&quot;</span>).length;    <span class="hljs-keyword">const</span> response = &#123;      results,      errors,      <span class="hljs-attr">message</span>: <span class="hljs-string">`已分析 <span class="hljs-subst">$&#123;results.length&#125;</span> 个文件，失败 <span class="hljs-subst">$&#123;failedCount&#125;</span> 个文件`</span>,    &#125;;    <span class="hljs-keyword">return</span> &#123;      <span class="hljs-attr">content</span>: [&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-built_in">JSON</span>.stringify(response, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>) &#125;],    &#125;;  &#125;);<span class="hljs-keyword">const</span> transport = <span class="hljs-keyword">new</span> StdioServerTransport();<span class="hljs-keyword">await</span> server.connect(transport)</code></pre></div><p>调用的工具：sloc_tool.ts</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; sloc &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node-sloc&#x27;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 代码行数统计结果接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">interface</span> SlocResult &#123;  <span class="hljs-comment">/** 统计的文件路径列表 */</span>  <span class="hljs-attr">paths</span>: <span class="hljs-built_in">string</span>[];  <span class="hljs-comment">/** 统计的文件数量 */</span>  files: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">/** 代码行数（不包含注释和空行） */</span>  sloc: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">/** 注释行数 */</span>  comments: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">/** 空行数 */</span>  blank: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">/** 总行数（代码+注释+空行） */</span>  loc: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 扩展的统计结果接口，包含注释率计算</span><span class="hljs-comment"> */</span><span class="hljs-keyword">interface</span> ExtendedSlocResult <span class="hljs-keyword">extends</span> SlocResult &#123;  <span class="hljs-comment">/** 注释行数占总行数的比率 */</span>  <span class="hljs-attr">commentsToTotalRatio</span>: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">/** 注释行数占代码行数的比率 */</span>  commentsToCodeRatio: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 统计指定文件的代码行数和注释比率</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">filePath</span></span> - 需要统计的文件路径</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>Promise&lt;ExtendedSlocResult&gt; 返回统计结果，包含代码行数、注释行数、空行数及注释比率</span><span class="hljs-comment"> */</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countCodeLines</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ExtendedSlocResult</span>&gt; </span>&#123;  <span class="hljs-keyword">const</span> options = &#123;    <span class="hljs-attr">path</span>: filePath,    <span class="hljs-comment">// 添加对Vue文件的支持</span>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.ts&#x27;</span>, <span class="hljs-string">&#x27;.jsx&#x27;</span>, <span class="hljs-string">&#x27;.tsx&#x27;</span>, <span class="hljs-string">&#x27;.vue&#x27;</span>, <span class="hljs-string">&#x27;.html&#x27;</span>, <span class="hljs-string">&#x27;.css&#x27;</span>],    <span class="hljs-attr">ignorePaths</span>: [<span class="hljs-string">&#x27;node_modules&#x27;</span>, <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-string">&#x27;build&#x27;</span>]  &#125;;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> sloc(options);        <span class="hljs-keyword">if</span>(!result) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;统计结果为空&#x27;</span>);    &#125;    <span class="hljs-comment">// 计算注释比率</span>    <span class="hljs-keyword">const</span> commentsToTotalRatio = <span class="hljs-built_in">Number</span>((result.comments / result.loc).toFixed(<span class="hljs-number">2</span>));    <span class="hljs-keyword">const</span> commentsToCodeRatio = <span class="hljs-built_in">Number</span>((result.comments / result.sloc).toFixed(<span class="hljs-number">2</span>));    <span class="hljs-keyword">return</span> &#123;      ...result,      commentsToTotalRatio,      commentsToCodeRatio    &#125;;  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`统计代码行数失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);  &#125;&#125;<span class="hljs-keyword">export</span> &#123; countCodeLines &#125;;<span class="hljs-comment">// 使用示例 控制台运行tsx src/utils/sloc_tool.ts</span><span class="hljs-comment">// const filePath = &#x27;E:\\DDI\\project\\Leader_Coach\\src\\views\\home\\component\\chatScrollButton\\chatScrollButton.vue&#x27;;</span><span class="hljs-comment">// countCodeLines(filePath)</span><span class="hljs-comment">//   .then((result) =&gt; &#123;</span><span class="hljs-comment">//     console.log(&#x27;文件统计结果:&#x27;);</span><span class="hljs-comment">//     console.log(&#x27;文件路径:&#x27;, result.paths);</span><span class="hljs-comment">//     console.log(&#x27;文件数量:&#x27;, result.files);</span><span class="hljs-comment">//     console.log(&#x27;代码行数:&#x27;, result.sloc);</span><span class="hljs-comment">//     console.log(&#x27;注释行数:&#x27;, result.comments);</span><span class="hljs-comment">//     console.log(&#x27;空行数:&#x27;, result.blank);</span><span class="hljs-comment">//     console.log(&#x27;总行数:&#x27;, result.loc);</span><span class="hljs-comment">//     console.log(&#x27;注释行数/总行数:&#x27;, `$&#123;result.commentsToTotalRatio * 100&#125;%`);</span><span class="hljs-comment">//     console.log(&#x27;注释行数/代码行数:&#x27;, `$&#123;result.commentsToCodeRatio * 100&#125;%`);</span><span class="hljs-comment">//   &#125;)</span><span class="hljs-comment">//   .catch((error) =&gt; &#123;</span><span class="hljs-comment">//     console.error(&#x27;错误:&#x27;, error);</span><span class="hljs-comment">//   &#125;); </span></code></pre></div><h2 id="MCP-Server使用步骤"><a href="#MCP-Server使用步骤" class="headerlink" title="MCP Server使用步骤"></a>MCP Server使用步骤</h2><ul><li><p>拉取MCP代码到本地</p></li><li><p>根据自己的windows和mac环境对json进行区分配置（命令路径）</p></li><li><p>然后将具体文件地址和要求给到AI</p></li><li><p>等待输出</p></li></ul><h2 id="Cursor使用示例"><a href="#Cursor使用示例" class="headerlink" title="Cursor使用示例"></a>Cursor使用示例</h2><p>配置json：</p><div class="code-wrapper"><pre><code class="hljs json">&#123;  <span class="hljs-attr">&quot;mcpServers&quot;</span>: &#123;    <span class="hljs-attr">&quot;代码评审工具&quot;</span>: &#123;      <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,      <span class="hljs-attr">&quot;args&quot;</span>: [<span class="hljs-string">&quot;your path/dist/mcp_code_review.js&quot;</span>],      <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;your path&quot;</span>,      <span class="hljs-attr">&quot;env&quot;</span>: &#123;        <span class="hljs-attr">&quot;OPENAI_API_KEY&quot;</span>: <span class="hljs-string">&quot;your api key&quot;</span>,        <span class="hljs-attr">&quot;OPENAI_API_BASE&quot;</span>: <span class="hljs-string">&quot;https://openrouter.ai/api/v1&quot;</span>,        <span class="hljs-attr">&quot;OPENAI_API_MODEL&quot;</span>: <span class="hljs-string">&quot;qwen/qwen-2.5-coder-32b-instruct:free&quot;</span>      &#125;    &#125;  &#125;&#125;</code></pre></div><p>cursor中启动MCP服务，会触发一个命令行窗口，运行过程中不要关闭</p><p>cursor里必须使用agent模式，并且使用claude模型，prompt如下：</p><div class="code-wrapper"><pre><code class="hljs plantext">E:\project\Leader_Coach\src\views\home\component\chatScrollButton\chatScrollButton.vueE:\project\Leader_Coach\src\views\recommend\recommend.ts使用代码审查工具对这以上文件路径进行code review调用工具的要求：- 取出工具返回的llmResponse字段里的内容，将完整内容提取到markdown里的code标签里一起回复- 如果工具输出里errors有值，或者message里失败n个文件，直接将errors内容输出，这种情况不要总结代码</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>AI相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LLM免费api平台</title>
    <link href="/2025/03/25/LLM%E5%85%8D%E8%B4%B9api%E5%B9%B3%E5%8F%B0/"/>
    <url>/2025/03/25/LLM%E5%85%8D%E8%B4%B9api%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>平时使用AI模型进行学习和尝试开发一些简单的agent，会消耗大量token，这里介绍两个提供免费API的平台，自用下来感觉回复速度和服务器稳定性很不错：</p></blockquote><h2 id="硅基流动"><a href="#硅基流动" class="headerlink" title="硅基流动"></a>硅基流动</h2><p><a href="https://siliconflow.cn/zh-cn/">https://siliconflow.cn/zh-cn/</a></p><p>官网介绍：专为大模型微调与托管打造的一站式服务平台。通过该平台，用户可以快速、无缝地将自定义模型部署为服务，并根据自己上传的数据进行模型微调。</p><ul><li>登录官网后，先申请apikey，然后进入模型广场选择模型 <a href="https://cloud.siliconflow.cn/models">https://cloud.siliconflow.cn/models</a></li></ul><p><img src="/img/blog/AI/api_platform/guiji_model_list.png"></p><p>可用的免费模型还是很多的，这里演示一下推理模型的使用，先看一下参数：<br><img src="/img/blog/AI/api_platform/guiji_api_param.png"></p><p><strong>使用OpenAI SDK进行流式输出的简单demo：</strong></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<span class="hljs-keyword">import</span> osclient = OpenAI(    api_key=os.getenv(<span class="hljs-string">&quot;SILICONFLOW_API_KEY&quot;</span>), <span class="hljs-comment">#这里使用你自己的api key </span>    base_url=<span class="hljs-string">&quot;https://api.siliconflow.cn/v1&quot;</span>)completion = client.chat.completions.create(    model=<span class="hljs-string">&quot;deepseek-ai/DeepSeek-R1-Distill-Qwen-7B&quot;</span>, <span class="hljs-comment">#这个是推理模型，推理内容在reasoning_content里</span>    <span class="hljs-comment"># model=&quot;Qwen/Qwen2-7B-Instruct&quot;, # 自行切换非推理模型对比效果</span>    messages=[&#123;        <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,          <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;9.9和9.11谁大?&quot;</span>      &#125;],    stream=<span class="hljs-literal">True</span>)reasoning = <span class="hljs-string">&quot;&quot;</span>content = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> completion:    <span class="hljs-comment"># print(&#x27;chunk.choices[0]:&#x27;, chunk.choices[0])</span>    delta = chunk.choices[<span class="hljs-number">0</span>].delta        delta_reasoning = <span class="hljs-built_in">getattr</span>(delta, <span class="hljs-string">&#x27;reasoning_content&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)    delta_content = <span class="hljs-built_in">getattr</span>(delta, <span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-keyword">if</span> delta_reasoning:        reasoning += delta_reasoning        <span class="hljs-built_in">print</span>(delta_reasoning, end=<span class="hljs-string">&quot;&quot;</span>, flush=<span class="hljs-literal">True</span>)    <span class="hljs-keyword">if</span> delta_content:        content += delta_content        <span class="hljs-built_in">print</span>(delta_content, end=<span class="hljs-string">&quot;&quot;</span>, flush=<span class="hljs-literal">True</span>)<span class="hljs-comment"># print(&#x27;\n&#x27;*2)</span><span class="hljs-comment"># if reasoning:</span><span class="hljs-comment">#     print(&quot;-&quot;*50)</span><span class="hljs-comment">#     print(&quot;完整推理:&quot;, reasoning)</span><span class="hljs-comment"># print(&quot;-&quot;*50)</span><span class="hljs-comment"># print(&quot;完整回答:&quot;, content)</span></code></pre></div><p><strong>运行演示</strong></p><video width="800" controls>  <source src="/img/blog/AI/api_platform/guiji_test.mp4" type="video/mp4"></video><hr><h2 id="OpenRouter平台"><a href="#OpenRouter平台" class="headerlink" title="OpenRouter平台"></a>OpenRouter平台</h2><p><a href="https://openrouter.ai/">https://openrouter.ai/</a></p><p>官网介绍：一个支持LLM统一接口的平台</p><p><img src="/img/blog/AI/api_platform/openrouter_jieshao.png"></p><p>和硅基流动一样，注册、创建apikey、选择模型；</p><p><strong>模型列表</strong> :<br>其中也有昨天刚发布的deepseek最新版V3，也有Qwen: QwQ 32B 和 DeepSeek: R1，这些在硅基流动上都是收费的，不确定openrouter后续会不会收费，至少可以试用的情况下可以优先使用这个平台进行测试</p><p><img src="/img/blog/AI/api_platform/openrouter_model_list.png"></p><p><strong>同样使用OpenAI SDK进行流式输出的简单demo：</strong></p><p>这里需要注意的是，思考的字段是reasoning，以下是完整代码，基本和上面一致：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<span class="hljs-keyword">import</span> osclient = OpenAI(    api_key=os.getenv(<span class="hljs-string">&quot;OPEN_ROUTER_API_KEY&quot;</span>), <span class="hljs-comment">#这里使用你自己的api key </span>    base_url=<span class="hljs-string">&quot;https://openrouter.ai/api/v1&quot;</span>)<span class="hljs-comment"># 自行切换非推理模型对比效果</span>completion = client.chat.completions.create(<span class="hljs-comment">#   model=&quot;deepseek/deepseek-chat-v3-0324:free&quot;,</span><span class="hljs-comment">#   model=&quot;qwen/qwq-32b:free&quot;,</span><span class="hljs-comment">#   model=&quot;qwen/qwen-2.5-72b-instruct:free&quot;,</span>  model=<span class="hljs-string">&quot;deepseek/deepseek-r1:free&quot;</span>, <span class="hljs-comment">#这个是推理模型，推理内容在reasoning里</span>  messages=[    &#123;      <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,      <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;9.9和9.11谁大?&quot;</span>    &#125;  ],  stream=<span class="hljs-literal">True</span>)reasoning = <span class="hljs-string">&quot;&quot;</span>content = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> completion:    <span class="hljs-comment"># print(&#x27;chunk.choices[0]:&#x27;, chunk.choices[0])</span>    delta = chunk.choices[<span class="hljs-number">0</span>].delta        <span class="hljs-comment"># 使用 getattr 安全地获取属性，如果不存在则返回空字符串</span>    delta_reasoning = <span class="hljs-built_in">getattr</span>(delta, <span class="hljs-string">&#x27;reasoning&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)    delta_content = <span class="hljs-built_in">getattr</span>(delta, <span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-comment"># 如果delta_reasoning存在，则将它添加到reasoning中，并打印出来</span>    <span class="hljs-keyword">if</span> delta_reasoning:        reasoning += delta_reasoning        <span class="hljs-built_in">print</span>(delta_reasoning, end=<span class="hljs-string">&quot;&quot;</span>, flush=<span class="hljs-literal">True</span>)    <span class="hljs-comment"># 如果delta_content存在，则将它添加到content中，并打印出来</span>    <span class="hljs-keyword">if</span> delta_content:        content += delta_content        <span class="hljs-built_in">print</span>(delta_content, end=<span class="hljs-string">&quot;&quot;</span>, flush=<span class="hljs-literal">True</span>)<span class="hljs-comment"># print(&#x27;\n&#x27;*2)</span><span class="hljs-comment"># if reasoning:</span><span class="hljs-comment">#     print(&quot;-&quot;*50)</span><span class="hljs-comment">#     print(&quot;完整推理:&quot;, reasoning)</span><span class="hljs-comment"># print(&quot;-&quot;*50)</span><span class="hljs-comment"># print(&quot;完整回答:&quot;, content)</span></code></pre></div><p>就不放视频了，基本效果和上面视频里是差不多的：</p><p><img src="/img/blog/AI/api_platform/openrouter_llm_test.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Langgraph学习5：WebAgent支持网页内容抓取</title>
    <link href="/2025/03/23/Langgraph%E5%AD%A6%E4%B9%A05%EF%BC%9AWebAgent%E6%94%AF%E6%8C%81%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9%E6%8A%93%E5%8F%96/"/>
    <url>/2025/03/23/Langgraph%E5%AD%A6%E4%B9%A05%EF%BC%9AWebAgent%E6%94%AF%E6%8C%81%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9%E6%8A%93%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<p>功能已完成，博客待编写~~</p>]]></content>
    
    
    <categories>
      
      <category>AI相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Langgraph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Langgraph学习4：搭一个web搜索agent</title>
    <link href="/2025/03/23/Langgraph%E5%AD%A6%E4%B9%A04%EF%BC%9A%E6%90%AD%E4%B8%80%E4%B8%AAweb%E6%90%9C%E7%B4%A2agent/"/>
    <url>/2025/03/23/Langgraph%E5%AD%A6%E4%B9%A04%EF%BC%9A%E6%90%AD%E4%B8%80%E4%B8%AAweb%E6%90%9C%E7%B4%A2agent/</url>
    
    <content type="html"><![CDATA[<p>功能已完成，博客待编写~~</p>]]></content>
    
    
    <categories>
      
      <category>AI相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Langgraph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Langgraph学习3：AI搜索工具的比较</title>
    <link href="/2025/03/22/Langgraph%E5%AD%A6%E4%B9%A03%EF%BC%9AAI%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <url>/2025/03/22/Langgraph%E5%AD%A6%E4%B9%A03%EF%BC%9AAI%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h1 id="AI搜索工具的比较：Tavily-VS-DuckDuckGo"><a href="#AI搜索工具的比较：Tavily-VS-DuckDuckGo" class="headerlink" title="AI搜索工具的比较：Tavily VS DuckDuckGo"></a>AI搜索工具的比较：Tavily VS DuckDuckGo</h1><p>在构建AI应用程序时，获取准确、实时的外部信息是非常重要的一环。LangChain提供了多种搜索工具来帮助AI系统获取网络上的信息。本文将详细比较两种常用的搜索工具：Tavily和DuckDuckGo，分析它们的使用方法、特点以及性能差异。</p><h2 id="搜索工具概述"><a href="#搜索工具概述" class="headerlink" title="搜索工具概述"></a>搜索工具概述</h2><h3 id="Tavily"><a href="#Tavily" class="headerlink" title="Tavily"></a>Tavily</h3><p>Tavily是一款专为AI应用优化的搜索引擎，提供了结构化的搜索结果。它需要API密钥才能使用，但能提供高质量的AI友好型搜索结果。</p><p>特点：</p><ul><li>需要API密钥</li><li>结果格式统一，便于AI处理</li><li>专为AI应用优化</li><li>返回结构化数据</li><li>每月1000次免费请求</li></ul><p>需要先到官网进行注册，和创建APIKEY： <a href="https://app.tavily.com/home">https://app.tavily.com/home</a><br><img src="/img/blog/AI/langgraph/2025-03-22_19-41-56.png"></p><h3 id="DuckDuckGo"><a href="#DuckDuckGo" class="headerlink" title="DuckDuckGo"></a>DuckDuckGo</h3><p>DuckDuckGo是一个注重隐私的搜索引擎，在LangChain中可以免费使用，无需API密钥。它提供了一种无需额外凭证即可获取网络信息的方式。</p><p>特点：</p><ul><li>无需API密钥</li><li>注重隐私保护</li><li>免费使用</li><li>覆盖范围广泛</li></ul><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>以下是完整的比较代码，可以直接运行来测试这两种搜索工具：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">搜索工具比较示例：Tavily vs DuckDuckGo</span><span class="hljs-string"></span><span class="hljs-string">该示例比较了LangChain中两个常用的搜索工具：</span><span class="hljs-string">1. Tavily - 需要API密钥的AI优化搜索引擎</span><span class="hljs-string">2. DuckDuckGo - 注重隐私的免费搜索引擎，无需API密钥</span><span class="hljs-string"></span><span class="hljs-string">通过相同的查询，观察两种搜索工具返回结果的差异。</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> json<span class="hljs-keyword">from</span> langchain_community.tools.tavily_search <span class="hljs-keyword">import</span> TavilySearchResults<span class="hljs-keyword">from</span> langchain_community.tools.ddg_search.tool <span class="hljs-keyword">import</span> DuckDuckGoSearchResults<span class="hljs-comment"># 设置Tavily API密钥（如果存在）</span>tavily_api_key = os.getenv(<span class="hljs-string">&#x27;TAVILY_API_KEY&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">if</span> tavily_api_key:    os.environ[<span class="hljs-string">&#x27;TAVILY_API_KEY&#x27;</span>] = tavily_api_key<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">format_results</span>(<span class="hljs-params">results, tool_name</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    格式化搜索结果为易读的格式</span><span class="hljs-string">    </span><span class="hljs-string">    Args:</span><span class="hljs-string">        results (list or str): 搜索结果列表或字符串</span><span class="hljs-string">        tool_name (str): 搜索工具名称</span><span class="hljs-string">        </span><span class="hljs-string">    Returns:</span><span class="hljs-string">        str: 格式化后的搜索结果字符串</span><span class="hljs-string">    &quot;&quot;&quot;</span>    formatted_output = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;tool_name&#125;</span> 搜索结果:\n&quot;</span>        <span class="hljs-comment"># 如果结果是字符串，尝试解析JSON</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(results, <span class="hljs-built_in">str</span>) <span class="hljs-keyword">and</span> tool_name == <span class="hljs-string">&quot;DuckDuckGo&quot;</span>:        <span class="hljs-keyword">try</span>:            parsed_results = json.loads(results)            results = parsed_results        <span class="hljs-keyword">except</span>:            <span class="hljs-keyword">return</span> formatted_output + results        <span class="hljs-comment"># 根据不同的工具格式化结果</span>    <span class="hljs-keyword">if</span> tool_name == <span class="hljs-string">&quot;Tavily&quot;</span>:        <span class="hljs-keyword">for</span> i, result <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(results, <span class="hljs-number">1</span>):            formatted_output += <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>. 标题: <span class="hljs-subst">&#123;result.get(<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;N/A&#x27;</span>)&#125;</span>\n&quot;</span>            formatted_output += <span class="hljs-string">f&quot;   链接: <span class="hljs-subst">&#123;result.get(<span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-string">&#x27;N/A&#x27;</span>)&#125;</span>\n&quot;</span>            formatted_output += <span class="hljs-string">f&quot;   内容: <span class="hljs-subst">&#123;result.get(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;N/A&#x27;</span>)[:<span class="hljs-number">150</span>]&#125;</span>...\n\n&quot;</span>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># DuckDuckGo</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(results, <span class="hljs-built_in">list</span>):            <span class="hljs-keyword">for</span> i, result <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(results, <span class="hljs-number">1</span>):                formatted_output += <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>. 标题: <span class="hljs-subst">&#123;result.get(<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;N/A&#x27;</span>)&#125;</span>\n&quot;</span>                formatted_output += <span class="hljs-string">f&quot;   链接: <span class="hljs-subst">&#123;result.get(<span class="hljs-string">&#x27;link&#x27;</span>, <span class="hljs-string">&#x27;N/A&#x27;</span>)&#125;</span>\n&quot;</span>                 formatted_output += <span class="hljs-string">f&quot;   摘要: <span class="hljs-subst">&#123;result.get(<span class="hljs-string">&#x27;snippet&#x27;</span>, <span class="hljs-string">&#x27;N/A&#x27;</span>)&#125;</span>\n\n&quot;</span>        <span class="hljs-keyword">else</span>:            formatted_output += <span class="hljs-string">&quot;无法解析搜索结果格式\n&quot;</span>                <span class="hljs-keyword">return</span> formatted_output<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_with_tool</span>(<span class="hljs-params">query, tool_type, max_results</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    使用指定的搜索工具进行网络搜索</span><span class="hljs-string">    </span><span class="hljs-string">    Args:</span><span class="hljs-string">        query (str): 搜索查询</span><span class="hljs-string">        tool_type (str): 搜索工具类型 (&quot;tavily&quot; 或 &quot;duckduckgo&quot;)</span><span class="hljs-string">        max_results (int, optional): 最大结果数. 默认为5.</span><span class="hljs-string">        </span><span class="hljs-string">    Returns:</span><span class="hljs-string">        dict: 搜索结果和状态信息</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">try</span>:        <span class="hljs-comment"># 根据工具类型创建搜索工具</span>        <span class="hljs-keyword">if</span> tool_type.lower() == <span class="hljs-string">&quot;tavily&quot;</span>:            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tavily_api_key:                <span class="hljs-keyword">return</span> &#123;                    <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">False</span>,                    <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;未设置Tavily API密钥，无法使用Tavily搜索&quot;</span>,                    <span class="hljs-string">&quot;results&quot;</span>: []                &#125;            search_tool = TavilySearchResults(max_results=max_results)            tool_name = <span class="hljs-string">&quot;Tavily&quot;</span>        <span class="hljs-keyword">elif</span> tool_type.lower() == <span class="hljs-string">&quot;duckduckgo&quot;</span>:            search_tool = DuckDuckGoSearchResults(max_results=max_results, output_format=<span class="hljs-string">&quot;list&quot;</span>)            tool_name = <span class="hljs-string">&quot;DuckDuckGo&quot;</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> &#123;                <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">False</span>,                <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">f&quot;不支持的搜索工具类型: <span class="hljs-subst">&#123;tool_type&#125;</span>&quot;</span>,                <span class="hljs-string">&quot;results&quot;</span>: []            &#125;                <span class="hljs-comment"># 计时开始</span>        start_time = time.time()                <span class="hljs-comment"># 调用搜索工具</span>        results = search_tool.invoke(&#123;<span class="hljs-string">&quot;query&quot;</span>: query&#125;)                <span class="hljs-comment"># 计时结束</span>        end_time = time.time()        search_time = end_time - start_time                <span class="hljs-comment"># 检查结果</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> results:            <span class="hljs-keyword">return</span> &#123;                <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">False</span>,                <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;tool_name&#125;</span>搜索未返回任何结果&quot;</span>,                <span class="hljs-string">&quot;results&quot;</span>: [],                <span class="hljs-string">&quot;tool_name&quot;</span>: tool_name,                <span class="hljs-string">&quot;search_time&quot;</span>: search_time            &#125;                    <span class="hljs-comment"># 格式化结果</span>        formatted_results = format_results(results, tool_name)                <span class="hljs-keyword">return</span> &#123;            <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">True</span>,            <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;tool_name&#125;</span>搜索成功完成&quot;</span>,            <span class="hljs-string">&quot;results&quot;</span>: results,            <span class="hljs-string">&quot;formatted_results&quot;</span>: formatted_results,            <span class="hljs-string">&quot;tool_name&quot;</span>: tool_name,            <span class="hljs-string">&quot;search_time&quot;</span>: search_time        &#125;            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        <span class="hljs-keyword">return</span> &#123;            <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">False</span>,            <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">f&quot;搜索过程中出现错误: <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(e)&#125;</span>&quot;</span>,            <span class="hljs-string">&quot;results&quot;</span>: [],            <span class="hljs-string">&quot;tool_name&quot;</span>: tool_type        &#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare_search_tools</span>(<span class="hljs-params">query, max_results=<span class="hljs-number">3</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    比较不同搜索工具的结果</span><span class="hljs-string">    </span><span class="hljs-string">    Args:</span><span class="hljs-string">        query (str): 搜索查询</span><span class="hljs-string">        max_results (int, optional): 每个工具返回的最大结果数. 默认为3.</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">60</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;搜索查询: &#x27;<span class="hljs-subst">&#123;query&#125;</span>&#x27;&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">60</span>)        <span class="hljs-comment"># 使用DuckDuckGo搜索</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n[1] 使用DuckDuckGo搜索...&quot;</span>)    ddg_result = search_with_tool(query, <span class="hljs-string">&quot;duckduckgo&quot;</span>, max_results)        <span class="hljs-comment"># 使用Tavily搜索 (如果有API密钥)</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n[2] 使用Tavily搜索...&quot;</span>)    tavily_result = search_with_tool(query, <span class="hljs-string">&quot;tavily&quot;</span>, max_results)        <span class="hljs-comment"># 打印结果比较</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">60</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;搜索结果比较&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">60</span>)        <span class="hljs-comment"># DuckDuckGo结果</span>    <span class="hljs-keyword">if</span> ddg_result[<span class="hljs-string">&quot;success&quot;</span>]:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nDuckDuckGo 搜索时间: <span class="hljs-subst">&#123;ddg_result.get(<span class="hljs-string">&#x27;search_time&#x27;</span>, <span class="hljs-string">&#x27;N/A&#x27;</span>):<span class="hljs-number">.2</span>f&#125;</span> 秒&quot;</span>)        <span class="hljs-built_in">print</span>(ddg_result[<span class="hljs-string">&quot;formatted_results&quot;</span>])    <span class="hljs-keyword">else</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nDuckDuckGo 搜索失败: <span class="hljs-subst">&#123;ddg_result[<span class="hljs-string">&#x27;message&#x27;</span>]&#125;</span>&quot;</span>)        <span class="hljs-comment"># Tavily结果</span>    <span class="hljs-keyword">if</span> tavily_result[<span class="hljs-string">&quot;success&quot;</span>]:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nTavily 搜索时间: <span class="hljs-subst">&#123;tavily_result.get(<span class="hljs-string">&#x27;search_time&#x27;</span>, <span class="hljs-string">&#x27;N/A&#x27;</span>):<span class="hljs-number">.2</span>f&#125;</span> 秒&quot;</span>)        <span class="hljs-built_in">print</span>(tavily_result[<span class="hljs-string">&quot;formatted_results&quot;</span>])    <span class="hljs-keyword">else</span>:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nTavily 搜索失败: <span class="hljs-subst">&#123;tavily_result[<span class="hljs-string">&#x27;message&#x27;</span>]&#125;</span>&quot;</span>)        <span class="hljs-comment"># 添加差异分析</span>    <span class="hljs-keyword">if</span> ddg_result[<span class="hljs-string">&quot;success&quot;</span>] <span class="hljs-keyword">and</span> tavily_result[<span class="hljs-string">&quot;success&quot;</span>]:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">60</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结果差异分析:&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">60</span>)                <span class="hljs-comment"># 比较结果数量</span>        ddg_results = ddg_result[<span class="hljs-string">&quot;results&quot;</span>]        tavily_results = tavily_result[<span class="hljs-string">&quot;results&quot;</span>]                <span class="hljs-comment"># 处理DuckDuckGo的结果数量</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(ddg_results, <span class="hljs-built_in">str</span>):            <span class="hljs-keyword">try</span>:                <span class="hljs-keyword">import</span> json                ddg_results = json.loads(ddg_results)            <span class="hljs-keyword">except</span>:                ddg_results = []                        ddg_count = <span class="hljs-built_in">len</span>(ddg_results) <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(ddg_results, <span class="hljs-built_in">list</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>        tavily_count = <span class="hljs-built_in">len</span>(tavily_results)                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;DuckDuckGo 返回结果数量: <span class="hljs-subst">&#123;ddg_count&#125;</span>&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Tavily 返回结果数量: <span class="hljs-subst">&#123;tavily_count&#125;</span>&quot;</span>)                <span class="hljs-comment"># 比较响应时间</span>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;search_time&quot;</span> <span class="hljs-keyword">in</span> ddg_result <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;search_time&quot;</span> <span class="hljs-keyword">in</span> tavily_result:            ddg_time = ddg_result[<span class="hljs-string">&quot;search_time&quot;</span>]            tavily_time = tavily_result[<span class="hljs-string">&quot;search_time&quot;</span>]            faster = <span class="hljs-string">&quot;DuckDuckGo&quot;</span> <span class="hljs-keyword">if</span> ddg_time &lt; tavily_time <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Tavily&quot;</span>            time_diff = <span class="hljs-built_in">abs</span>(ddg_time - tavily_time)            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;响应时间差异: <span class="hljs-subst">&#123;faster&#125;</span> 更快 <span class="hljs-subst">&#123;time_diff:<span class="hljs-number">.2</span>f&#125;</span> 秒&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    <span class="hljs-string">&quot;&quot;&quot;主函数，运行搜索工具比较示例&quot;&quot;&quot;</span>    <span class="hljs-comment"># 示例搜索查询</span>    queries = [        <span class="hljs-string">&quot;2024年人工智能的主要发展趋势&quot;</span>,        <span class="hljs-string">&quot;LangChain和LlamaIndex的比较&quot;</span>,        <span class="hljs-string">&quot;Python和JavaScript的区别&quot;</span>    ]        <span class="hljs-keyword">for</span> query <span class="hljs-keyword">in</span> queries:        compare_search_tools(query)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n\n&quot;</span> + <span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">70</span> + <span class="hljs-string">&quot;\n&quot;</span>)                <span class="hljs-comment"># 暂停一下，避免搜索频率过高</span>        time.sleep(<span class="hljs-number">2</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;*&quot;</span> * <span class="hljs-number">70</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* LangChain搜索工具比较: Tavily vs DuckDuckGo *&quot;</span>.center(<span class="hljs-number">70</span>))    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span> * <span class="hljs-number">70</span> + <span class="hljs-string">&quot;\n&quot;</span>)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tavily_api_key:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;警告: 未设置TAVILY_API_KEY环境变量，Tavily搜索将不可用\n&quot;</span>)        main()</code></pre></div><h2 id="实际运行结果"><a href="#实际运行结果" class="headerlink" title="实际运行结果"></a>实际运行结果</h2><p>下面是使用上述代码运行三个不同查询的实际对比结果，可以直观地看出两种搜索工具在不同方面的表现差异：</p><div class="code-wrapper"><pre><code class="hljs log">**********************************************************************              * LangChain搜索工具比较: Tavily vs DuckDuckGo ***********************************************************************============================================================搜索查询: &#x27;2024年人工智能的主要发展趋势&#x27;============================================================[1] 使用DuckDuckGo搜索...[2] 使用Tavily搜索...============================================================搜索结果比较============================================================DuckDuckGo 搜索时间: 6.33 秒DuckDuckGo 搜索结果:1. 标题: 李飞飞团队发布《2024年人工智能指数报告》：10大趋势，揭示AI大模型喜与忧_澎湃号·湃客_澎湃新闻-The Paper   链接: https://www.thepaper.cn/newsDetail_forward_27045165   摘要: 刚刚，由李飞飞联合领导的斯坦福大学以人为本人工智能研究所（Stanford HAI）发布了《2024 年人工智能指数报告》（Artificial Intelligence Index Report 2024）。 这份长达 300 多页的报告是 Stanford HAI 发布的第 7 份 AI Index 研究，追踪了 2023 年全球人工智能的发展趋势。2. 标题: 《2024年人工智能指数报告》   链接: https://cingai.nankai.edu.cn/2024/0914/c10233a550905/page.htm   摘要: 2024年4月，斯坦福大学以人为本人工智能研究所（Stanford HAI）发布了《2024 年人工智能指数报告》（Artificial Intelligence Index Report 2024）。 据Stanford HAI 官方介绍道：&quot;这是我们迄今为止最全面的报告，而且是在人工智能对社会的影响从未如此明显的重要时刻发布的。3. 标题: 中国信息通信研究院发布《人工智能发展报告(2024年)》   链接: https://d.wanfangdata.com.cn/periodical/Ch9QZXJpb2RpY2FsQ0hJTmV3UzIwMjUwMTE2MTYzNjE0Eg1tamd5MjAyNTAxMDEwGghkNGwzYXFocg==   摘要: 2024年12月10日,中国信息通信研究院发布《人工智能发展报告(2024年)》.《人工智能发展报告(2024年)》立足产业新发展、新变化、新需求,聚焦新形势下全球人工智能发展重点,总结梳理人工智能技术创新方向、产业升级重点、行业落地趋势和安全治理进展,展望人工智能发展机遇,以期与业界分享,共同推动 ...4. 标题: 2024-2025年ai领域重大事件盘点：技术突破、应用落地与未来趋势_2024-2025最新的人工智能&quot;事件-csdn博客   链接: https://blog.csdn.net/TGQlovemm/article/details/145548021   摘要: 文章浏览阅读4k次，点赞26次，收藏19次。2024-2025年，ai技术从实验室走向大规模应用，生成式ai、多模态融合与具身智能成为核心驱动力。然而，技术突破也伴随伦理、隐私与能源消耗的挑战。未来，ai将不仅是工具，更是人类智慧的延伸，需在创新与治理中寻找平衡点，以实现&quot;技术向善&quot;的 终极 ...Tavily 搜索时间: 7.20 秒Tavily 搜索结果:1. 标题: 瞭望| 前瞻2024人工智能四大趋势 - 新华网   链接: http://www.news.cn/tech/20240103/06334b17b41c44518168c2dea7bb844d/c.html   内容: 瞭望 | 前瞻2024人工智能四大趋势2024-01-03 16:01:40 来源：新华社据消息人士称，OpenAI正在训练下一代的人工智能，暂名“Q*”（读作Q-star）。新的一年，OpenAI下一代产品可能发布数据瓶颈指的是可用于训练AI的高质量数据的有限性，合成数据有望打破这一瓶颈。除...2. 标题: 2024年人工智能产业十大发展趋势   链接: https://zhuanlan.zhihu.com/p/683509691   内容: 2024年人工智能产业十大发展趋势技术变革1. 多模态预训练大模型将是人工智能产业的标配2. 高质量数据愈发稀缺将倒逼数据智能飞跃3. 智能 算力无处不在...3. 标题: 2024 年最重要的AI 趋势 - IBM   链接: https://www.ibm.com/cn-zh/think/insights/artificial-intelligence-trends   内容: 人工智能主要趋势 | IBM2024 年最重要的 AI 趋势标签Artificial Intelligence2024 年 2 月 9 日阅读时长：12 分钟复制链接2022 年是生成式人工智能 (AI) 迅速进入公众意识的一年，而 2023 年则是它开始在商业世界扎根生长的一年。因此...------------------------------------------------------------结果差异分析:------------------------------------------------------------DuckDuckGo 返回结果数量: 4Tavily 返回结果数量: 3响应时间差异: DuckDuckGo 更快 0.87 秒==================================================================================================================================搜索查询: &#x27;LangChain和LlamaIndex的比较&#x27;============================================================[1] 使用DuckDuckGo搜索...[2] 使用Tavily搜索...============================================================搜索结果比较============================================================DuckDuckGo 搜索时间: 6.44 秒DuckDuckGo 搜索结果:1. 标题: LangChain vs LlamaIndex：为您的AI应用选择最佳框架   链接: https://myscale.com/blog/zh/llamaindex-vs-langchain-detailed-comparison/   摘要: 总之，LlamaIndex和LangChain在技术领域的不同用例中提供了独特的优势。它们通过其专业化的功能满足了各种应用需求。它们提高了可用性， 并扩展了AI开发的视野。 # 根据需求做出正确选择. 在考虑选择LlamaIndex和LangChain之间的选择时，仔细评估您的项目需求至关 ...2. 标题: Langchain与LlamaIndex应该选哪个 - 53AI-AI知识库|大模型知识库|大模型训练|智能体开发   链接: https://www.53ai.com/news/langchain/2025040387046.html   摘要: 在选择LangChain和LlamaIndex时，需要考虑以下因素： 项目需求： 如果应用主要关注搜索和检索，LlamaIndex可能更适合。对于更多样化的NLP任务和自定义工作流程，LangChain提供更大的灵活性。 使用简易性： LlamaIndex提供更简化和适合初学者的界面，而LangChain需要更深入 ...3. 标题: LangChain vs LlamaIndex: A Detailed Comparison - DataCamp   链接: https://www.datacamp.com/blog/langchain-vs-llamaindex   摘要: Langchain vs LlamaIndex: A Comparative Analysis. LlamaIndex is primarily designed for search and retrieval tasks. It excels at indexing large datasets and retrieving relevant information quickly and accurately. LangChain, on the other hand, provides a modular and adaptable framework for building a variety of NLP applications, including chatbots ...4. 标题: LangChain vs LlamaIndex: In-Depth Comparison and Use   链接: https://www.deepchecks.com/langchain-vs-llamaindex-depth-comparison-use/   摘要: LangChain and LlamaIndex are both powerful frameworks for building applications with LLMs. While they share some common functionalities, they are usually quite different. In this section, you will explore LangChain vs. LlamaIndex across various aspects. Ease of use and configuration. LlamaIndex is designed with simplicity in mind.Tavily 搜索时间: 7.36 秒Tavily 搜索结果:1. 标题: LangChain 与LlamaIndex：详细比较原创 - CSDN博客   链接: https://blog.csdn.net/RamendeusStudio/article/details/140046035   内容: LangChain 专注于构建复杂的工作流和交互式应用程序，而LlamaIndex 则强调无缝数据集成和动态数据管理。 本文对这两个框架进行了全面比较，探讨了它们独特...2. 标题: LangChain vs LlamaIndex：为您的AI应用选择最佳框架 - MyScale   链接: https://myscale.com/blog/zh/llamaindex-vs-langchain-detailed-comparison/   内容: 让我们讨论一下LlamaIndex和LangChain的一些核心功能和功能。# 数据索引在数据索引的背景下比较LlamaIndex和LangChain时，不同的方法浮出水面。LlamaIndex在快速组织和分类大量信息方面表现出色，将信息高效地转化为数值表示（嵌入式）。它专注于高效索引，以确...3. 标题: LlamaIndex 和Langchain 有啥区别？ - 杰力皓博   链接: https://www.aqwu.net/wp/?p=2902   内容: 两者之间的主要区别在于它们的使用场景和灵活性。LlamaIndex特别适合于搜索和检索任务，使其成为深度数据探索的有力工具。相比之下，LangChain提供了更广泛的能力和工具集成，...------------------------------------------------------------结果差异分析:------------------------------------------------------------DuckDuckGo 返回结果数量: 4Tavily 返回结果数量: 3响应时间差异: DuckDuckGo 更快 0.92 秒==================================================================================================================================搜索查询: &#x27;Python和JavaScript的区别&#x27;============================================================[1] 使用DuckDuckGo搜索...[2] 使用Tavily搜索...============================================================搜索结果比较============================================================DuckDuckGo 搜索时间: 6.39 秒DuckDuckGo 搜索结果:1. 标题: JavaScript与Python编程语言对比：性能、应用场景及学习建议 - 云原生实践   链接: https://www.oryoy.com/news/javascript-yu-python-bian-cheng-yu-yan-dui-bi-xing-neng-ying-yong-chang-jing-ji-xue-xi-jian-yi.html     摘要: JavaScript与Python编程语言对比：性能、应用场景及学习建议 在当今的编程世界中，JavaScript和Python无疑是两种最受欢迎且广泛应用的编 程语言。它们各自拥有庞大的开发者社区和丰富的库资源，但同时也存在明显的差异。本文将从性能、应用场景以及学习建议三个方面，对JavaScript和Python进行深入对比 ...2. 标题: JavaScript 与 Python：您应该先学习哪一个？ - Web前端之家   链接: https://www.jiangweishan.com/article/PythonandavaScript.html   摘要: 句法 虽然我们已经讨论了这两种语言的语法，但我们将更深入地研究这两种语言的细微差别。我们将研究最标准的编程指令以及 Python 和 JavaScript 的区别。 印刷 任何编程语言中一个基本概念就是打印。在任何优秀的初学者编程教程中，您编写的第一个程序都应该打印短语 Hello, World!。  使用 Python ...3. 标题: Python vs Java脚本：它们之间的主要区别 - Guru99   链接: https://www.guru99.com/zh-CN/python-vs-javascript.html   摘要: 之间的区别 Python vs Java脚本 Python 是一种高级面向对象编程语言，具有内置数据结构以及动态绑定和类型，非常适合快速应用程序开发。 JavaScript 是一种脚本语言，可以帮助您创建交互式网页。 Python 具有可变和不可变的数据类型，但是 Java脚本没有可变和不可变的概念。 Python 源 代码默认为 ASCII ...4. 标题: python 和 javascript 有什么区别 - PingCode   链接: https://docs.pingcode.com/ask/ask-ask/164914.html   摘要: Python和JavaScript的主要区别在于它们的运行环境、语法、应用范围和设计哲学。 Python通常用于服务器端编程、数据科学和脚本编写，而JavaScript主要用于客户端的Web开发。 Python以简洁易读著称、支持多种编程范式，例如面向对象和函数式编程。Tavily 搜索时间: 7.98 秒Tavily 搜索结果:1. 标题: Python和JavaScript在使用上有什么区别？ - 葡萄城技术团队 - 博客园   链接: https://www.cnblogs.com/powertoolsteam/p/14450549.html   内容: 两种方法之间的主要区别在于，在Python中，将提示用户在控制台中输入值，而在JavaScript中，浏览器中将显示一个小提示，并要求用户输入值。...2. 标题: python 和javascript 有什么区别？ - 知乎   链接: https://www.zhihu.com/question/583932715   内容: 1、语法差异：Python 的语法比较简单，强调代码可读性，比如它使用缩进来表示代码块的范围。 JavaScript 的语法比较复杂，结构更加灵活，比如它没有明显的缩进...3. 标题: Python与JavaScript有什么区别？ - 稀土掘金   链接: https://juejin.cn/post/7112346448229990414   内容: 一方面，Python是强类型的，因此类型之间没有隐式转换。另一方面，JavaScript是弱类型的，意味着不相关的类型之间的转换是隐式的。...   ------------------------------------------------------------结果差异分析:------------------------------------------------------------DuckDuckGo 返回结果数量: 4Tavily 返回结果数量: 3响应时间差异: DuckDuckGo 更快 1.59 秒======================================================================</code></pre></div><h3 id="1-环境设置"><a href="#1-环境设置" class="headerlink" title="1.环境设置"></a>1.环境设置</h3><p>先需要导入必要的库并设置环境变量</p><h3 id="2-结果格式化函数"><a href="#2-结果格式化函数" class="headerlink" title="2. 结果格式化函数"></a>2. 结果格式化函数</h3><p>搜索工具返回的原始数据格式各不相同，需要统一格式化以便比较。</p><p>format_results这个函数接收搜索结果和工具名称，根据不同工具返回的数据结构进行格式化，生成一个易于阅读的字符串输出。对于Tavily，它处理标题、URL和内容摘要；对于DuckDuckGo，它处理标题、链接和snippet摘要。</p><h3 id="3-搜索工具调用函数"><a href="#3-搜索工具调用函数" class="headerlink" title="3. 搜索工具调用函数"></a>3. 搜索工具调用函数</h3><p>search_with_tool核心功能是通过不同的搜索工具执行查询：</p><p>这个函数根据指定的工具类型（”tavily”或”duckduckgo”）创建相应的搜索工具实例，然后执行查询，记录搜索时间，并返回格式化的结果。</p><p>关键API使用：</p><ul><li><code>TavilySearchResults(max_results=max_results)</code> - 创建Tavily搜索工具</li><li><code>DuckDuckGoSearchResults(max_results=max_results, output_format=&quot;list&quot;)</code> - 创建DuckDuckGo搜索工具</li><li><code>search_tool.invoke(&#123;&quot;query&quot;: query&#125;)</code> - 执行搜索查询</li></ul><h3 id="4-搜索工具比较函数"><a href="#4-搜索工具比较函数" class="headerlink" title="4. 搜索工具比较函数"></a>4. 搜索工具比较函数</h3><p>compare_search_tools比较函数协调多个搜索工具的使用并分析差异：</p><p>这个函数执行以下步骤：</p><ol><li>使用DuckDuckGo执行搜索</li><li>使用Tavily执行相同的搜索</li><li>打印两种工具的搜索时间</li><li>显示格式化的搜索结果</li><li>分析结果之间的差异，包括结果数量和响应时间</li></ol><h3 id="5-主函数"><a href="#5-主函数" class="headerlink" title="5. 主函数"></a>5. 主函数</h3><p>在主函数中，定义了三个示例查询，并对每个查询依次运行比较函数。为了避免请求频率过高，每次比较之间添加了短暂的延迟。</p><h2 id="工具性能与结果差异分析"><a href="#工具性能与结果差异分析" class="headerlink" title="工具性能与结果差异分析"></a>工具性能与结果差异分析</h2><p>通过代码的运行，我们可以观察到两种搜索工具的几个关键差异：</p><ol><li><p><strong>结果格式</strong>：Tavily返回结构化的JSON数据，包含标题、URL和内容；DuckDuckGo返回的结果包含标题、链接和摘要。</p></li><li><p><strong>响应时间</strong>：代码会测量并比较两种工具的响应时间，帮助我们了解它们在性能方面的差异。</p></li><li><p><strong>结果质量</strong>：通过运行多个查询，可以主观评估两种工具返回结果的相关性和质量。</p></li><li><p><strong>可用性</strong>：DuckDuckGo无需API密钥，随时可用；Tavily需要有效的API密钥。</p></li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>不同的搜索工具适合不同的应用场景：</p><ul><li><p><strong>Tavily</strong>：适合需要高质量、结构化结果的专业AI应用，特别是那些有预算支持API调用的项目。</p></li><li><p><strong>DuckDuckGo</strong>：适合开发阶段的项目、教育目的或不需要特别优化的应用，尤其是当预算有限或注重隐私时。</p></li></ul><h2 id="综合比较分析（以下是Claude-3-7-sonnet根据完整log进行的分析结果）"><a href="#综合比较分析（以下是Claude-3-7-sonnet根据完整log进行的分析结果）" class="headerlink" title="综合比较分析（以下是Claude-3.7-sonnet根据完整log进行的分析结果）"></a>综合比较分析（以下是Claude-3.7-sonnet根据完整log进行的分析结果）</h2><p>通过对三种不同查询的测试比较，我们可以总结出以下几点关于Tavily和DuckDuckGo搜索工具的对比：</p><h3 id="结果数量"><a href="#结果数量" class="headerlink" title="结果数量"></a>结果数量</h3><p>在所有测试中，DuckDuckGo都返回了4条结果，而Tavily返回了3条结果。这是因为我们在代码中为两种工具设置了不同的默认返回数量，但也反映了两者在结果处理上的差异。</p><h3 id="响应速度"><a href="#响应速度" class="headerlink" title="响应速度"></a>响应速度</h3><p>在所有测试查询中，DuckDuckGo的响应速度都比Tavily快，平均快约1秒左右：</p><ul><li>查询1：DuckDuckGo快0.87秒</li><li>查询2：DuckDuckGo快0.92秒</li><li>查询3：DuckDuckGo快1.59秒</li></ul><p>这可能是因为DuckDuckGo不需要额外的API认证步骤，且其服务器可能针对简单查询做了更好的优化。</p><h3 id="结果质量与相关性"><a href="#结果质量与相关性" class="headerlink" title="结果质量与相关性"></a>结果质量与相关性</h3><p>两种工具在结果质量上各有特点：</p><ul><li><p><strong>DuckDuckGo</strong>：返回的结果更全面，包含了更多来源的信息。例如在”2024年人工智能的主要发展趋势”的查询中，DuckDuckGo返回了包括斯坦福研究所和中国信息通信研究院的报告，覆盖面较广。</p></li><li><p><strong>Tavily</strong>：虽然结果数量较少，但针对AI应用场景做了优化，返回的内容格式更统一，且内容摘要往往直接切入主题。例如在”Python和JavaScript的区别”查询中，Tavily的结果更直接地列出了语法差异等关键点。</p></li></ul><h3 id="结果格式"><a href="#结果格式" class="headerlink" title="结果格式"></a>结果格式</h3><p>两种工具返回的结果格式有明显差异：</p><ul><li><strong>DuckDuckGo</strong>：返回的字段包括title、link和snippet，更适合传统的搜索结果展示。</li><li><strong>Tavily</strong>：返回的字段包括title、url和content，格式更为结构化，便于AI系统进一步处理。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过实际的搜索测试比较，我们可以看到：</p><ol><li><strong>性能方面</strong>：DuckDuckGo在响应速度上略胜一筹。</li><li><strong>可用性方面</strong>：DuckDuckGo无需API密钥，更容易上手使用。</li><li><strong>结果质量方面</strong>：Tavily的结果更适合AI应用处理，而DuckDuckGo提供了更广泛的信息覆盖。</li></ol><p>这些结果验证了理论分析中的预期，并提供了直观的证据帮助开发者根据自己的应用需求选择合适的搜索工具。对于注重速度和无需API密钥的应用，DuckDuckGo是更好的选择；而对于需要高质量、结构化结果的AI专业应用，Tavily则能提供更好的支持。</p>]]></content>
    
    
    <categories>
      
      <category>AI相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Langgraph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Langgraph学习2：LLM自动调用工具</title>
    <link href="/2025/03/22/Langgraph%E5%AD%A6%E4%B9%A02%EF%BC%9ALLM%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <url>/2025/03/22/Langgraph%E5%AD%A6%E4%B9%A02%EF%BC%9ALLM%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，通过学习官方示例构建了一个基础的Langgraph chatbot工作流。今天更进一步，探索如何让chatbot能够调用工具来完成特定任务。</p><h2 id="定义工具"><a href="#定义工具" class="headerlink" title="定义工具"></a>定义工具</h2><p>简单定义一个无任何逻辑的工具函数，该函数直接会返回天气查询的结果来模拟LLM调用天气api的流程：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_core.tools <span class="hljs-keyword">import</span> tool<span class="hljs-keyword">from</span> langchain_core.utils.function_calling <span class="hljs-keyword">import</span> convert_to_openai_function<span class="hljs-comment"># 定义工具</span><span class="hljs-meta">@tool</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_weather</span>(<span class="hljs-params">query: <span class="hljs-built_in">str</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;用于获取天气信息。&quot;&quot;&quot;</span>    <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;今天天气晴朗，温度20度&quot;</span>, <span class="hljs-string">&quot;明天天气多云，温度25度&quot;</span>]<span class="hljs-comment"># 创建工具列表</span>tools = [get_weather]<span class="hljs-comment"># 绑定工具到LLM</span>llm_with_tools = llm.bind_tools(tools)<span class="hljs-comment"># 创建OpenAI函数格式的工具描述</span>functions = [convert_to_openai_function(t) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tools]<span class="hljs-comment"># 创建tool节点</span><span class="hljs-keyword">from</span> langgraph.prebuilt <span class="hljs-keyword">import</span> ToolNodetool_node = ToolNode(tools)</code></pre></div><p>使用了@tool装饰器来定义工具函数，这是Langchain提供的便捷方式。然后创建了工具列表并将其绑定到LLM，同时还创建了一个专门的ToolNode来处理工具调用。</p><p><strong>以下是Claude-3.7-sonnet对tool装饰器的用法和解释：</strong></p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-variable">@tool</span>装饰器详解<span class="hljs-variable">@tool</span>是LangChain提供的装饰器，它的作用是将普通Python函数转换为LangChain工具格式。这个装饰器会自动：- 解析函数签名中的参数类型- 从函数文档字符串中提取描述信息- 创建一个符合LangChain工具标准的包装器- 使用<span class="hljs-variable">@tool</span>时需要注意：- 函数必须有文档字符串（docstring），这将作为工具的描述传递给LLM- 参数类型最好有明确的注解，这样LLM才能正确理解参数类型- 参数名称应尽量具有描述性，这有助于LLM理解参数的作用- 返回值应该是字符串或可序列化为字符串的对象，以便传递回LLMllm_with_tools = llm.bind_tools(tools)这一步是将工具绑定到LLM实例，这样LLM在生成回复时就能感知到这些工具的存在。convert_to_openai_function函数则是将LangChain工具格式转换为OpenAI函数调用格式，因为很多模型都兼容OpenAI的函数调用API标准。</code></pre></div><h2 id="修改聊天节点函数"><a href="#修改聊天节点函数" class="headerlink" title="修改聊天节点函数"></a>修改聊天节点函数</h2><p>需要改造原来的聊天节点函数，使其支持工具调用：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># llm的调用</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chat_bot</span>(<span class="hljs-params">state: MessagesState</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;生成流式回复的节点函数&quot;&quot;&quot;</span>    messages = state[<span class="hljs-string">&quot;messages&quot;</span>]    <span class="hljs-comment"># 使用支持工具调用的方式调用LLM</span>    response = <span class="hljs-keyword">await</span> llm_with_tools.ainvoke(        messages,        functions=functions,        function_call=<span class="hljs-string">&quot;auto&quot;</span>    )    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;messages&quot;</span>: [response]&#125;</code></pre></div><p>通过传入functions参数和设置function_call=”auto”，让模型自行决定是否需要调用工具。</p><p>这意味着模型将根据用户的输入自动判断是否需要调用工具。如果模型认为需要调用工具，它会生成一个特殊的回复，包含工具调用信息而不是直接文本回答。</p><h2 id="定义条件路由"><a href="#定义条件路由" class="headerlink" title="定义条件路由"></a>定义条件路由</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Literal</span><span class="hljs-comment"># 定义边的逻辑判断（条件边），判断是否继续</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tool_router</span>(<span class="hljs-params">state: MessagesState</span>) -&gt; <span class="hljs-type">Literal</span>[&quot;tools&quot;, &quot;__end__&quot;]:</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;state------&gt;&#x27;</span>,state,<span class="hljs-string">&#x27;\n&#x27;</span>)    messages = state[<span class="hljs-string">&#x27;messages&#x27;</span>]    last_message = messages[-<span class="hljs-number">1</span>]    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;last_message------&gt;&#x27;</span>,last_message,<span class="hljs-string">&#x27;\n&#x27;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;last_message.tool_calls------&gt;&#x27;</span>,last_message.tool_calls,<span class="hljs-string">&#x27;\n&#x27;</span>)    <span class="hljs-keyword">if</span> last_message.tool_calls: <span class="hljs-comment"># 判断模型是否返回tools调用</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;tools&quot;</span>    <span class="hljs-keyword">return</span> END</code></pre></div><p>这个函数检查模型返回的最后一条消息是否包含工具调用请求。如果有，就路由到”tools”节点；如果没有，就结束工作流。</p><h3 id="工具调用流程详解"><a href="#工具调用流程详解" class="headerlink" title="工具调用流程详解"></a>工具调用流程详解</h3><p>当模型决定调用工具时，整个过程是这样的：</p><ul><li>模型生成一个包含tool_calls属性的AIMessage对象</li><li>tool_router函数检查最新消息是否包含tool_calls</li><li>如果存在tool_calls，函数返回”tools”，指示工作流去执行工具节点</li><li>如果不存在，函数返回END，表示工作流结束</li></ul><p>从日志中可以看到last_message.tool_calls的格式：</p><div class="code-wrapper"><pre><code class="hljs log">last_message.tool_calls------&gt; [&#123;&#x27;name&#x27;: &#x27;get_weather&#x27;, &#x27;args&#x27;: &#123;&#x27;query&#x27;: &#x27;今明两天天气&#x27;&#125;, &#x27;id&#x27;: &#x27;019619eaea388a97f7e451f4cefc4bfe&#x27;, &#x27;type&#x27;: &#x27;tool_call&#x27;&#125;]</code></pre></div><p>这个结构包含了关键信息：</p><ul><li>name：要调用的工具名称（对应我们定义的函数名）</li><li>args：传递给工具的参数（这里是查询字符串）</li><li>id：工具调用的唯一标识符（用于后续匹配返回结果）</li><li>type：调用类型，固定为”tool_call”</li></ul><h3 id="ToolNode的工作原理"><a href="#ToolNode的工作原理" class="headerlink" title="ToolNode的工作原理"></a>ToolNode的工作原理</h3><p>当工作流转到tool_node节点时，ToolNode会自动：</p><ul><li>从最后一条消息中提取tool_calls</li><li>根据工具名称找到对应的工具函数</li><li>用提取的参数调用该函数</li><li>将结果封装为ToolMessage添加到消息历史中</li><li>返回更新后的状态给工作流<br>最后，工作流会再次进入chat_bot节点，让模型基于工具返回的结果生成最终回复。</li></ul><h2 id="扩展工作流"><a href="#扩展工作流" class="headerlink" title="扩展工作流"></a>扩展工作流</h2><p>现在可以重新构建一个更复杂的工作流，包含工具调用和条件路由：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 创建工作流程</span>workflow = StateGraph(MessagesState)<span class="hljs-comment"># 添加节点</span>workflow.add_node(<span class="hljs-string">&quot;chat_bot&quot;</span>, chat_bot)<span class="hljs-comment"># 设置入口节点</span>workflow.set_entry_point(<span class="hljs-string">&quot;chat_bot&quot;</span>)<span class="hljs-comment"># 添加tool节点</span>workflow.add_node(<span class="hljs-string">&quot;tools&quot;</span>, tool_node)<span class="hljs-comment"># 从tools节点指向chat_bot节点，以便可能的后续交互</span>workflow.add_edge(<span class="hljs-string">&quot;tools&quot;</span>, <span class="hljs-string">&quot;chat_bot&quot;</span>)<span class="hljs-comment"># 添加条件边</span>workflow.add_conditional_edges(    <span class="hljs-string">&quot;chat_bot&quot;</span>,    tool_router,  <span class="hljs-comment"># 判断下一个调用的节点</span>)<span class="hljs-comment"># 编译图</span>app_graph = workflow.<span class="hljs-built_in">compile</span>()</code></pre></div><p>与第一篇不同这个工作流有了条件路由，执行路径现在有两种可能：<br>chat_bot → END（如果模型直接回答）<br>chat_bot → tools → chat_bot → END（如果模型需要调用工具）<br>add_conditional_edges方法是关键，它允许工作流根据路由函数的返回值选择不同的执行路径。</p><h2 id="测试工作流"><a href="#测试工作流" class="headerlink" title="测试工作流"></a>测试工作流</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 测试运行函数</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_streaming_chain</span>():</span>    <span class="hljs-string">&quot;&quot;&quot;运行graph的链&quot;&quot;&quot;</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始生成回复...\n&quot;</span>)    messages = [        SystemMessage(content=<span class="hljs-string">&quot;你是一个智能助手，使用专业且准确的语言回复用户的问题，且使用中文进行回复&quot;</span>),        HumanMessage(content=<span class="hljs-string">&quot;帮我查一下今明两天的天气&quot;</span>)    ]        <span class="hljs-comment"># 初始化状态</span>    initial_state = &#123;<span class="hljs-string">&quot;messages&quot;</span>: messages, <span class="hljs-string">&quot;streamed_output&quot;</span>: []&#125;        <span class="hljs-comment"># 使用messages模式捕获流式输出</span>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> app_graph.astream(initial_state, stream_mode=<span class="hljs-string">&#x27;messages&#x27;</span>):        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(event, <span class="hljs-built_in">tuple</span>):            chunk: AIMessageChunk = event[<span class="hljs-number">0</span>]            <span class="hljs-keyword">if</span> chunk.<span class="hljs-built_in">type</span> == <span class="hljs-string">&#x27;AIMessageChunk&#x27;</span>:                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;event里监听到的流式输出------&gt;&#x27;</span>,chunk.content,<span class="hljs-string">&#x27;\n\n&#x27;</span>)</code></pre></div><p>与第一篇不同，这次选择了stream_mode=’messages’来观察模型的实时输出。</p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p>测试结果展示了完整的工作流执行过程：</p><ul><li>模型分析用户问题”帮我查一下今明两天的天气”，决定需要调用get_weather工具</li><li>工具调用节点执行get_weather函数，返回天气信息</li><li>模型收到天气信息后，生成了最终回复</li></ul><p>关键是工具调用和路由部分的执行：</p><ul><li>当模型返回包含tool_calls的消息时，tool_router函数返回”tools”</li><li>工作流转到tools节点，执行工具调用</li><li>调用的结果作为新消息被添加到对话历史</li><li>工作流返回到chat_bot节点，让模型基于工具结果生成最终回复</li></ul><p><strong>用户询问</strong>：<br>帮我查一下今明两天的天气</p><p><strong>chatbot回答</strong>：<br>好的，我来帮您查询一下。请稍等片刻经过查询，今天天气晴朗，温度20度，明天天气多云，温度25度。请问还有其他需要我帮忙查询的吗？</p><p>此时的graph图：<br><img src="/img/blog/AI/langgraph/2025-03-22_17-39-01.png"></p><p>以下是完整输出过程：</p><div class="code-wrapper"><pre><code class="hljs xl">开始生成回复...<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span>  <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span>  <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span>  <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span>  <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span>  <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span>  <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span><span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span><span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span><span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span>  <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span><span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span><span class="hljs-function"><span class="hljs-title">state</span>------&gt;</span> &#123;<span class="hljs-string">&#x27;messages&#x27;</span>: [SystemMessage(content=<span class="hljs-string">&#x27;你是一个智能助手，使用专业且准确的语言回复用户的问题，且使用中文进行回复&#x27;</span>, additional_kwargs=&#123;&#125;, response_metadata=&#123;&#125;, id=<span class="hljs-string">&#x27;76b77c29-117e-4a0f-b36c-896e2eaf13ee&#x27;</span>), HumanMessage(content=<span class="hljs-string">&#x27;帮我查一下今明两天的天气&#x27;</span>, additional_kwargs=&#123;&#125;, response_metadata=&#123;&#125;, id=<span class="hljs-string">&#x27;e0b6808b-a4ad-4ee5-829b-7718dbe06d88&#x27;</span>), AIMessage(content=<span class="hljs-string">&#x27;&#x27;</span>, additional_kwargs=&#123;<span class="hljs-string">&#x27;tool_calls&#x27;</span>: [&#123;<span class="hljs-string">&#x27;index&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;019619eaea388a97f7e451f4cefc4bfe&#x27;</span>, <span class="hljs-string">&#x27;function&#x27;</span>: &#123;<span class="hljs-string">&#x27;arguments&#x27;</span>: <span class="hljs-string">&#x27;&#123;&quot;query&quot;: &quot;今明两天天气&quot;&#125;&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;get_weather&#x27;</span>&#125;, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;function&#x27;</span>&#125;]&#125;, response_metadata=&#123;<span class="hljs-string">&#x27;finish_reason&#x27;</span>: <span class="hljs-string">&#x27;tool_calls&#x27;</span>, <span class="hljs-string">&#x27;model_name&#x27;</span>: <span class="hljs-string">&#x27;THUDM/glm-4-9b-chat&#x27;</span>&#125;, id=<span class="hljs-string">&#x27;run-6b761404-e237-4cc4-a203-2316e0ecb3e3&#x27;</span>, tool_calls=[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;get_weather&#x27;</span>, <span class="hljs-string">&#x27;args&#x27;</span>: &#123;<span class="hljs-string">&#x27;query&#x27;</span>: <span class="hljs-string">&#x27;今明两天天气&#x27;</span>&#125;, <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;019619eaea388a97f7e451f4cefc4bfe&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;tool_call&#x27;</span>&#125;], usage_metadata=&#123;<span class="hljs-string">&#x27;input_tokens&#x27;</span>: <span class="hljs-number">2076</span>, <span class="hljs-string">&#x27;output_tokens&#x27;</span>: <span class="hljs-number">65</span>, <span class="hljs-string">&#x27;total_tokens&#x27;</span>: <span class="hljs-number">2141</span>, <span class="hljs-string">&#x27;input_token_details&#x27;</span>: &#123;&#125;, <span class="hljs-string">&#x27;output_token_details&#x27;</span>: &#123;&#125;&#125;)]&#125;<span class="hljs-function"><span class="hljs-title">last_message</span>------&gt;</span> content=<span class="hljs-string">&#x27;&#x27;</span> additional_kwargs=&#123;<span class="hljs-string">&#x27;tool_calls&#x27;</span>: [&#123;<span class="hljs-string">&#x27;index&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;019619eaea388a97f7e451f4cefc4bfe&#x27;</span>, <span class="hljs-string">&#x27;function&#x27;</span>: &#123;<span class="hljs-string">&#x27;arguments&#x27;</span>: <span class="hljs-string">&#x27;&#123;&quot;query&quot;: &quot;今明两天天气&quot;&#125;&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;get_weather&#x27;</span>&#125;, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;function&#x27;</span>&#125;]&#125; response_metadata=&#123;<span class="hljs-string">&#x27;finish_reason&#x27;</span>: <span class="hljs-string">&#x27;tool_calls&#x27;</span>, <span class="hljs-string">&#x27;model_name&#x27;</span>: <span class="hljs-string">&#x27;THUDM/glm-4-9b-chat&#x27;</span>&#125; id=<span class="hljs-string">&#x27;run-6b761404-e237-4cc4-a203-2316e0ecb3e3&#x27;</span> tool_calls=[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;get_weather&#x27;</span>, <span class="hljs-string">&#x27;args&#x27;</span>: &#123;<span class="hljs-string">&#x27;query&#x27;</span>: <span class="hljs-string">&#x27;今明两天天气&#x27;</span>&#125;, <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;019619eaea388a97f7e451f4cefc4bfe&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;tool_call&#x27;</span>&#125;] usage_metadata=&#123;<span class="hljs-string">&#x27;input_tokens&#x27;</span>: <span class="hljs-number">2076</span>, <span class="hljs-string">&#x27;output_tokens&#x27;</span>: <span class="hljs-number">65</span>, <span class="hljs-string">&#x27;total_tokens&#x27;</span>: <span class="hljs-number">2141</span>, <span class="hljs-string">&#x27;input_token_details&#x27;</span>: &#123;&#125;, <span class="hljs-string">&#x27;output_token_details&#x27;</span>: &#123;&#125;&#125;<span class="hljs-function"><span class="hljs-title">last_message</span>.tool_calls------&gt;</span> [&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;get_weather&#x27;</span>, <span class="hljs-string">&#x27;args&#x27;</span>: &#123;<span class="hljs-string">&#x27;query&#x27;</span>: <span class="hljs-string">&#x27;今明两天天气&#x27;</span>&#125;, <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;019619eaea388a97f7e451f4cefc4bfe&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;tool_call&#x27;</span>&#125;]<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span>  <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span><span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 好的<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> ，<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 我来<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 帮<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 您<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 查询 <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 一下<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 。<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 请<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 稍<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 等<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 片刻<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 经过 <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 查询<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> ，<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 今天<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 天气<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 晴<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 朗<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> ，<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 温度<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> <span class="hljs-number">20</span><span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 度 <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> ，<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 明天<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 天气<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 多云<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> ，<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 温度<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> <span class="hljs-number">25</span><span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 度<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 。<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 请问<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 还有<span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 其他 <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 需要 <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 我 <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 帮忙 <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 查询 <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> 的吗 <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span> ？ <span class="hljs-function"><span class="hljs-title">event</span>里监听到的流式输出------&gt;</span>  <span class="hljs-function"><span class="hljs-title">state</span>------&gt;</span> &#123;<span class="hljs-string">&#x27;messages&#x27;</span>: [SystemMessage(content=<span class="hljs-string">&#x27;你是一个智能助手，使用专业且准确的语言回复用户的问题，且使用中文进行回复&#x27;</span>, additional_kwargs=&#123;&#125;, response_metadata=&#123;&#125;, id=<span class="hljs-string">&#x27;76b77c29-117e-4a0f-b36c-896e2eaf13ee&#x27;</span>), HumanMessage(content=<span class="hljs-string">&#x27;帮我查一下今明两天的天气&#x27;</span>, additional_kwargs=&#123;&#125;, response_metadata=&#123;&#125;, id=<span class="hljs-string">&#x27;e0b6808b-a4ad-4ee5-829b-7718dbe06d88&#x27;</span>), AIMessage(content=<span class="hljs-string">&#x27;&#x27;</span>, additional_kwargs=&#123;<span class="hljs-string">&#x27;tool_calls&#x27;</span>: [&#123;<span class="hljs-string">&#x27;index&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;019619eaea388a97f7e451f4cefc4bfe&#x27;</span>, <span class="hljs-string">&#x27;function&#x27;</span>: &#123;<span class="hljs-string">&#x27;arguments&#x27;</span>: <span class="hljs-string">&#x27;&#123;&quot;query&quot;: &quot;今明两天天气&quot;&#125;&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;get_weather&#x27;</span>&#125;, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;function&#x27;</span>&#125;]&#125;, response_metadata=&#123;<span class="hljs-string">&#x27;finish_reason&#x27;</span>: <span class="hljs-string">&#x27;tool_calls&#x27;</span>, <span class="hljs-string">&#x27;model_name&#x27;</span>: <span class="hljs-string">&#x27;THUDM/glm-4-9b-chat&#x27;</span>&#125;, id=<span class="hljs-string">&#x27;run-6b761404-e237-4cc4-a203-2316e0ecb3e3&#x27;</span>, tool_calls=[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;get_weather&#x27;</span>, <span class="hljs-string">&#x27;args&#x27;</span>: &#123;<span class="hljs-string">&#x27;query&#x27;</span>: <span class="hljs-string">&#x27;今明两天天气&#x27;</span>&#125;, <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;019619eaea388a97f7e451f4cefc4bfe&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;tool_call&#x27;</span>&#125;], usage_metadata=&#123;<span class="hljs-string">&#x27;input_tokens&#x27;</span>: <span class="hljs-number">2076</span>, <span class="hljs-string">&#x27;output_tokens&#x27;</span>: <span class="hljs-number">65</span>, <span class="hljs-string">&#x27;total_tokens&#x27;</span>: <span class="hljs-number">2141</span>, <span class="hljs-string">&#x27;input_token_details&#x27;</span>: &#123;&#125;, <span class="hljs-string">&#x27;output_token_details&#x27;</span>: &#123;&#125;&#125;), ToolMessage(content=<span class="hljs-string">&#x27;[&quot;今天天气晴朗，温度20度&quot;, &quot;明天天气多云，温度25度&quot;]&#x27;</span>, <span class="hljs-keyword">name</span>=<span class="hljs-string">&#x27;get_weather&#x27;</span>, id=<span class="hljs-string">&#x27;4d8564fa-8301-4672-8e8d-64f6cecbf936&#x27;</span>, tool_call_id=<span class="hljs-string">&#x27;019619eaea388a97f7e451f4cefc4bfe&#x27;</span>), AIMessage(content=<span class="hljs-string">&#x27;\n好的，我来帮您查询一下。请稍等片 刻经过查询，今天天气晴朗，温度20度，明天天气多云，温度25度。请问还有其他需要我帮忙查询的吗？&#x27;</span>, additional_kwargs=&#123;&#125;, response_metadata=&#123;<span class="hljs-string">&#x27;finish_reason&#x27;</span>: <span class="hljs-string">&#x27;stop&#x27;</span>, <span class="hljs-string">&#x27;model_name&#x27;</span>: <span class="hljs-string">&#x27;THUDM/glm-4-9b-chat&#x27;</span>&#125;, id=<span class="hljs-string">&#x27;run-b9e66b49-9301-4343-8e51-67d3d48737c1&#x27;</span>, usage_metadata=&#123;<span class="hljs-string">&#x27;input_tokens&#x27;</span>: <span class="hljs-number">8668</span>, <span class="hljs-string">&#x27;output_tokens&#x27;</span>: <span class="hljs-number">945</span>, <span class="hljs-string">&#x27;total_tokens&#x27;</span>: <span class="hljs-number">9613</span>, <span class="hljs-string">&#x27;input_token_details&#x27;</span>: &#123;&#125;, <span class="hljs-string">&#x27;output_token_details&#x27;</span>: &#123;&#125;&#125;)]&#125;<span class="hljs-function"><span class="hljs-title">last_message</span>------&gt;</span> content=<span class="hljs-string">&#x27;\n好的，我来帮您查询一下。请稍等片刻经过查询，今天天气晴朗，温度20度，明天天气多云，温度25度。请问还有其他需要我帮忙查询的吗？&#x27;</span> additional_kwargs=&#123;&#125; response_metadata=&#123;<span class="hljs-string">&#x27;finish_reason&#x27;</span>: <span class="hljs-string">&#x27;stop&#x27;</span>, <span class="hljs-string">&#x27;model_name&#x27;</span>: <span class="hljs-string">&#x27;THUDM/glm-4-9b-chat&#x27;</span>&#125; id=<span class="hljs-string">&#x27;run-b9e66b49-9301-4343-8e51-67d3d48737c1&#x27;</span> usage_metadata=&#123;<span class="hljs-string">&#x27;input_tokens&#x27;</span>: <span class="hljs-number">8668</span>, <span class="hljs-string">&#x27;output_tokens&#x27;</span>: <span class="hljs-number">945</span>, <span class="hljs-string">&#x27;total_tokens&#x27;</span>: <span class="hljs-number">9613</span>, <span class="hljs-string">&#x27;input_token_details&#x27;</span>: &#123;&#125;, <span class="hljs-string">&#x27;output_token_details&#x27;</span>: &#123;&#125;&#125;<span class="hljs-function"><span class="hljs-title">last_message</span>.tool_calls------&gt;</span> []</code></pre></div><p>以下是完整代码：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Literal</span><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<span class="hljs-keyword">from</span> langchain_core.messages <span class="hljs-keyword">import</span> HumanMessage, AIMessage, SystemMessage, AIMessageChunk<span class="hljs-keyword">from</span> langgraph.graph <span class="hljs-keyword">import</span> Graph, StateGraph, MessagesState, END<span class="hljs-keyword">from</span> langchain_community.chat_models <span class="hljs-keyword">import</span> QianfanChatEndpoint<span class="hljs-keyword">from</span> langchain_core.tools <span class="hljs-keyword">import</span> tool<span class="hljs-keyword">from</span> langgraph.prebuilt <span class="hljs-keyword">import</span> ToolNode<span class="hljs-keyword">import</span> asyncio<span class="hljs-keyword">from</span> langchain_core.runnables.graph <span class="hljs-keyword">import</span> MermaidDrawMethod<span class="hljs-keyword">from</span> langchain_core.utils.function_calling <span class="hljs-keyword">import</span> convert_to_openai_function<span class="hljs-comment"># 百度千帆的调用方式</span><span class="hljs-comment"># llm = QianfanChatEndpoint(</span><span class="hljs-comment">#     model=&quot;ERNIE-Speed-128K&quot;,</span><span class="hljs-comment">#     streaming=True,  # 启用流式输出</span><span class="hljs-comment">#     api_key=os.getenv(&#x27;QIANFAN_AK&#x27;, &#x27;&#x27;),</span><span class="hljs-comment">#     secret_key=os.getenv(&#x27;QIANFAN_SK&#x27;, &#x27;&#x27;)</span><span class="hljs-comment"># )</span><span class="hljs-comment"># 硅基流动的api调用方式</span>llm = ChatOpenAI(    <span class="hljs-comment">#THUDM/glm-4-9b-chat</span>    <span class="hljs-comment">#Qwen/Qwen2.5-7B-Instruct</span>    model=<span class="hljs-string">&quot;THUDM/glm-4-9b-chat&quot;</span>,    streaming=<span class="hljs-literal">False</span>,  <span class="hljs-comment"># 启用流式输出</span>    api_key=os.getenv(<span class="hljs-string">&#x27;SILICONFLOW_API_KEY&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>),     base_url=os.getenv(<span class="hljs-string">&#x27;SILICONFLOW_BASE_URL&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>),    temperature=<span class="hljs-number">0.1</span>,)<span class="hljs-comment"># 定义工具</span><span class="hljs-meta">@tool</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_weather</span>(<span class="hljs-params">query: <span class="hljs-built_in">str</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;用于获取天气信息。&quot;&quot;&quot;</span>    <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;今天天气晴朗，温度20度&quot;</span>, <span class="hljs-string">&quot;明天天气多云，温度25度&quot;</span>]tools = [get_weather]llm_with_tools = llm.bind_tools(tools)<span class="hljs-comment"># 创建工具列表的函数版本</span>functions = [convert_to_openai_function(t) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tools]<span class="hljs-comment"># 创建tool节点</span>tool_node = ToolNode(tools)<span class="hljs-comment"># llm的调用</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chat_bot</span>(<span class="hljs-params">state: MessagesState</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;生成流式回复的节点函数&quot;&quot;&quot;</span>    messages = state[<span class="hljs-string">&quot;messages&quot;</span>]    <span class="hljs-comment"># response = await llm.ainvoke(messages)</span>    response = <span class="hljs-keyword">await</span> llm_with_tools.ainvoke(        messages,        functions=functions,        function_call=<span class="hljs-string">&quot;auto&quot;</span>    )    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;messages&quot;</span>: [response]&#125;<span class="hljs-comment"># 4.定义边的逻辑判断（条件边），判断是否继续</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tool_router</span>(<span class="hljs-params">state: MessagesState</span>) -&gt; <span class="hljs-type">Literal</span>[&quot;tools&quot;, &quot;__end__&quot;]:</span> <span class="hljs-comment">#Literal用于限制返回的值的可选值</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;state------&gt;&#x27;</span>,state,<span class="hljs-string">&#x27;\n&#x27;</span>)    messages = state[<span class="hljs-string">&#x27;messages&#x27;</span>]    last_message = messages[-<span class="hljs-number">1</span>]    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;last_message------&gt;&#x27;</span>,last_message,<span class="hljs-string">&#x27;\n&#x27;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;last_message.tool_calls------&gt;&#x27;</span>,last_message.tool_calls,<span class="hljs-string">&#x27;\n&#x27;</span>)    <span class="hljs-keyword">if</span> last_message.tool_calls: <span class="hljs-comment">#判断models是否返回tools调用，有则告诉调用tools节点，否则结束</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;tools&quot;</span>    <span class="hljs-keyword">return</span> END<span class="hljs-comment"># 创建工作流程</span>workflow = StateGraph(MessagesState)<span class="hljs-comment"># 添加节点</span>workflow.add_node(<span class="hljs-string">&quot;chat_bot&quot;</span>, chat_bot)<span class="hljs-comment"># 设置入口节点</span>workflow.set_entry_point(<span class="hljs-string">&quot;chat_bot&quot;</span>)<span class="hljs-comment"># 添加tool节点</span>workflow.add_node(<span class="hljs-string">&quot;tools&quot;</span>, tool_node)<span class="hljs-comment"># 从tools节点指向chat_bot节点，以便可能的后续交互</span>workflow.add_edge(<span class="hljs-string">&quot;tools&quot;</span>, <span class="hljs-string">&quot;chat_bot&quot;</span>)workflow.add_conditional_edges(    <span class="hljs-string">&quot;chat_bot&quot;</span>,    tool_router,    <span class="hljs-comment">#判断下一个调用的节点</span>)<span class="hljs-comment"># 编译图</span>app_graph = workflow.<span class="hljs-built_in">compile</span>()<span class="hljs-comment"># 定义一个将图导出为PNG的函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">export_graph_to_png</span>():</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    将LangGraph图导出为PNG格式</span><span class="hljs-string">    Returns:</span><span class="hljs-string">        str: 生成的PNG文件路径</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">try</span>:        output_file=<span class="hljs-string">&#x27;简单的chatbot-&#x27;</span>+datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%d_%H-%M-%S&quot;</span>)+<span class="hljs-string">&quot;.png&quot;</span>        app_graph.get_graph().draw_mermaid_png(            draw_method=MermaidDrawMethod.API,            output_file_path=output_file        )        <span class="hljs-comment"># return True</span>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;导出PNG图形时出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><span class="hljs-comment"># 测试运行函数</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_streaming_chain</span>():</span>    <span class="hljs-string">&quot;&quot;&quot;运行graph的链&quot;&quot;&quot;</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始生成回复...\n&quot;</span>)    messages = [        SystemMessage(content=<span class="hljs-string">&quot;你是一个智能助手，使用专业且准确的语言回复用户的问题，且使用中文进行回复&quot;</span>),        HumanMessage(content=<span class="hljs-string">&quot;帮我查一下今明两天的天气&quot;</span>)    ]        <span class="hljs-comment"># 初始化状态</span>    initial_state = &#123;<span class="hljs-string">&quot;messages&quot;</span>: messages, <span class="hljs-string">&quot;streamed_output&quot;</span>: []&#125;        <span class="hljs-comment"># stream_mode values的效果</span>    <span class="hljs-comment"># async for event in app_graph.astream(initial_state, config=&#123;&quot;configurable&quot;: &#123;&quot;thread_id&quot;: &quot;1&quot;&#125;&#125;, stream_mode=&quot;values&quot;):</span>    <span class="hljs-comment">#     # print(&#x27;event------&gt;&#x27;,event,&#x27;\n\n&#x27;)</span>    <span class="hljs-comment">#     if &quot;messages&quot; in event:</span>    <span class="hljs-comment">#         event[&quot;messages&quot;][-1].pretty_print()</span>    <span class="hljs-comment">#     pass</span>        <span class="hljs-comment"># stream_mode messages的流式效果</span>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> app_graph.astream(initial_state, stream_mode=<span class="hljs-string">&#x27;messages&#x27;</span>):        <span class="hljs-comment"># print(&#x27;event------&gt;&#x27;,event,&#x27;\n\n&#x27;)</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(event, <span class="hljs-built_in">tuple</span>):            chunk: AIMessageChunk = event[<span class="hljs-number">0</span>]            <span class="hljs-keyword">if</span> chunk.<span class="hljs-built_in">type</span> == <span class="hljs-string">&#x27;AIMessageChunk&#x27;</span>:                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;event里监听到的流式输出------&gt;&#x27;</span>,chunk.content,<span class="hljs-string">&#x27;\n\n&#x27;</span>)        <span class="hljs-comment"># print(&quot;\n回复完成&quot;)</span>        <span class="hljs-comment"># 展示图形</span>    <span class="hljs-keyword">try</span>:        <span class="hljs-comment"># 导出为PNG</span>        export_graph_to_png()    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;图表绘制出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<span class="hljs-comment"># 运行流式输出</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    asyncio.run(run_streaming_chain())</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>AI相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Langgraph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Langgraph学习1：基础流程</title>
    <link href="/2025/03/22/Langgraph%E5%AD%A6%E4%B9%A01%EF%BC%9A%E5%9F%BA%E7%A1%80chatbot/"/>
    <url>/2025/03/22/Langgraph%E5%AD%A6%E4%B9%A01%EF%BC%9A%E5%9F%BA%E7%A1%80chatbot/</url>
    
    <content type="html"><![CDATA[<p>最近开始学习Langgraph，决定从基础的chatbot开始，一步步记录一下学习过程</p><h2 id="1-LLM免费API调用方式"><a href="#1-LLM免费API调用方式" class="headerlink" title="1. LLM免费API调用方式"></a>1. LLM免费API调用方式</h2><p>开始构建chatbot的第一步是选择合适的大语言模型。为了节省费用，这里尝试了两种不同平台的的免费LLM API的调用方式：百度千帆和硅基流动。</p><h3 id="百度千帆调用"><a href="#百度千帆调用" class="headerlink" title="百度千帆调用"></a>百度千帆调用</h3><p>这是demo中目前使用的方式，主要通过QianfanChatEndpoint来调用百度的ERNIE-Speed-128K免费模型：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-keyword">from</span> langchain_community.chat_models <span class="hljs-keyword">import</span> QianfanChatEndpointllm = QianfanChatEndpoint(    model=<span class="hljs-string">&quot;ERNIE-Speed-128K&quot;</span>,    streaming=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 启用流式输出</span>    api_key=os.getenv(<span class="hljs-string">&#x27;QIANFAN_AK&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>),    secret_key=os.getenv(<span class="hljs-string">&#x27;QIANFAN_SK&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))</code></pre></div><h3 id="硅基流动调用方式"><a href="#硅基流动调用方式" class="headerlink" title="硅基流动调用方式"></a>硅基流动调用方式</h3><p>另一种方式是使用硅基流动的API，通过ChatOpenAI来调用国产的GLM或Qwen等免费模型：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAIllm = ChatOpenAI(    <span class="hljs-comment">#THUDM/glm-4-9b-chat</span>    <span class="hljs-comment">#Qwen/Qwen2.5-7B-Instruct</span>    model=<span class="hljs-string">&quot;THUDM/glm-4-9b-chat&quot;</span>,    streaming=<span class="hljs-literal">False</span>,    api_key=os.getenv(<span class="hljs-string">&#x27;SILICONFLOW_API_KEY&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>),     base_url=os.getenv(<span class="hljs-string">&#x27;SILICONFLOW_BASE_URL&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>),    temperature=<span class="hljs-number">0.1</span>,)</code></pre></div><h2 id="2-构建基础Langgraph工作流"><a href="#2-构建基础Langgraph工作流" class="headerlink" title="2. 构建基础Langgraph工作流"></a>2. 构建基础Langgraph工作流</h2><p>接下来定义一个简单的chat节点函数和工作流：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<span class="hljs-keyword">from</span> langchain_core.messages <span class="hljs-keyword">import</span> HumanMessage, AIMessage, SystemMessage, AIMessageChunk<span class="hljs-keyword">from</span> langgraph.graph <span class="hljs-keyword">import</span> Graph, StateGraph, MessagesState, END<span class="hljs-keyword">import</span> asyncio<span class="hljs-keyword">from</span> langchain_core.runnables.graph <span class="hljs-keyword">import</span> MermaidDrawMethod<span class="hljs-comment"># llm的调用</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chat_bot</span>(<span class="hljs-params">state: MessagesState</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;生成流式回复的节点函数&quot;&quot;&quot;</span>    messages = state[<span class="hljs-string">&quot;messages&quot;</span>]    <span class="hljs-comment"># 使用非流式方式接收完整返回</span>    response = <span class="hljs-keyword">await</span> llm.ainvoke(messages)    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;messages&quot;</span>: [response]&#125;<span class="hljs-comment"># 创建工作流程</span>workflow = StateGraph(MessagesState)<span class="hljs-comment"># 添加节点</span>workflow.add_node(<span class="hljs-string">&quot;chat_bot&quot;</span>, chat_bot)<span class="hljs-comment"># 设置入口节点</span>workflow.set_entry_point(<span class="hljs-string">&quot;chat_bot&quot;</span>)<span class="hljs-comment"># 添加边，从chat_bot节点到end节点</span>workflow.add_edge(<span class="hljs-string">&quot;chat_bot&quot;</span>, END)<span class="hljs-comment"># 编译图</span>app_graph = workflow.<span class="hljs-built_in">compile</span>()</code></pre></div><p>在这个工作流中，只设置了一个chat_bot节点，它接收消息并返回LLM的回复。工作流的结构很简单：入口 -&gt; chat_bot -&gt; 结束。</p><h2 id="3-两种流式输出方式"><a href="#3-两种流式输出方式" class="headerlink" title="3. 两种流式输出方式"></a>3. 两种流式输出方式</h2><p>在Langgraph中，有多种调试和输出方式，这里尝试了两种不同的流式输出方式：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_streaming_chain</span>():</span>    <span class="hljs-string">&quot;&quot;&quot;运行graph的链&quot;&quot;&quot;</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始生成回复...\n&quot;</span>)    messages = [        SystemMessage(content=<span class="hljs-string">&quot;你是一个智能助手，使用专业且准确的语言回复用户的问题，且使用中文进行回复&quot;</span>),        HumanMessage(content=<span class="hljs-string">&quot;什么花最丑&quot;</span>)    ]    <span class="hljs-comment"># 初始化状态</span>    initial_state = &#123;<span class="hljs-string">&quot;messages&quot;</span>: messages, <span class="hljs-string">&quot;streamed_output&quot;</span>: []&#125;    <span class="hljs-comment"># stream_mode values的效果</span>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> app_graph.astream(initial_state, config=&#123;<span class="hljs-string">&quot;configurable&quot;</span>: &#123;<span class="hljs-string">&quot;thread_id&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;&#125;, stream_mode=<span class="hljs-string">&quot;values&quot;</span>):        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;messages&quot;</span> <span class="hljs-keyword">in</span> event:            event[<span class="hljs-string">&quot;messages&quot;</span>][-<span class="hljs-number">1</span>].pretty_print()        <span class="hljs-keyword">pass</span></code></pre></div><p>这种方式会返回完整的消息对象，适合需要处理完整状态更新的场景。<br><img src="/img/blog/AI/langgraph/2025-03-22_16-27-58.png"></p><h3 id="第二种：stream-mode-”messages”"><a href="#第二种：stream-mode-”messages”" class="headerlink" title="第二种：stream_mode=”messages”"></a>第二种：stream_mode=”messages”</h3><p>这种方式可以获取真正的流式输出片段：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># stream_mode messages的流式效果</span>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> app_graph.astream(initial_state, stream_mode=<span class="hljs-string">&#x27;messages&#x27;</span>):        <span class="hljs-comment"># print(&#x27;event------&gt;&#x27;,event,&#x27;\n\n&#x27;)</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(event, <span class="hljs-built_in">tuple</span>):            chunk: AIMessageChunk = event[<span class="hljs-number">0</span>]            <span class="hljs-keyword">if</span> chunk.<span class="hljs-built_in">type</span> == <span class="hljs-string">&#x27;AIMessageChunk&#x27;</span>:                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;event里监听到的流式输出------&gt;&#x27;</span>,chunk.content,<span class="hljs-string">&#x27;\n\n&#x27;</span>)</code></pre></div><p>使用messages模式可以获取每个小片段的输出，适合需要实时展示生成内容的场景，比如打字机效果。</p><p><img src="/img/blog/AI/langgraph/2025-03-22_16-34-30.png"></p><h2 id="4-使用MermaidDrawMethod可视化工作流"><a href="#4-使用MermaidDrawMethod可视化工作流" class="headerlink" title="4.使用MermaidDrawMethod可视化工作流"></a>4.使用MermaidDrawMethod可视化工作流</h2><p>最后，将构建的Langgraph工作流可视化出来，便于理解和记录：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个将图导出为PNG的函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">export_graph_to_png</span>():</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    将LangGraph图导出为PNG格式</span><span class="hljs-string">    Returns:</span><span class="hljs-string">        str: 生成的PNG文件路径</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">try</span>:        output_file=<span class="hljs-string">&#x27;简单的chatbot-&#x27;</span>+datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%d_%H-%M-%S&quot;</span>)+<span class="hljs-string">&quot;.png&quot;</span>        app_graph.get_graph().draw_mermaid_png(            draw_method=MermaidDrawMethod.API,            output_file_path=output_file        )    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;导出PNG图形时出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre></div><p>在这个函数中，使用MermaidDrawMethod.API方法生成了工作流的可视化图片。Langgraph支持多种可视化方式，API方式是其中比较常用的一种，它会调用Mermaid的在线服务生成图片。生成的图片名称会根据以上代码逻辑以包含时间戳，便于区分不同批次运行后的结果。</p><p><img src="/img/blog/AI/langgraph/2025-03-22_16-03-41.png"></p><p>完整代码如下：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<span class="hljs-keyword">from</span> langchain_core.messages <span class="hljs-keyword">import</span> HumanMessage, AIMessage, SystemMessage, AIMessageChunk<span class="hljs-keyword">from</span> langgraph.graph <span class="hljs-keyword">import</span> Graph, StateGraph, MessagesState, END<span class="hljs-keyword">from</span> langchain_community.chat_models <span class="hljs-keyword">import</span> QianfanChatEndpoint<span class="hljs-keyword">import</span> asyncio<span class="hljs-keyword">from</span> langchain_core.runnables.graph <span class="hljs-keyword">import</span> MermaidDrawMethod<span class="hljs-comment"># 百度千帆的调用方式</span>llm = QianfanChatEndpoint(    model=<span class="hljs-string">&quot;ERNIE-Speed-128K&quot;</span>,    streaming=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 启用流式输出</span>    api_key=os.getenv(<span class="hljs-string">&#x27;QIANFAN_AK&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>),    secret_key=os.getenv(<span class="hljs-string">&#x27;QIANFAN_SK&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))<span class="hljs-comment"># 硅基流动的api调用方式</span><span class="hljs-comment"># llm = ChatOpenAI(</span><span class="hljs-comment">#     #THUDM/glm-4-9b-chat</span><span class="hljs-comment">#     #Qwen/Qwen2.5-7B-Instruct</span><span class="hljs-comment">#     model=&quot;THUDM/glm-4-9b-chat&quot;,</span><span class="hljs-comment">#     streaming=False,  # 启用流式输出</span><span class="hljs-comment">#     api_key=os.getenv(&#x27;SILICONFLOW_API_KEY&#x27;, &#x27;&#x27;), </span><span class="hljs-comment">#     base_url=os.getenv(&#x27;SILICONFLOW_BASE_URL&#x27;, &#x27;&#x27;),</span><span class="hljs-comment">#     temperature=0.1,</span><span class="hljs-comment"># )</span><span class="hljs-comment"># llm的调用</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chat_bot</span>(<span class="hljs-params">state: MessagesState</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;生成流式回复的节点函数&quot;&quot;&quot;</span>    messages = state[<span class="hljs-string">&quot;messages&quot;</span>]   <span class="hljs-comment"># 使用非流式方式接收完整返回</span>    response = <span class="hljs-keyword">await</span> llm.ainvoke(messages)    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;messages&quot;</span>: [response]&#125;<span class="hljs-comment"># 创建工作流程</span>workflow = StateGraph(MessagesState)<span class="hljs-comment"># 添加节点</span>workflow.add_node(<span class="hljs-string">&quot;chat_bot&quot;</span>, chat_bot)<span class="hljs-comment"># 设置入口节点</span>workflow.set_entry_point(<span class="hljs-string">&quot;chat_bot&quot;</span>)<span class="hljs-comment"># 添加边，从chat_bot节点到end节点</span>workflow.add_edge(<span class="hljs-string">&quot;chat_bot&quot;</span>, END)<span class="hljs-comment"># 编译图</span>app_graph = workflow.<span class="hljs-built_in">compile</span>()<span class="hljs-comment"># 定义一个将图导出为PNG的函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">export_graph_to_png</span>():</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    将LangGraph图导出为PNG格式</span><span class="hljs-string">    Returns:</span><span class="hljs-string">        str: 生成的PNG文件路径</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-keyword">try</span>:        output_file=<span class="hljs-string">&#x27;简单的chatbot-&#x27;</span>+datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%d_%H-%M-%S&quot;</span>)+<span class="hljs-string">&quot;.png&quot;</span>        app_graph.get_graph().draw_mermaid_png(            draw_method=MermaidDrawMethod.API,            output_file_path=output_file        )        <span class="hljs-comment"># return True</span>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;导出PNG图形时出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><span class="hljs-comment"># 测试运行函数</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_streaming_chain</span>():</span>    <span class="hljs-string">&quot;&quot;&quot;运行graph的链&quot;&quot;&quot;</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始生成回复...\n&quot;</span>)    messages = [        SystemMessage(content=<span class="hljs-string">&quot;你是一个智能助手，使用专业且准确的语言回复用户的问题，且使用中文进行回复&quot;</span>),        HumanMessage(content=<span class="hljs-string">&quot;什么花最丑&quot;</span>)    ]    <span class="hljs-comment"># 初始化状态</span>    initial_state = &#123;<span class="hljs-string">&quot;messages&quot;</span>: messages, <span class="hljs-string">&quot;streamed_output&quot;</span>: []&#125;    <span class="hljs-comment"># stream_mode values的效果</span>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> app_graph.astream(initial_state, config=&#123;<span class="hljs-string">&quot;configurable&quot;</span>: &#123;<span class="hljs-string">&quot;thread_id&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;&#125;, stream_mode=<span class="hljs-string">&quot;values&quot;</span>):        <span class="hljs-comment"># print(&#x27;event------&gt;&#x27;,event,&#x27;\n\n&#x27;)</span>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;messages&quot;</span> <span class="hljs-keyword">in</span> event:            event[<span class="hljs-string">&quot;messages&quot;</span>][-<span class="hljs-number">1</span>].pretty_print()        <span class="hljs-keyword">pass</span>    <span class="hljs-comment"># stream_mode messages的流式效果</span>    <span class="hljs-comment"># async for event in app_graph.astream(initial_state, stream_mode=&#x27;messages&#x27;):</span>    <span class="hljs-comment">#     # print(&#x27;event------&gt;&#x27;,event,&#x27;\n\n&#x27;)</span>    <span class="hljs-comment">#     if isinstance(event, tuple):</span>    <span class="hljs-comment">#         chunk: AIMessageChunk = event[0]</span>    <span class="hljs-comment">#         if chunk.type == &#x27;AIMessageChunk&#x27;:</span>    <span class="hljs-comment">#             print(&#x27;event里监听到的流式输出------&gt;&#x27;,chunk.content,&#x27;\n\n&#x27;)</span>    <span class="hljs-comment"># print(&quot;\n回复完成&quot;)</span>    <span class="hljs-comment"># 展示图形</span>    <span class="hljs-keyword">try</span>:        <span class="hljs-comment"># 导出为PNG</span>        export_graph_to_png()    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;图表绘制出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<span class="hljs-comment"># 运行流式输出</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    asyncio.run(run_streaming_chain())</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>AI相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Langgraph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STAR形式分享AI编程-2</title>
    <link href="/2025/03/12/STAR%E5%BD%A2%E5%BC%8F%E5%88%86%E4%BA%ABAI%E7%BC%96%E7%A8%8B2/"/>
    <url>/2025/03/12/STAR%E5%BD%A2%E5%BC%8F%E5%88%86%E4%BA%ABAI%E7%BC%96%E7%A8%8B2/</url>
    
    <content type="html"><![CDATA[<h2 id="分享一个使用AI助手编程时AI表现不足的STAR："><a href="#分享一个使用AI助手编程时AI表现不足的STAR：" class="headerlink" title="分享一个使用AI助手编程时AI表现不足的STAR："></a>分享一个使用AI助手编程时AI表现不足的STAR：</h2><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p><strong>编码工具：</strong> Cursor<br><strong>AI模型：</strong> claude-3.5-sonnet</p><h2 id="实践描述"><a href="#实践描述" class="headerlink" title="实践描述"></a>实践描述</h2><h3 id="Situation-amp-Task"><a href="#Situation-amp-Task" class="headerlink" title="Situation &amp; Task"></a>Situation &amp; Task</h3><p>最近接手做一个别的团队成员维护的AI项目，刚开始的时候我没有了解过这个项目之前的业务逻辑和数据处理逻辑，第一时间会让AI代替我理解和修改一些功能，比如打字机的处理、SSE的流式输出处理、对话流程处理，通常大家编码的时候一些函数里或多或少会有和业务相关的代码，这时候直接询问AI会将一些业务相关的东西帮你一起处理，处理的结果有几种可能的情况：</p><p>一是它不会去管那些和业务相关的代码，只帮你做数据处理</p><p>二是它会直接删除它觉得这里不应该有的代码，包括业务逻辑</p><p>三就像是前面两者的混合，有删有增，它看完上下文后觉得，前面一个地方改了某个逻辑，这里也要配合改才合适，然后主动帮你把它觉得这里不改就可能是个bug的地方给补上去</p><p>受各种业务逻辑的干扰，通常让AI改完再验证，再继续问答再验证，假如一个能2小时完成的事情，几个轮次下来可能时间已经过去一半仍然没有进展</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>尝试细节拆分：</p><p>业务流程归业务流程，数据处理归数据处理，两者尽量改为独立的函数做处理，关键逻辑要像”把大象装冰箱分三步”那样写清楚</p><p>比如流式数据处理，里面包含think标签和content两部分，至于业务上是什么流程，不要在数据处理的同时让AI过多关注，只需要告诉它，在如下所示的格式里，前面一段think标签和里面的内容，需要单独放在一个字段，</think>后面的单独放在一个字段，并确保在流式输出中不会因为不在同一帧里有截断漏掉的情况，并且有可能会多个开始和结尾标签都在同一帧的情况等等细节描述</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">think</span>&gt;</span>这里是思考内容这里是思考内容这里是思考内容这里是思考内容这里是思考内容这里是思考内容这里是思考内容这里是思考内容这里是思考内容这里是思考内容这里是思考内容这里是思考内容这里是思考内容这里是思考内容。<span class="hljs-tag">&lt;/<span class="hljs-name">think</span>&gt;</span>这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文。</code></pre></div><p>首先对数据逻辑的可能性进行描述</p><div class="code-wrapper"><pre><code class="hljs xml">处理thinkContent的方法逻辑- 1. 当message包含<span class="hljs-tag">&lt;<span class="hljs-name">think</span>&gt;</span>标签时，将message中的<span class="hljs-tag">&lt;<span class="hljs-name">think</span>&gt;</span>标签和后面文案开头的br标签进行去除- 2. 当message包含<span class="hljs-tag">&lt;/<span class="hljs-name">think</span>&gt;</span>标签时，将message中的<span class="hljs-tag">&lt;/<span class="hljs-name">think</span>&gt;</span>标签和后面文案开头的br标签进行去除，同时fullResponseContent需要拼接<span class="hljs-tag">&lt;/<span class="hljs-name">think</span>&gt;</span>后面的内容，否则正文会缺失一部分- 3. 即没有<span class="hljs-tag">&lt;<span class="hljs-name">think</span>&gt;</span>标签也没有<span class="hljs-tag">&lt;/<span class="hljs-name">think</span>&gt;</span>标签时，即代表是<span class="hljs-tag">&lt;<span class="hljs-name">think</span>&gt;</span>标签和<span class="hljs-tag">&lt;/<span class="hljs-name">think</span>&gt;</span>标签之间的内容，正常拼接- 4. 如果message既包含<span class="hljs-tag">&lt;<span class="hljs-name">think</span>&gt;</span>标签，也包含<span class="hljs-tag">&lt;/<span class="hljs-name">think</span>&gt;</span>标签，那么需要把<span class="hljs-tag">&lt;<span class="hljs-name">think</span>&gt;</span>标签和<span class="hljs-tag">&lt;/<span class="hljs-name">think</span>&gt;</span>标签之间的内容进行拼接，同时fullResponseContent需要拼接<span class="hljs-tag">&lt;/<span class="hljs-name">think</span>&gt;</span>后面的内容，否则正文会到think卡片里去</code></pre></div><p>以下是AI给出的function的完整输出，基本是直接拿来用的:</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 处理thinkContent，这里需要处理&lt;think&gt;标签和&lt;/think&gt;标签，和&lt;br&gt;标签</span><span class="hljs-comment"> * 1. 当message包含&lt;think&gt;标签时，将message中的&lt;think&gt;标签和后面文案开头的br标签进行去除</span><span class="hljs-comment"> * 2. 当message包含&lt;/think&gt;标签时，将message中的&lt;/think&gt;标签和后面文案开头的br标签进行去除，同时fullResponseContent需要拼接&lt;/think&gt;后面的内容，否则正文会缺失一部分</span><span class="hljs-comment"> * 3. 即没有&lt;think&gt;标签也没有&lt;/think&gt;标签时，即代表是&lt;think&gt;标签和&lt;/think&gt;标签之间的内容，正常拼接</span><span class="hljs-comment"> * 4. 如果message既包含&lt;think&gt;标签，也包含&lt;/think&gt;标签，那么需要把&lt;think&gt;标签和&lt;/think&gt;标签之间的内容进行拼接，同时fullResponseContent需要拼接&lt;/think&gt;后面的内容，否则正文会到think卡片里去</span><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>message event.data</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> handleThinkContent = <span class="hljs-function">(<span class="hljs-params">message: string</span>) =&gt;</span> &#123;  thinkBuffer.value += message;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;LOG: thinkBuffer:&quot;</span>, thinkBuffer.value);  <span class="hljs-comment">// 检查是否一次性接收到完整的think内容或者一次性接收到所有思考+正文内容，这时候需要把think之后的内容全部放到fullResponseContent.value里</span>  <span class="hljs-keyword">if</span> (message.includes(<span class="hljs-string">&quot;&lt;think&gt;&quot;</span>) &amp;&amp; message.includes(<span class="hljs-string">&quot;&lt;/think&gt;&quot;</span>)) &#123;    <span class="hljs-comment">// 一次性接收到完整内容的处理</span>    <span class="hljs-keyword">const</span> thinkStartIndex = message.indexOf(<span class="hljs-string">&quot;&lt;think&gt;&quot;</span>);    <span class="hljs-keyword">const</span> thinkEndIndex = message.indexOf(<span class="hljs-string">&quot;&lt;/think&gt;&quot;</span>);        <span class="hljs-comment">// 提取think内容</span>    <span class="hljs-keyword">const</span> thinkContentStr = message.substring(thinkStartIndex + <span class="hljs-number">7</span>, thinkEndIndex + <span class="hljs-number">8</span>)      .replace(<span class="hljs-regexp">/^(?:&lt;br&gt;)+/</span>, <span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">// 去除开头的&lt;br&gt;</span>      .replace(<span class="hljs-regexp">/(?:&lt;br&gt;)+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// 去除结尾的&lt;br&gt;</span>      <span class="hljs-comment">// 更新think内容</span>    thinkContent.value = thinkContentStr;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;LOG: thinkContent:&quot;</span>, thinkContent.value);        <span class="hljs-comment">// 提取think之前和之后的内容作为正文</span>    <span class="hljs-keyword">let</span> afterThinkContent = (thinkBuffer.value.substring(thinkBuffer.value.indexOf(<span class="hljs-string">&quot;&lt;/think&gt;&quot;</span>) + <span class="hljs-number">8</span>)).replace(<span class="hljs-regexp">/^(?:&lt;br&gt;)+/</span>, <span class="hljs-string">&#x27;&#x27;</span>);    <span class="hljs-comment">// 更新正文内容</span>    fullResponseContent.value += afterThinkContent;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;LOG: fullResponseContent:&quot;</span>, fullResponseContent.value);    handleFullResponseContent();        <span class="hljs-comment">// 重置状态</span>    isCollectingThink.value = <span class="hljs-literal">false</span>;    thinkBuffer.value = <span class="hljs-string">&quot;&quot;</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">if</span> (message.includes(<span class="hljs-string">&quot;&lt;think&gt;&quot;</span>)) &#123;      isCollectingThink.value = <span class="hljs-literal">true</span>;      thinkBuffer.value = (message.substring(message.indexOf(<span class="hljs-string">&quot;&lt;think&gt;&quot;</span>) + <span class="hljs-number">7</span>)).replace(<span class="hljs-regexp">/^(?:&lt;br&gt;)+/</span>, <span class="hljs-string">&#x27;&#x27;</span>);      thinkContent.value = thinkBuffer.value;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;LOG: thinkContent:&quot;</span>, thinkContent.value);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (message.includes(<span class="hljs-string">&quot;&lt;/think&gt;&quot;</span>)) &#123;      isCollectingThink.value = <span class="hljs-literal">false</span>;      <span class="hljs-comment">// 获取&lt;/think&gt;标签后的内容并去除开头的所有&lt;br&gt;标签</span>      <span class="hljs-keyword">let</span> afterThinkContent = (thinkBuffer.value.substring(thinkBuffer.value.indexOf(<span class="hljs-string">&quot;&lt;/think&gt;&quot;</span>) + <span class="hljs-number">8</span>)).replace(<span class="hljs-regexp">/^(?:&lt;br&gt;)+/</span>, <span class="hljs-string">&#x27;&#x27;</span>);      fullResponseContent.value += afterThinkContent;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;LOG: fullResponseContent:&quot;</span>, fullResponseContent.value);      handleFullResponseContent();      <span class="hljs-comment">// 这里需要把thinkBuffer.value进行截取，去除&lt;/think&gt; 后面的内容</span>      <span class="hljs-keyword">let</span> finalThinkPart = message.substring(<span class="hljs-number">0</span>, message.indexOf(<span class="hljs-string">&quot;&lt;/think&gt;&quot;</span>));      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;LOG: content:&quot;</span>, finalThinkPart);      thinkContent.value += finalThinkPart;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;LOG: thinkContent:&quot;</span>, thinkContent.value);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isCollectingThink.value) &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;LOG: message:&quot;</span>, message);      thinkContent.value += message;    &#125;  &#125;&#125;</code></pre></div><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>经过这样的拆分和对功能点的细节描述给到AI，AI可以完美的处理并封装好方法，基本可以直接拿来用，且大大缩短了自己写代码来调试和AI干扰了业务代码后进行验证的时间，这一点经过多次尝试，非常有效~</p><p>🤔 举个栗子：<br>原来让AI改代码就像让一个新来的厨房学徒直接上手炒菜——ta分不清哪些是秘制调料（业务逻辑），哪些是普通配菜（数据处理），结果把你的招牌菜改成了”黑暗料理”。</p><p>现在只让他做食材预处理：<br>✅ 土豆切丝<br>✅ 青菜摘叶<br>✅ 肉片腌制</p><p>至于火候把控和调料搭配（业务逻辑），牢牢掌握在自己手里！他只需要保证切好的土豆丝粗细均匀，剩下的交给你这个大厨来掌勺 🧑‍🍳</p><p>总结来说，针对不熟悉的项目，且在保证原有功能的基础之上，这样做会很省心省力，且按时的完成了任务。</p>]]></content>
    
    
    <categories>
      
      <category>AI相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Prompt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端项目选型及搭建：React技术栈</title>
    <link href="/2025/01/04/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E9%80%89%E5%9E%8B%E5%8F%8A%E6%90%AD%E5%BB%BA%EF%BC%9AReact%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <url>/2025/01/04/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E9%80%89%E5%9E%8B%E5%8F%8A%E6%90%AD%E5%BB%BA%EF%BC%9AReact%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么推荐用React搭建项目"><a href="#为什么推荐用React搭建项目" class="headerlink" title="为什么推荐用React搭建项目"></a>为什么推荐用React搭建项目</h2><h3 id="各个主流框架的使用情况"><a href="#各个主流框架的使用情况" class="headerlink" title="各个主流框架的使用情况"></a>各个主流框架的使用情况</h3><h4 id="1-npm下载量"><a href="#1-npm下载量" class="headerlink" title="1. npm下载量"></a>1. npm下载量</h4><blockquote><p>数据来源：<a href="https://npmtrends.com/@angular/core-vs-jquery-vs-react-vs-svelte-vs-vue">npm trends 框架对比数据</a></p></blockquote><p>通过下面这张图可以看出react的全球下载量在最近一年的下载量稳居第一；<br><img src="/img/blog/Js_Research/1.PNG"></p><p>GitHub上的一些数据也可以通过对比明显看出，无论是Star数还是开源库的维护频率都是非常高的；</p><table><thead><tr><th>框架</th><th>Stars</th><th>Issues</th><th>最后一次更新（2025.1.05）</th><th>总开源时长</th></tr></thead><tbody><tr><td>React</td><td>231,030</td><td>933</td><td>1个月前</td><td>13年</td></tr><tr><td>Vue</td><td>48,294</td><td>920</td><td>2个月前</td><td>11年</td></tr><tr><td>Angular</td><td>96,575</td><td>1740</td><td>17天前</td><td>9年</td></tr><tr><td>jQuery</td><td>59,282</td><td>91</td><td>1年前</td><td>14年</td></tr><tr><td>Svelte</td><td>80750</td><td>803</td><td>2天前</td><td>8年</td></tr></tbody></table><h4 id="2-Stack-Overflow-标签数量排行"><a href="#2-Stack-Overflow-标签数量排行" class="headerlink" title="2. Stack Overflow 标签数量排行"></a>2. Stack Overflow 标签数量排行</h4><blockquote><p>数据来源：<a href="https://trends.stackoverflow.co/?tags=reactjs,vue.js,angular,svelte,jquery">Stack Overflow 标签数量排行</a></p></blockquote><p>通过该标签排行可以看出在Stack Overflow社区里React目前是最受欢迎的现代前端框架、社区活跃度最高、技术问题解决资源最丰富；<br><img src="/img/blog/Js_Research/2.PNG"></p><h4 id="3-JS现状调查"><a href="#3-JS现状调查" class="headerlink" title="3. JS现状调查"></a>3. JS现状调查</h4><blockquote><p>数据来源：<a href="https://2024.stateofjs.com/en-US/libraries/front-end-frameworks/">JS现状调查</a></p></blockquote><p>通过该图可以看到目前主流js库的【使用量】中，react一直是多年来排名最高的，但近几年前端发展迅速有了新的js库，后面几个tag里的【关注量】和【留存量】，react并没有始终排在第一，但也在前几名里；<br><img src="/img/blog/Js_Research/3.PNG"></p><h4 id="4-百度搜索指数"><a href="#4-百度搜索指数" class="headerlink" title="4. 百度搜索指数"></a>4. 百度搜索指数</h4><blockquote><p>数据来源：<a href="https://index.baidu.com/v2/main/index.html#/trend/react?words=react,vue.js,angular,jquery,">百度搜索指数</a></p></blockquote><p>国内开发在不借助魔法网络的情况下基本依赖百度搜索，以下是几个主流框架的搜索指数：<br><img src="/img/blog/Js_Research/4.PNG"></p><h3 id="综合搜索及AI总结："><a href="#综合搜索及AI总结：" class="headerlink" title="综合搜索及AI总结："></a>综合搜索及AI总结：</h3><table><thead><tr><th>评估维度</th><th>React</th><th>Vue</th><th>Angular</th></tr></thead><tbody><tr><td>学习曲线</td><td>中等</td><td>较低</td><td>较陡</td></tr><tr><td>生态系统</td><td>非常成熟（国内外）</td><td>成熟,但相对国内使用者较多</td><td>成熟，国外使用较多</td></tr><tr><td>灵活性</td><td>高</td><td>中等</td><td>中等</td></tr><tr><td>社区活跃度</td><td>极高</td><td>高</td><td>中等</td></tr><tr><td>工程化支持</td><td>完善</td><td>完善</td><td>完善</td></tr></tbody></table><h3 id="哪些常见国内应用是基于React开发的？"><a href="#哪些常见国内应用是基于React开发的？" class="headerlink" title="哪些常见国内应用是基于React开发的？"></a>哪些常见国内应用是基于React开发的？</h3><p>云效、飞书、蚂蚁数据可视化、飞猪、虾米音乐、斗鱼直播、知乎、豆瓣、美团外卖H5、石墨文档、36氪、优酷、携程、滴滴官网、今日头条…</p><h3 id="哪些AI产品是基于React开发的？"><a href="#哪些AI产品是基于React开发的？" class="headerlink" title="哪些AI产品是基于React开发的？"></a>哪些AI产品是基于React开发的？</h3><p>AI应用：Openai、讯飞星火、通一千问、Deepseek…</p><p>AI应用开发平台：Coze、Dify、Lobechat…</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>综上所述，React 凭借其组件化开发、虚拟 DOM、单向数据流等优势，以及庞大的生态系统（组件库、UI库）和活跃的社区，成为构建现代 Web 应用的理想选择。众多知名 AI 应用和平台的成功案例也证明了 React 的可靠性和高效性。因此，推荐使用 React 作为项目开发的首选框架。</p><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><p>Node &gt;= 18+ (本地版本：18.20.4)</p><h3 id="路由、工具、组件库"><a href="#路由、工具、组件库" class="headerlink" title="路由、工具、组件库"></a>路由、工具、组件库</h3><table><thead><tr><th>类别</th><th>依赖包</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>核心框架</td><td>React</td><td>^18.3.1</td><td>用于构建用户界面的 JavaScript 库</td></tr><tr><td></td><td>TypeScript</td><td>^5.4.5</td><td>JavaScript 的超集，添加了类型系统</td></tr><tr><td></td><td>Vite</td><td>^5.2.11</td><td>现代化的前端构建工具，开发体验好，构建速度快</td></tr><tr><td></td><td>@vitejs/plugin-react-swc</td><td>^3.7.0</td><td>基于 SWC 的 React 插件，提供更快的编译速度</td></tr><tr><td>状态管理与路由</td><td>Zustand</td><td>^4.5.2</td><td>轻量级状态管理库，使用简单，支持 Hooks</td></tr><tr><td></td><td>React Router</td><td>^6.23.1</td><td>React 官方路由方案</td></tr><tr><td></td><td>Ahooks</td><td>^3.8.4</td><td>阿里出品的 React Hooks 库，提供丰富的自定义 Hooks</td></tr><tr><td>UI组件库</td><td>Ant Design</td><td>^5.22.7</td><td>企业级 UI 组件库，提供丰富的组件和主题定制</td></tr><tr><td></td><td>@iconify/react</td><td>^4.1.1</td><td>图标库，支持多个图标集合</td></tr><tr><td></td><td>@livekit/components-react</td><td>^2.6.7</td><td>LiveKit 的 React 组件库，用于实时音视频</td></tr><tr><td></td><td>@livekit/components-styles</td><td>^1.1.4</td><td>LiveKit 组件样式库</td></tr><tr><td>工具库</td><td>Axios</td><td>^1.7.2</td><td>基于 Promise 的 HTTP 客户端</td></tr><tr><td></td><td>Dayjs</td><td>^1.11.11</td><td>轻量级日期处理库，支持链式操作</td></tr><tr><td></td><td>Lodash-unified</td><td>^1.0.3</td><td>实用工具库，提供数组、对象等操作方法</td></tr><tr><td></td><td>Qs</td><td>^6.13.0</td><td>URL 参数解析和字符串化工具</td></tr><tr><td></td><td>axios-mock-adapter</td><td>^1.22.0</td><td>Axios 的模拟请求适配器，用于开发调试</td></tr></tbody></table><h3 id="整体项目结构"><a href="#整体项目结构" class="headerlink" title="整体项目结构"></a>整体项目结构</h3><div class="code-wrapper"><pre><code class="hljs plaintext">├── src/ # 源代码目录├── public/ # 静态资源目录├── node_modules/ # 依赖包目录├── index.html # HTML 入口文件├── vite.config.ts # Vite 配置文件├── package.json # 项目配置和依赖管理├── tsconfig.json # TypeScript 配置│├── 环境配置文件│ ├── .env.dev # 开发环境配置│ └── .env.prod # 生产环境配置│├── 代码规范配置│ ├── .eslintrc.cjs # ESLint 配置│ ├── .prettierrc.cjs # Prettier 配置│ ├── .stylelintrc.cjs # StyleLint 配置│ ├── .editorconfig # 编辑器配置│ └── .commitlintrc.cjs # Git 提交规范配置│├── 忽略文件配置│ ├── .gitignore # Git 忽略文件│ ├── .eslintignore # ESLint 忽略文件│ ├── .prettierignore # Prettier 忽略文件│ └── .stylelintignore # StyleLint 忽略文件│└── 项目文档├── README.md # 项目说明文档└── LICENSE # 开源协议</code></pre></div><h3 id="源代码目录结构"><a href="#源代码目录结构" class="headerlink" title="源代码目录结构"></a>源代码目录结构</h3><div class="code-wrapper"><pre><code class="hljs plaintext">src/├── apis/ # API 接口管理│ ├── request.ts # Axios 请求封装│ └── modules/ # 按模块划分的 API│├── assets/ # 静态资源│ ├── images/ # 图片资源│ ├── icons/ # 图标资源│ └── styles/ # 全局样式│├── components/ # 全局公共组件│ ├── Layout/ # 布局组件│ ├── Button/ # 按钮组件│ └── Form/ # 表单组件│├── constants/ # 常量定义│ ├── index.ts # 公共常量│ └── routes.ts # 路由常量│├── hooks/ # 自定义 Hooks│ ├── useRequest.ts # 请求 Hook│ └── useAuth.ts # 认证 Hook│├── pages/ # 页面组件│ ├── Home/ # 首页│ ├── Login/ # 登录页│ └── User/ # 用户页面│├── router/ # 路由配置│ ├── index.tsx # 路由入口│ └── routes.tsx # 路由定义│├── store/ # 状态管理│ ├── index.ts # Store 入口│ └── modules/ # 状态模块│├── types/ # TypeScript 类型定义│ ├── global.d.ts # 全局类型│ └── api.d.ts # API 相关类型│├── utils/ # 工具函数│ ├── storage.ts # 存储工具│ └── validator.ts # 验证工具│├── App.tsx # 应用根组件├── main.tsx # 应用入口└── env.d.ts # 环境变量类型声明</code></pre></div><h3 id="项目命令"><a href="#项目命令" class="headerlink" title="项目命令"></a>项目命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>npm run dev</code></td><td>启动开发服务器，默认端口 8000</td></tr><tr><td><code>npm run build</code></td><td>构建生产环境代码</td></tr><tr><td><code>npm run analyzer</code></td><td>构建并分析打包结果</td></tr><tr><td><code>npm run serve</code></td><td>预览生产环境构建</td></tr><tr><td><code>npm run lint:js</code></td><td>JavaScript/TypeScript 代码检查</td></tr><tr><td><code>npm run lint:css</code></td><td>CSS 代码检查</td></tr><tr><td><code>npm run check</code></td><td>TypeScript 类型检查</td></tr><tr><td><code>npm run commit</code></td><td>规范化的 Git 提交</td></tr></tbody></table><h3 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h3><ul><li>使用 ESLint 进行代码检查</li><li>使用 Prettier 进行代码格式化</li><li>使用 StyleLint 进行样式检查</li><li>使用 Commitlint 进行提交信息检查</li><li>遵循 TypeScript 开发规范</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STAR形式分享AI编程-1</title>
    <link href="/2024/11/28/STAR%E5%BD%A2%E5%BC%8F%E5%88%86%E4%BA%ABAI%E7%BC%96%E7%A8%8B1/"/>
    <url>/2024/11/28/STAR%E5%BD%A2%E5%BC%8F%E5%88%86%E4%BA%ABAI%E7%BC%96%E7%A8%8B1/</url>
    
    <content type="html"><![CDATA[<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p><strong>编码工具：</strong> Cursor<br><strong>AI模型：</strong> claude-3.5-sonnet</p><h2 id="实践描述"><a href="#实践描述" class="headerlink" title="实践描述"></a>实践描述</h2><h3 id="Situation-amp-Task"><a href="#Situation-amp-Task" class="headerlink" title="Situation &amp; Task"></a>Situation &amp; Task</h3><p>在开发某个统计功能时，需要根据后端返回的数据结构计算不同管理者类型的分布情况。传统的纯文字prompt方式往往需要多轮对话才能获得准确的代码实现。</p><p>为了提升效率，我们采用了以下方案：</p><ol><li>设计一个清晰的伪代码prompt，包含：<ul><li>完整的数据结构示例</li><li>详细的计算逻辑规则</li><li>预期的返回值格式</li></ul></li><li>利用该prompt生成TypeScript代码，并封装为独立方法</li></ol><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>具体实施步骤如下：</p><ol><li><p>编写伪代码构建清晰化的prompt：</p><ul><li>管理者类型的完整定义</li><li>后端返回的JSON数据结构示例</li><li>使用if-else形式描述的三层判断逻辑</li><li>清晰的返回值数据结构</li></ul></li><li><p>生成<code>CalculationManagerType.ts</code>文件，包含：</p><ul><li>类型定义和函数</li><li>辅助函数的模块化设计</li><li>主计算函数<code>calculateManagerDistribution</code></li><li>完整的TypeScript类型注解和注释</li></ul></li></ol><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><h4 id="技术成果"><a href="#技术成果" class="headerlink" title="技术成果"></a>技术成果</h4><ul><li>生成的代码无需过多修改即可投入使用</li><li>代码结构清晰，包含完整的类型定义和注释</li><li>实现了业务逻辑要求</li></ul><h4 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h4><ul><li>相比纯文字prompt，减少了多轮对话的需求</li><li>显著提高了代码生成的准确性</li><li>缩短了从需求到实现的时间：1h → 10min</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ul><li>证实了结构化伪代码prompt的优势</li><li>为类似场景总结了可复用的prompt写法</li></ul><h2 id="以下是完成此任务的详细prompt和AI生成的代码"><a href="#以下是完成此任务的详细prompt和AI生成的代码" class="headerlink" title="以下是完成此任务的详细prompt和AI生成的代码"></a>以下是完成此任务的详细prompt和AI生成的代码</h2><p>整理的伪代码的prompt如下：</p><div class="code-wrapper"><pre><code class="hljs prolog">以下是管理者类型分布的逻辑：产品制定的管理者类型：探索方向型，驱动增长型，强化执行型，塑造环境型，待分化型后端返回的数据结构如下：“totalPeople”：<span class="hljs-number">4</span>，<span class="hljs-string">&quot;assessmentGroupReportCpaTalentDistributionVO&quot;</span>: [&#123;<span class="hljs-string">&quot;typeName&quot;</span>: <span class="hljs-string">&quot;探索方向型&quot;</span>,<span class="hljs-string">&quot;definition&quot;</span>: <span class="hljs-string">&quot;一段文本一段文本一段文本​&quot;</span>,<span class="hljs-string">&quot;exerciseOpportunity&quot;</span>: <span class="hljs-string">&quot;一段文本一段文本一段文本&quot;</span>,<span class="hljs-string">&quot;cpaTalentDistributionTypeCode&quot;</span>: <span class="hljs-string">&quot;exploratoryDirection&quot;</span>,<span class="hljs-string">&quot;peopleList&quot;</span>: []&#125;,&#123;<span class="hljs-string">&quot;typeName&quot;</span>: <span class="hljs-string">&quot;驱动增长型&quot;</span>,<span class="hljs-string">&quot;definition&quot;</span>: <span class="hljs-string">&quot;作为业务战将，帮助组织实现业务增长​&quot;</span>,<span class="hljs-string">&quot;exerciseOpportunity&quot;</span>: <span class="hljs-string">&quot;一段文本一段文本一段文本&quot;</span>,<span class="hljs-string">&quot;cpaTalentDistributionTypeCode&quot;</span>: <span class="hljs-string">&quot;growthDriven&quot;</span>,<span class="hljs-string">&quot;peopleList&quot;</span>: [<span class="hljs-string">&quot;用户26&quot;</span>]&#125;,&#123;<span class="hljs-string">&quot;typeName&quot;</span>: <span class="hljs-string">&quot;强化执行型&quot;</span>,<span class="hljs-string">&quot;definition&quot;</span>: <span class="hljs-string">&quot;一段文本一段文本一段文本​&quot;</span>,<span class="hljs-string">&quot;exerciseOpportunity&quot;</span>: <span class="hljs-string">&quot;一段文本一段文本一段文本一段文本&quot;</span>,<span class="hljs-string">&quot;cpaTalentDistributionTypeCode&quot;</span>: <span class="hljs-string">&quot;executionEnhancer&quot;</span>,<span class="hljs-string">&quot;peopleList&quot;</span>: [<span class="hljs-string">&quot;用户24&quot;</span>,<span class="hljs-string">&quot;用户27&quot;</span>]&#125;,&#123;<span class="hljs-string">&quot;typeName&quot;</span>: <span class="hljs-string">&quot;塑造环境型&quot;</span>,<span class="hljs-string">&quot;definition&quot;</span>: <span class="hljs-string">&quot;一段文本一段文本一段文本&quot;</span>,<span class="hljs-string">&quot;exerciseOpportunity&quot;</span>: <span class="hljs-string">&quot;一段文本一段文本一段文本一段文本&quot;</span>,<span class="hljs-string">&quot;cpaTalentDistributionTypeCode&quot;</span>: <span class="hljs-string">&quot;environmentShaper&quot;</span>,<span class="hljs-string">&quot;peopleList&quot;</span>: [<span class="hljs-string">&quot;用户25&quot;</span>]&#125;,&#123;<span class="hljs-string">&quot;typeName&quot;</span>: <span class="hljs-string">&quot;待分化型&quot;</span>,<span class="hljs-string">&quot;definition&quot;</span>: <span class="hljs-string">&quot;一段文本一段文本一段文本&quot;</span>,<span class="hljs-string">&quot;exerciseOpportunity&quot;</span>: <span class="hljs-string">&quot;一段文本一段文本一段文本一段文本&quot;</span>,<span class="hljs-string">&quot;cpaTalentDistributionTypeCode&quot;</span>: <span class="hljs-string">&quot;pendingDifferentiation&quot;</span>,<span class="hljs-string">&quot;peopleList&quot;</span>: []&#125;]人数占比计算逻辑：if (条件 <span class="hljs-number">1</span>：待分化型的人数最高)：&#123;return &#123; 待分化型人数最高：true，highList:[], lowList:[] &#125;&#125;else if( 条件<span class="hljs-number">2</span> ：当非待分化型的四种类型的人数相同 )&#123;return &#123;  待分化型占比最高：false，highList:[], lowList:[] &#125;&#125;else&#123;highList = [找出非待分化型人数最多的那个管理者类型对象，并列的也一起放到这个数组里]lowList: = [找出非待分化型人数最少的那个管理者类型对象，并列的也一起放到这个数组里]return &#123; 待分化型人数最高：false，highList:highList，lowList:lowList &#125;&#125;根据上面的逻辑和数据返回结构生成一个方法来计算出返回值</code></pre></div><p>生成的代码CalculationManagerType.ts：</p><p>可以看到ai直接会把需要定义的数据返回类型和计算逻辑完全按照伪代码prompt里的要求去生成，并且下面这段calculateManagerDistribution 的函数代码是完全没有二次修改的直接可以使用的：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@fileoverview </span>管理者类型分布计算工具</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> &#123; ManagerTypeVO, DistributionResult &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../data&#x27;</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@function <span class="hljs-variable">getPendingDifferentiationType</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@description </span>从列表中获取待分化类型</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> getPendingDifferentiationType = (types: ManagerTypeVO[]): <span class="hljs-function"><span class="hljs-params">ManagerTypeVO</span> =&gt;</span> &#123;<span class="hljs-keyword">return</span> types.find(<span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> type.cpaTalentDistributionTypeCode === <span class="hljs-string">&#x27;pendingDifferentiation&#x27;</span>)!&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@function <span class="hljs-variable">getNonPendingTypes</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@description </span>获取除待分化类型外的所有类型</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> getNonPendingTypes = (types: ManagerTypeVO[]): ManagerTypeVO[] =&gt; &#123;<span class="hljs-keyword">return</span> types.filter(<span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> type.cpaTalentDistributionTypeCode !== <span class="hljs-string">&#x27;pendingDifferentiation&#x27;</span>)&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@function <span class="hljs-variable">findExtremeTypes</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@description </span>找出人数最多和最少的类型</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> findExtremeTypes = (types: ManagerTypeVO[]): &#123; <span class="hljs-attr">highList</span>: ManagerTypeVO[]; lowList: ManagerTypeVO[] &#125; =&gt; &#123;<span class="hljs-keyword">const</span> counts = types.map(<span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> type.peopleList.length)<span class="hljs-keyword">const</span> maxCount = <span class="hljs-built_in">Math</span>.max(...counts)<span class="hljs-keyword">const</span> minCount = <span class="hljs-built_in">Math</span>.min(...counts)<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">highList</span>: types.filter(<span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> type.peopleList.length === maxCount),<span class="hljs-attr">lowList</span>: types.filter(<span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> type.peopleList.length === minCount)&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@function <span class="hljs-variable">calculateManagerDistribution</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@description </span>计算管理者类型的分布情况</span><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>types 管理者类型数据数组</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>分布计算结果</span><span class="hljs-comment"> */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> calculateManagerDistribution = (types: ManagerTypeVO[]): <span class="hljs-function"><span class="hljs-params">DistributionResult</span> =&gt;</span> &#123;<span class="hljs-keyword">const</span> pendingType = getPendingDifferentiationType(types)<span class="hljs-keyword">const</span> nonPendingTypes = getNonPendingTypes(types)<span class="hljs-keyword">const</span> pendingCount = pendingType.peopleList.length<span class="hljs-comment">// 条件1：待分化类型人数最多</span><span class="hljs-keyword">const</span> nonPendingCounts = nonPendingTypes.map(<span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> type.peopleList.length)<span class="hljs-keyword">const</span> maxNonPendingCount = <span class="hljs-built_in">Math</span>.max(...nonPendingCounts)<span class="hljs-keyword">if</span> (pendingCount &gt; maxNonPendingCount) &#123;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">isPendingDifferentiationHighest</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">highList</span>: [],<span class="hljs-attr">lowList</span>: []&#125;&#125;<span class="hljs-comment">// 条件2：所有非待分化类型人数相等</span><span class="hljs-keyword">const</span> allNonPendingEqual = nonPendingCounts.every(<span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> count === nonPendingCounts[<span class="hljs-number">0</span>])<span class="hljs-keyword">if</span> (allNonPendingEqual) &#123;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">isPendingDifferentiationHighest</span>: <span class="hljs-literal">false</span>,<span class="hljs-attr">highList</span>: [],<span class="hljs-attr">lowList</span>: []&#125;&#125;<span class="hljs-comment">// 条件3：找出非待分化类型中人数最多和最少的组</span><span class="hljs-keyword">const</span> &#123; highList, lowList &#125; = findExtremeTypes(nonPendingTypes)<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">isPendingDifferentiationHighest</span>: <span class="hljs-literal">false</span>,highList,lowList&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>AI相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Prompt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端页面媒体资源防下载</title>
    <link href="/2024/07/04/%E5%AA%92%E4%BD%93%E8%B5%84%E6%BA%90%E9%98%B2%E4%B8%8B%E8%BD%BD/"/>
    <url>/2024/07/04/%E5%AA%92%E4%BD%93%E8%B5%84%E6%BA%90%E9%98%B2%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前端进行展示图片、视频、pdf等媒体资源时，对于私有化知识的资源需要做一个保护机制，即防止用户下载留存。</p><p>防范维度：</p><ul><li><p>无任何web技术的人群：大众用户</p></li><li><p>懂web技术的人群</p></li></ul><p>此文档记录的技术方向主要是针对第一类：大众用户</p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>针对视频，可使用现成js插件来实现防下载功能，推荐以下两个插件：</p><ul><li><p>video.js GitHub 37.5k；Demo地址：<br><a href="https://videojs.com/advanced/?video=disneys-oceans">https://videojs.com/advanced/?video=disneys-oceans</a></p></li><li><p>plyr  Github 26k；Demo地址：<a href="https://plyr.io/">https://plyr.io/</a> </p></li></ul><p>video-js使用示例：</p><div class="code-wrapper"><pre><code class="hljs javascript">&lt;link href=<span class="hljs-string">&quot;https://vjs.zencdn.net/7.11.4/video-js.css&quot;</span> rel=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://vjs.zencdn.net/7.11.4/video.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;my-video&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;video-js&quot;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">preload</span>=<span class="hljs-string">&quot;auto&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;640&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;264&quot;</span> <span class="hljs-attr">poster</span>=<span class="hljs-string">&quot;MY_VIDEO_POSTER.jpg&quot;</span> <span class="hljs-attr">data-setup</span>=<span class="hljs-string">&quot;&#123;&#125;&quot;</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;MY_VIDEO.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;vjs-no-js&quot;</span>&gt;</span></span><span class="xml">    To view this video please enable JavaScript, and consider upgrading to a web browser that</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://videojs.com/html5-video-support/&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>supports HTML5 video<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span></span><span class="xml"></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><span class="javascript"><span class="xml">  <span class="hljs-keyword">var</span> player = videojs(<span class="hljs-string">&#x27;my-video&#x27;</span>);</span></span><span class="javascript"><span class="xml">  player.ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><span class="javascript"><span class="xml">    <span class="hljs-comment">// 禁用右键菜单</span></span></span><span class="javascript"><span class="xml">    player.el().oncontextmenu = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;;</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">    <span class="hljs-comment">// 隐藏下载按钮</span></span></span><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> controlBar = player.getChild(<span class="hljs-string">&#x27;controlBar&#x27;</span>);</span></span><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> fullscreenToggle = controlBar.getChild(<span class="hljs-string">&#x27;fullscreenToggle&#x27;</span>);</span></span><span class="javascript"><span class="xml">    <span class="hljs-keyword">if</span> (fullscreenToggle) &#123;</span></span><span class="javascript"><span class="xml">      fullscreenToggle.hide();</span></span><span class="javascript"><span class="xml">    &#125;</span></span><span class="javascript"><span class="xml">  &#125;);</span></span><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><p>ply使用示例:</p><div class="code-wrapper"><pre><code class="hljs javascript">&lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;https://cdn.plyr.io/3.6.8/plyr.css&quot;</span> /&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.plyr.io/3.6.8/plyr.polyfilled.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;player&quot;</span> <span class="hljs-attr">playsinline</span> <span class="hljs-attr">controls</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;MY_VIDEO.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span> /&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><span class="javascript"><span class="xml">  <span class="hljs-keyword">const</span> player = <span class="hljs-keyword">new</span> Plyr(<span class="hljs-string">&#x27;#player&#x27;</span>, &#123;</span></span><span class="javascript"><span class="xml">    <span class="hljs-attr">controls</span>: [<span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-string">&#x27;progress&#x27;</span>, <span class="hljs-string">&#x27;current-time&#x27;</span>, <span class="hljs-string">&#x27;mute&#x27;</span>, <span class="hljs-string">&#x27;volume&#x27;</span>, <span class="hljs-string">&#x27;fullscreen&#x27;</span>]</span></span><span class="javascript"><span class="xml">  &#125;);</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">  <span class="hljs-comment">// 禁用右键菜单</span></span></span><span class="javascript"><span class="xml">  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;player&#x27;</span>).oncontextmenu = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;;</span></span><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><p>如果使用浏览器打开pdf会有浏览器自带的下载功能，这里推荐使用以下插件来展示pdf：</p><p>pdf.js GitHub 47.1k；Demo地址：<a href="https://mozilla.github.io/pdf.js/examples/index.html#interactive-examples">https://mozilla.github.io/pdf.js/examples/index.html#interactive-examples</a></p><p>使用效果，在矩形区域显示一个pdf文件的内容：</p><p><img src="/img/blog/js/07.png" alt="img.png"></p><p><strong>但是：在矩形区域上方点击鼠标右键会出现一个【图片另存为】，这时候需要使用下方和【图片】一样的设置</strong></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>利用css设置禁止选中和js中的禁止右键：<br>css:</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;    -webkit-user-select: none; <span class="hljs-comment">/* Safari */</span>    -moz-user-select: none;    <span class="hljs-comment">/* Firefox */</span>    -ms-user-select: none;     <span class="hljs-comment">/* IE10+/Edge */</span>    user-select: none;         <span class="hljs-comment">/* Standard */</span>    <span class="hljs-attribute">pointer-events</span>: none;&#125;</code></pre></div><p>js：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//防止右键下载图片</span><span class="hljs-built_in">document</span>.oncontextmenu = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">// 或者</span>&lt;div id=<span class="hljs-string">&quot;myElement&quot;</span> oncontextmenu=<span class="hljs-string">&quot;return false;&quot;</span>&gt;...&lt;/div&gt;</code></pre></div><p>vue中的写法示例：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;img ref=&quot;myImage&quot; src=&quot;your-image.jpg&quot; /&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  mounted() &#123;    this.$refs.myImage.oncontextmenu = function(event) &#123;      event.preventDefault();      return false;    &#125;;  &#125;&#125;&lt;/script&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端记录页面停留时长</title>
    <link href="/2024/07/04/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%81%9C%E7%95%99%E6%97%B6%E9%95%BF/"/>
    <url>/2024/07/04/%E5%89%8D%E7%AB%AF%E8%AE%B0%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%81%9C%E7%95%99%E6%97%B6%E9%95%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="主要逻辑"><a href="#主要逻辑" class="headerlink" title="主要逻辑"></a>主要逻辑</h2><div class="code-wrapper"><pre><code class="hljs text">1.进入页面开始计时 2.如果浏览器tab切换，停止计时，重新切换回当前页面，继续累加计时 3.如果浏览器缩小或被遮盖，停止计时，重新切换回当前页面，继续累加计时 4.如果浏览器刷新，重新计时5.如果浏览器关闭，停止计时</code></pre></div><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>基于以上逻辑，使用以下代码进行实现：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> startTime;   <span class="hljs-keyword">let</span> elapsedTime = <span class="hljs-number">0</span>;   <span class="hljs-keyword">let</span> timerInterval;   <span class="hljs-keyword">let</span> isTimerRunning = <span class="hljs-literal">false</span>;   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startTimer</span>(<span class="hljs-params"></span>) </span>&#123;       <span class="hljs-keyword">if</span> (!isTimerRunning) &#123;           startTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() / <span class="hljs-number">1000</span> - elapsedTime;           timerInterval = <span class="hljs-built_in">setInterval</span>(updateTimer, <span class="hljs-number">1000</span>);           isTimerRunning = <span class="hljs-literal">true</span>;       &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopTimer</span>(<span class="hljs-params"></span>) </span>&#123;       <span class="hljs-keyword">if</span> (isTimerRunning) &#123;           <span class="hljs-built_in">clearInterval</span>(timerInterval);           elapsedTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() / <span class="hljs-number">1000</span> - startTime;           isTimerRunning = <span class="hljs-literal">false</span>;       &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateTimer</span>(<span class="hljs-params"></span>) </span>&#123;       <span class="hljs-keyword">const</span> currentTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() / <span class="hljs-number">1000</span>;       elapsedTime = currentTime - startTime;       displayTime(elapsedTime);   &#125;   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayTime</span>(<span class="hljs-params">time</span>) </span>&#123;       <span class="hljs-keyword">const</span> timeString = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Math</span>.floor(time)&#125;</span>秒`</span>;       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeString&#x27;</span>, timeString);   &#125;   <span class="hljs-comment">// 监听页面可见性变化</span>   <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;visibilitychange&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.hidden) &#123;           stopTimer();       &#125; <span class="hljs-keyword">else</span> &#123;           startTimer();       &#125;   &#125;);   <span class="hljs-comment">// 页面加载完成后开始计时</span>   <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, startTimer);   <span class="hljs-comment">// 监听页面关闭或刷新</span>   <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;beforeunload&#x27;</span>, stopTimer);</code></pre></div><p>经过测试，发现一个特殊情况：当缩小浏览器或者切换tab到其他页面（其他电脑应用）后，经过十几分钟（或者更长时间）后再重新回到当前计时页面，以上代码会出现一个时间偏差，例如原本离开的时间是6秒，再回来应该从第7秒开始累加，但回来后会从10秒或者20秒开始累加；</p><p>原因如下：</p><blockquote><p>js执行的任务队列分别有微任务和宏任务两种，而setInterval 和setTimeout 属于宏任务，在浏览器页面的执行机制里，当页面失焦被置于后台时，会因为浏览器的性能机制导致被延迟执行，具体延迟执行时长是不确定的（取决于当前页面的代码逻辑和浏览器本身的调度）：</p></blockquote><p><img src="/img/blog/js/03.png" alt="img.png"></p><p><img src="/img/blog/js/04.png" alt="img.png"></p><p>根据以上的情况和原因说明，不使用定时器，改用requestAnimationFrame 方法来实现更精准的时长计算</p><p><strong>为什么使用requestAnimationFrame 可以解决时长精准度的问题？</strong></p><p>可以概括为：requestAnimationFrame与浏览器的渲染周期同步，这意味着它以与浏览器的渲染帧速率一致的一致速率（通常为每秒 60 次）调用。这种同步有助于减少时间测量的差异。且当浏览器被缩小，或切换tab，该事件会被暂停调用，重新激活页面时会再次以每秒60次的频率调用</p><p>官方说明：<br><img src="/img/blog/js/05.png" alt="img.png"></p><p>以下是修改之后的代码：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> pauseTime = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> accumulatedTime = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> timerId = <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> isRunning = <span class="hljs-literal">false</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startTimer</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span> (!isRunning) &#123;        startTime = performance.now();        isRunning = <span class="hljs-literal">true</span>;        requestAnimationFrame(updateTimer);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateTimer</span>(<span class="hljs-params">timestamp</span>) </span>&#123;    <span class="hljs-keyword">if</span> (isRunning) &#123;        <span class="hljs-keyword">const</span> currentTime = timestamp;        <span class="hljs-keyword">const</span> elapsed = <span class="hljs-built_in">Math</span>.floor(currentTime - startTime + accumulatedTime);        <span class="hljs-comment">// 更新计时器的显示</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Elapsed time: <span class="hljs-subst">$&#123;elapsed&#125;</span>ms:::`</span>,elapsed/<span class="hljs-number">1000</span>);        timerId = requestAnimationFrame(updateTimer);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pauseTimer</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span> (isRunning) &#123;        pauseTime = performance.now();        accumulatedTime += pauseTime - startTime;        isRunning = <span class="hljs-literal">false</span>;        cancelAnimationFrame(timerId);    &#125;&#125;<span class="hljs-comment">// 监听浏览器的 visibilitychange 事件</span><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;visibilitychange&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.visibilityState === <span class="hljs-string">&#x27;hidden&#x27;</span>) &#123;        pauseTimer();    &#125; <span class="hljs-keyword">else</span> &#123;        startTimer();    &#125;&#125;);<span class="hljs-comment">// 初始化计时器</span>startTimer();</code></pre></div><p>在html里引用以上修改后的代码，未出现离开时间较长时间偏差的问题，特此记录。</p><p>requestAnimationFrame的浏览器兼容性（2024/7/3）：<br><img src="/img/blog/js/06.png" alt="img.png"></p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><blockquote><p>动画演示js的EventLoop：<a href="https://juejin.cn/post/6969028296893792286">https://juejin.cn/post/6969028296893792286</a></p><p>requestAnimationFrame的使用场景举例：<a href="https://juejin.cn/post/7190728064458817591#heading-1">https://juejin.cn/post/7190728064458817591#heading-1</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cordova框架搭建及打包尝试（过程记录）</title>
    <link href="/2024/06/30/Cordova%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%89%93%E5%8C%85%E5%B0%9D%E8%AF%95/"/>
    <url>/2024/06/30/Cordova%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%89%93%E5%8C%85%E5%B0%9D%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="安装-amp-创建项目"><a href="#安装-amp-创建项目" class="headerlink" title="安装&amp;创建项目"></a>安装&amp;创建项目</h3><p>全局安装cordova</p><div class="code-wrapper"><pre><code class="hljs text">npm install -g cordova</code></pre></div><p>创建项目名为HelloWorld的命令，com.example.hello按照文档说法需要改为实际项目域名：</p><div class="code-wrapper"><pre><code class="hljs text">cordova create hello com.example.hello HelloWorld</code></pre></div><p>添加android环境（这次是在Windows上尝试，所以只能配置android环境；(打ios需要mac系统的xcode，没有实践记录)）：</p><div class="code-wrapper"><pre><code class="hljs text">cordova platform add android</code></pre></div><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>android平台的环境配置：</p><div class="code-wrapper"><pre><code class="hljs text">安装jdk17版本；gradle7.6-all版本；Android sdk安装最高版本和最低版本即可；</code></pre></div><p>以下配置根据实际安装位置，变量名如下：</p><div class="code-wrapper"><pre><code class="hljs text">ANDROID_HOME：E:\AndroidSDK\SDKANDROID_SDK_ROOT：E:\AndroidSDK\SDKGRADLE_HOME：E:\AndroidSDK\gradle-7.6-all\gradle-7.6JAVA_HOME：C:\Program Files\Java\jdk-17PATH下的环境变量配置：%ANDROID_HOME%\platform-tools%ANDROID_HOME%\tools%ANDROID_HOME%\tools\bin%ANDROID_HOME%\build-tools%ANDROID_HOME%\emulator%ANDROID_HOME%\cmdline-tools\latest\bin%GRADLE_HOME%\bin%JAVA_HOME%\bin</code></pre></div><p>查看对应平台的打包环境是否满足</p><div class="code-wrapper"><pre><code class="hljs text">cordova requirements</code></pre></div><p>执行不通过的话会报错，需要根据报错信息查找原因，大部分是因为环境和版本不匹配，查一下jdk和android版本的兼容版本重新安装即可；<br>下图是android环境配置正确的命令输出：<br><img src="/img/blog/cordova/1.png" alt="img.png"></p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>最后执行打包命令:</p><div class="code-wrapper"><pre><code class="hljs text">cordova build android</code></pre></div><p>等到打包结束，apk文件输出在项目下此目录：platforms\android\app\build\outputs\apk\debug<br><img src="/img/blog/cordova/2.png" alt="img.png"></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>此记录只是跑通了cordova的项目创建和打包环境配置以及打包尝试，中间因为配置兼容问题卡了一段时间，后续再测试相关api功能转换~~</p>]]></content>
    
    
    <categories>
      
      <category>Cordova</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cordova</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯云搭建WEB服务器步骤记录</title>
    <link href="/2024/04/25/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%90%AD%E5%BB%BAWEB%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%AD%A5%E9%AA%A4%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/04/25/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%90%AD%E5%BB%BAWEB%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%AD%A5%E9%AA%A4%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>新购入了一个轻量应用服务器，之前没有使用docker部署，需要再重头搭一下环境，以下是相关步骤：</p><h3 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h3><p>首先，你需要更新你的CentOS系统。在终端中，运行以下命令：</p><div class="code-wrapper"><pre><code class="hljs text">sudo yum update -y</code></pre></div><p>安装基本的依赖和工具</p><p>你可能需要一些基础的依赖和工具，如curl、wget和unzip。在终端中，运行以下命令来安装这些工具：</p><div class="code-wrapper"><pre><code class="hljs text">sudo yum install -y curl wget unzip</code></pre></div><h3 id="安装NVM"><a href="#安装NVM" class="headerlink" title="安装NVM"></a>安装NVM</h3><p>在终端中，运行以下命令来安装NVM：</p><div class="code-wrapper"><pre><code class="hljs text">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash</code></pre></div><p>查看是否安装完成</p><div class="code-wrapper"><pre><code class="hljs text">command -v nvm</code></pre></div><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>通过NVM，你可以安装任何版本的Node.js。<br>查看远程node版本，该命令会列出所有node版本，并会标注哪些是LTS版本</p><div class="code-wrapper"><pre><code class="hljs text">nvm ls-remote</code></pre></div><p>安装命令</p><div class="code-wrapper"><pre><code class="hljs text">nvm install v16.xx.xx</code></pre></div><p>然后，运行以下命令来检查Node.js是否已经成功安装：</p><div class="code-wrapper"><pre><code class="hljs text">nvm install v16.xx.xx</code></pre></div><h3 id="安装PM2"><a href="#安装PM2" class="headerlink" title="安装PM2"></a>安装PM2</h3><p>PM2 是一个Node.js应用程序的生产过程管理器。在终端中，运行以下命令来安装PM2：</p><div class="code-wrapper"><pre><code class="hljs text">npm install -g pm2</code></pre></div><p>然后，运行以下命令来检查PM2是否已经成功安装：</p><div class="code-wrapper"><pre><code class="hljs text">pm2 -v</code></pre></div><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>在终端中，运行以下命令来安装MySQL：</p><div class="code-wrapper"><pre><code class="hljs text">sudo yum install -y mysql-server</code></pre></div><p>然后，运行以下命令来启动MySQL服务：</p><div class="code-wrapper"><pre><code class="hljs text">sudo systemctl start mysqld</code></pre></div><p>运行以下命令来确保MySQL在启动时自动启动：</p><div class="code-wrapper"><pre><code class="hljs text">sudo systemctl enable mysqld</code></pre></div><p>然后，运行以下命令来检查MySQL是否已经成功安装：</p><div class="code-wrapper"><pre><code class="hljs text">mysql --version</code></pre></div><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>在终端中，运行以下命令来安装Nginx：</p><div class="code-wrapper"><pre><code class="hljs text">sudo yum install -y nginx</code></pre></div><p>然后，运行以下命令来启动Nginx服务：</p><div class="code-wrapper"><pre><code class="hljs text">sudo systemctl start nginx</code></pre></div><p>运行以下命令来确保Nginx在启动时自动启动：</p><div class="code-wrapper"><pre><code class="hljs text">sudo systemctl enable nginx</code></pre></div><p>查看nginx是否是自启动</p><div class="code-wrapper"><pre><code class="hljs text">systemctl is-enabled nginx</code></pre></div><p>然后，运行以下命令来检查Nginx是否已经成功安装</p><div class="code-wrapper"><pre><code class="hljs text">nginx -v</code></pre></div><p>修改/etc/nginx.conf 配置，同时需要开放云服务器的访问端口</p><div class="code-wrapper"><pre><code class="hljs text">server &#123;        listen       8001;                location / &#123;            root   /opt/scorm-player;            index  scormplayer.html;            try_files $uri $uri/ /index.html;        &#125;    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>腾讯云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单结构化prompt实践记录</title>
    <link href="/2024/02/02/prompt%E7%BB%93%E6%9E%84%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/02/02/prompt%E7%BB%93%E6%9E%84%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h3><p>最近半年出现很多ai平台，平时使用最多的是智谱清言，此次也是利用glm模型，通过尝试prompt来让ai完成数据提取的任务；</p><h3 id="要做的事"><a href="#要做的事" class="headerlink" title="要做的事"></a>要做的事</h3><p>将一个excel数据集中每行json数据里的userQuery的值取出来，然后再按照条件进行组装<br>即excel里的某列数据是一个json，json对象里有很多字段，原本需要手动去复制黏贴到某个位置，再进行二次组装成新的数据集</p><p>初步尝试的prompt：</p><blockquote><p>请将Excel里的第一列中70行里的json对象里面的userQuery进行组装，<br>组装规律为：<br>[领导：王浩：]<br>这个规律的结果例子 ：[领导：嗯，确实非常忙碌，但这个项目延期也会造成很严重的后果，那你有什么有什么方面是我可以帮助或者支持到你的呢？王浩：老板，要不然你把这次的W项目的策划方案交给其他人做吧。领导：嗯，这个具体怎么做，我们可以之后再再具体讨论，您刚刚说到有很多事情让你忙不开身是时间分配上的一个方面，那你还有没有别的方面是可以更好的帮助到你去按时完成这样一个计划的呢？王浩：老板，我现在确实也没有什么好办法。]</p></blockquote><p><img src="/img/blog/prompt/1.png" alt="img.png"></p><p><img src="/img/blog/prompt/2.png" alt="img.png"></p><p>首次结果：首先感觉格式不对，然后组装数据也有问题；</p><p>经过多次尝试，以下是最终的【结构化+步骤】的优化之后的prompt：</p><div class="code-wrapper"><pre><code class="hljs text"># 角色- 请你作为数据分析师，分析excel中的数据## 任务- 先读取excel中的第一列，所有有json数据的行- 取出每行json里的userQuery字段的value- 将取出的value数据进行剔除所有 &#x27;\n&#x27; 符号- 然后将剔除后的数据装到新的excel文件里（不包括原json）- 所有行的数据都转换之后，提供下载这个excel</code></pre></div><p><img src="/img/blog/prompt/3.png" alt="img.png"></p><p><img src="/img/blog/prompt/4.png" alt="img.png"></p><p>实际测试效果通过最后这种prompt，一次对话就完成了想要的效果；</p><h3 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h3><blockquote><p>通过结构化+分步指令，ai会逐步完成指令中详细步骤来实现最终效果。<br>而以最开始的那种简单描述，首先ai只能完成简单任务，如果再次通过每次的上下对话让ai去做效率很低。<br>由此可见一个需求描述准确和步骤细化的prompt在结果上会有巨大的差异。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>AI相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Prompt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nvm的安装&amp;使用以及npm和yarn的源设置</title>
    <link href="/2023/12/27/npm%E5%92%8Cyarn%E7%9A%84%E6%BA%90%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/12/27/npm%E5%92%8Cyarn%E7%9A%84%E6%BA%90%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装nvm之前需要先卸载电脑中的node版本，并清理掉缓存:</p><div class="code-wrapper"><pre><code class="hljs taggerscript">控制面板 -&gt; 卸载程序 -&gt; 卸载nodejs删除以下文件夹（如果存在的话）C:<span class="hljs-symbol">\P</span>rogram Files (x86)<span class="hljs-symbol">\N</span>odejsC:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\N</span>odejsC:<span class="hljs-symbol">\U</span>sers&#123;User&#125;<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\n</span>pmC:<span class="hljs-symbol">\U</span>sers&#123;User&#125;<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\n</span>pm-cache删除C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\用</span>户名 下的 .npmrc文件以及 .yarnrc 文件</code></pre></div><p>nvm GitHub地址：<br><a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></p><p>Windows安装包下载地址：<br><a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><p>安装完成输入命令查看nvm版本：<br><img src="/img/blog/nvm/version.png" alt="img.png"></p><p>使用<code>nvm list available</code>命令查看当前可安装版本：<br><img src="/img/blog/nvm/node_list.png" alt="img.png"></p><p>通过 <a href="https://nodejs.org/en/download/releases">https://nodejs.org/en/download/releases</a> 地址查看node的长期维护版本；</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><div class="code-wrapper"><pre><code class="hljs stylus">查看已安装版本：nvm list安装某个版本: nvm install xx<span class="hljs-selector-class">.xx</span><span class="hljs-selector-class">.xx</span>使用某个版本：nvm use xx<span class="hljs-selector-class">.xx</span>.xx</code></pre></div><p>带星号的指向为当前使用的版本：<br><img src="/img/blog/nvm/current_node.png" alt="img.png"></p><h2 id="yarn源设置"><a href="#yarn源设置" class="headerlink" title="yarn源设置"></a>yarn源设置</h2><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">// 查询源</span>yarn config get registry<span class="hljs-comment">// 更换国内源</span>yarn config set registry https:<span class="hljs-comment">//registry.npmmirror.com</span><span class="hljs-comment">// 恢复官方源</span>yarn config set registry https:<span class="hljs-comment">//registry.yarnpkg.com</span><span class="hljs-comment">// 删除注册表</span>yarn config <span class="hljs-keyword">delete</span> registry</code></pre></div><h2 id="Npm源设置"><a href="#Npm源设置" class="headerlink" title="Npm源设置"></a>Npm源设置</h2><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 查询源npm config get registry<span class="hljs-regexp">//</span> 更换国内源npm config set registry https:<span class="hljs-regexp">//</span>registry.npmmirror.com<span class="hljs-regexp">//</span> 恢复官方源npm config set registry https:<span class="hljs-regexp">//</span>registry.npmjs.org<span class="hljs-regexp">//</span> 删除注册表npm config <span class="hljs-keyword">delete</span> registry如果是一次性的使用临时源：淘宝：npm --registry https:<span class="hljs-regexp">//</span>registry.npm.taobao.org install XXX（模块名）腾讯：npm --registry http:<span class="hljs-regexp">//mi</span>rrors.cloud.tencent.com<span class="hljs-regexp">/npm/</span>  install xxx（模块名）--legacy-peer-deps 忽略npm包的依赖</code></pre></div><p>转发：<a href="https://juejin.cn/post/6971268824288985118">掘金：legacy-peer-deps到底做了些什么？</a></p>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Npm</tag>
      
      <tag>Yarn</tag>
      
      <tag>Nvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端版本更新技术方案</title>
    <link href="/2023/12/22/%E5%89%8D%E7%AB%AF%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"/>
    <url>/2023/12/22/%E5%89%8D%E7%AB%AF%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>公司的移动端和PC端，分别是angular和vue库开发的项目，每次在打包发布新版本后，用户都需要手动刷新页面获取最新代码或样式，否则发布的最新的js\css\image等资源文件得不到更新，为解决此问题对两个项目做了以下改造；</p></blockquote><h2 id="技术方案说明"><a href="#技术方案说明" class="headerlink" title="技术方案说明"></a>技术方案说明</h2><ul><li><p>项目在打包时利用插件生成一个时间戳作为版本信息，打入到一个json文件里</p></li><li><p>前端路由拦截器里监听到路由变化时，请求这个json文件，和本地的localStorage里的版本信息做对比：</p><ul><li><p>如果本地没有缓存：直接做自动刷新浏览器处理，同时把json文件里的版本信息存到缓存里</p></li><li><p>如果本地有缓存：对比是否有差异，无差异不做处理；有差异则调用浏览器的location.reload()做自动刷新处理，同时将服务器的版本信息存到localStorage里，再有路由变化时则不会再次刷新了，直到下次新版本发布重新走步骤2</p></li></ul></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h3><p>首先编写一个webpack plugin ：VersionFilePlugin.js，主要逻辑为生成一个version.json在项目打包配置output.path的static文件夹下</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-comment">/**</span><span class="hljs-comment"> * 生成版本信息</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VersionFilePlugin</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> &#123;    <span class="hljs-built_in">this</span>.options = options || &#123;&#125;;  &#125;  <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">compiler</span>)</span> &#123;    compiler.plugin(<span class="hljs-string">&#x27;done&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">stat</span>) =&gt;</span> &#123;      <span class="hljs-comment">//方案：作为json文件打到dist里，然后通过网络请求进行查找version.json文件</span>      <span class="hljs-keyword">const</span> version = <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">// 获取当前时间戳</span>      <span class="hljs-keyword">const</span> versionData = &#123; version &#125;;      <span class="hljs-keyword">const</span> versionFilePath = path.join(compiler.options.output.path, <span class="hljs-string">&#x27;static/version.json&#x27;</span>);      <span class="hljs-comment">// 写入version.json文件</span>      fs.writeFileSync(versionFilePath, <span class="hljs-built_in">JSON</span>.stringify(versionData));    &#125;);  &#125;&#125;<span class="hljs-built_in">module</span>.exports = VersionFilePlugin;</code></pre></div><p>在webpack.prod.conf里引入这个插件（uat和prod的打包都是使用的这个文件，开发环境的webpack.dev.conf不需要引入此插件功能）</p><div class="code-wrapper"><pre><code class="hljs text">const VersionFilePlugin = require(&#x27;../plugins/VersionFilePlugin&#x27;);plugins：[    ...省略其他代码    new VersionFilePlugin()  在所有plugin的最后引入这个VersionFilePlugin]</code></pre></div><p>到此步为止，运行pc的npm run build:shuat 或者 npm run build:shprod可以看到打包出的dist文件夹下已有一个version.json文件了</p><p><img src="/img/blog/page_version/1.png" alt="img.png"></p><p><img src="/img/blog/page_version/2.png" alt="img.png"></p><p>接下来在api里请求这个json文件，/api/version.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/request&#x27;</span>;<span class="hljs-comment">//获取版本信息</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getVersion</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> request.MainService(&#123;    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/pc/static/version.json&#x27;</span>,    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,  &#125;);&#125;</code></pre></div><p>在app.vue里的全局监听路由变化进行调用上面的api</p><div class="code-wrapper"><pre><code class="hljs vue">watch: &#123;  $route(val, old) &#123;    //获取版本信息    getVersion().then(data =&gt; &#123;      if(data &amp;&amp; data.version)&#123;        versionExamine(data.version);      &#125;    &#125;)  &#125;&#125;</code></pre></div><p>versionExamine方法是util里的工具方法，用于对比本地缓存里的versionData，此工具方法移动和pc可以共用</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//版本检查：根据本地缓存的版本信息和服务器的版本信息进行对比</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">versionExamine</span>(<span class="hljs-params">timestamp</span>)</span>&#123;  <span class="hljs-keyword">let</span> storage_version = <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;versionData&#x27;</span>);  <span class="hljs-keyword">if</span>(storage_version)&#123;<span class="hljs-comment">//本地有版本信息则进行对比</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Number</span>(timestamp) !== <span class="hljs-built_in">Number</span>(storage_version))&#123;      <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;versionData&#x27;</span>,timestamp);      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;强制刷新页面~~&#x27;</span>);      location.reload();    &#125;  &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//没有的话先存下版本信息，再进行刷新页面</span>    <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;versionData&#x27;</span>,timestamp);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;强制刷新页面~~&#x27;</span>);    location.reload();  &#125;&#125;</code></pre></div><p>最后，如有版本更新，在pc的页面进行路由跳转时会自动进行刷新浏览器的当前tab页，同时可看到【强制刷新页面~~】的log<br><img src="/img/blog/page_version/3.png" alt="img.png"></p><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p>由于移动端的的angular项目很老，是angular5的版本（目前官方已更新16），直接使用PC的同一个webpack插件的方式不适用于这个版本，所以做了以下修改：</p><p>这个生成version.json的插件不再是一个webpack形式，而是直接使用node里的fs模块生成一个文件出来，在执行打包时把它当做一个命令顺序执行：</p><p>version-plugin.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs= <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">const</span> version = <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">// 获取当前时间戳</span><span class="hljs-keyword">const</span> versionData = &#123; version &#125;;<span class="hljs-comment">// 写入version.json文件</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;versionData&#x27;</span>, versionData);fs.writeFileSync(<span class="hljs-string">&#x27;./dist/assets/version.json&#x27;</span>, <span class="hljs-built_in">JSON</span>.stringify(versionData));</code></pre></div><p>现在package.json里增加一个命令，然后修改uat的打包命令：</p><div class="code-wrapper"><pre><code class="hljs shell">&quot;version-plugin&quot;: &quot;node ./version-plugin.js&quot;,</code></pre></div><p>uat修改前的打包命令：</p><div class="code-wrapper"><pre><code class="hljs shell">&quot;produat&quot;: &quot;npm run git-plugin --max_old_space_size=16384 &amp;&amp; node --max_old_space_size=16384 ./node_modules/@angular/cli/bin/ng build  --dev --aot --build-optimizer  --environment=uat&quot;</code></pre></div><p>在原本的命令后面加上 &amp;&amp; npm run version-plugin，修改后：</p><div class="code-wrapper"><pre><code class="hljs shell">&quot;produat&quot;: &quot;npm run git-plugin --max_old_space_size=16384 &amp;&amp; node --max_old_space_size=16384 ./node_modules/@angular/cli/bin/ng build  --dev --aot --build-optimizer  --environment=uat &amp;&amp; npm run version-plugin&quot;</code></pre></div><p>然后运行流水线，可看到运行记录：<br><img src="/img/blog/page_version/4.png" alt="img.png"></p><p><img src="/img/blog/page_version/5.png" alt="img.png"></p><p>再查看移动端的部署日志可看到，已生成成功：<br><img src="/img/blog/page_version/6.png" alt="img.png"></p><p>和pc一样，接下来在app.component.ts的路由里调用api，执行util里的versionExamine方法，进行对比处理：<br><img src="/img/blog/page_version/7.png" alt="img.png"></p><p>如有版本更新会自动进行刷新浏览器的当前tab页，可同样看到【强制刷新页面~~】的log<br><img src="/img/blog/page_version/8.png" alt="img.png"></p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>此功能上线之后，只有更新到这个方案的客户端才具备路由跳转进行版本更新的功能</p><p>此功能不具备解决线上有关逻辑性的报障，可解决一些因为版本落后导致的js/css/image等资源更新的情况</p>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Chrome新版浏览器存储分区的技术前瞻（2023.10）</title>
    <link href="/2023/10/30/%E5%85%B3%E4%BA%8EChrome%E6%96%B0%E7%89%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E5%88%86%E5%8C%BA%E7%9A%84%E6%8A%80%E6%9C%AF%E5%89%8D%E7%9E%BB/"/>
    <url>/2023/10/30/%E5%85%B3%E4%BA%8EChrome%E6%96%B0%E7%89%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E5%88%86%E5%8C%BA%E7%9A%84%E6%8A%80%E6%9C%AF%E5%89%8D%E7%9E%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>事件说明：2023.10.25，第三方学习平台报障，PC端的报告页新开tab查看报告详情，被跳转到了登录页，用户在不登录的情况下无法查看报告详情。<br>排查过程：部分同事电脑的Chrome可以正常跳转，部分电脑的Chrome不可以，第一时间发现是版本不同，然后发现在浏览器存储里，低版本的Chrome（106.x）和高版本的Chrome(118.x)上显示有差异，在当时不确定具体原因的情况下做了如下修改，解决了报障问题：<br>解决方案：在pc端新打开tab的代码里，把token加到要打开的url后面，同时在app.vue里做url取token的处理，来获取userinfo信息。避免因为没有token，而被跳转到登录页。</p></blockquote><p>此次线上报障虽然已经修复，但为了找到根本原因，以方便后续web开发的应用能够正常运行在不同版本浏览器，去到 Chrome官网了解到了如下信息：</p><h2 id="Chrome版本差异"><a href="#Chrome版本差异" class="headerlink" title="Chrome版本差异"></a>Chrome版本差异</h2><p>Chrome在最近几年的用户隐私上做了很多的技术提案以及功能上的开发探讨，此次问题的原因在于新版本Chrome浏览器增加了<a href="https://developers.google.com/privacy-sandbox/3pcd/storage-partitioning?hl=zh-cn#how-to-test-storage-partitioning">【分区存储】</a>的机制，什么是分区存储？（点击文字可查看官网原文）</p><blockquote><p>To prevent certain types of side-channel cross-site tracking, Chrome is partitioning storage and communications APIs in third-party contexts.</p><p>为了防止某些类型的旁路跨站点跟踪，Chrome正在第三方上下文中对存储和通信API进行分区。</p></blockquote><blockquote><p>Without storage partitioning, a site can join data across different sites to track the user across the web. Also, it allows the embedded site to infer specific states about the user in the top-level site using side-channel techniques such as Timing Attacks, XS-Leaks, and COSI.</p><p>如果没有存储分区，一个站点可以连接不同站点的数据，从而在整个Web上跟踪用户。此外，它还允许嵌入式站点使用侧信道技术（如定时攻击、XS泄漏和COSI）来推断顶级站点中用户的特定状态。</p></blockquote><blockquote><p>Historically, storage has been keyed only by origin. This means that if an iframe from example.com is embedded on a.com and b.com, it could learn about your browsing habits for those two sites by storing and successfully retrieving an ID from storage. With third-party storage partitioning enabled, storage for example.com exists in two different partitions, one for a.com and the other for b.com.</p><p>从历史上看，存储仅按来源进行监控。这意味着，如果example.com中的iframe嵌入到a.com和b.com中，它可以通过存储并成功从存储中检索ID来了解这两个网站的浏览习惯。在启用第三方存储分区的情况下，example.com的存储存在于两个不同的分区中，一个用于a.com，另一个用于b.com。</p></blockquote><blockquote><p>Partitioning generally means that data stored by storage APIs like local storage and IndexedDB by an iframe will no longer be accessible to all contexts in the same origin. Instead, the data will only be available to contexts with the same origin and same top-level site.</p><p>分区通常意味着存储API（如本地存储和IndexedDB）通过iframe存储的数据将不再可以访问同一来源的所有上下文。相反，数据将仅可用于具有相同来源和相同顶级站点的上下文。</p></blockquote><p>最后一句话说明了重点：存储的数据只能在具有相同来源和相同顶级站点进行访问。<br>然后对于web开发来说，最常用的local storage和session storage受到了影响，如下说明:</p><blockquote><p>The Web Storage API provides mechanisms by which browsers can store key/value pairs. There are two mechanisms: Local Storage and Session Storage. They are not currently quota-managed, but will still be partitioned.</p><p>Web Storage API 提供了浏览器可以存储键/值对的机制。有两种机制: 本地存储和会话存储。它们当前不受配额管理，但仍将被分区。</p></blockquote><p>这句话里的不受配额管理，目前不确定是不是大小限制的机制有所修改，但存储分区这件事已经确定在115以上版本的Chrome上做了此机制，但实际测试，116版本也是可以访问的，可能只有升级到117或者118才有这个机制（个人判断）。</p><p>下图是官方介绍第三方站点嵌套某个站点，关于存储分区概念的图例：<br>存储分区版本之前：</p><p><img src="/img/blog/chrome/1.png" alt="img.png"></p><p>存储分区版本之后：</p><p><img src="/img/blog/chrome/2.png" alt="img.png"></p><p>结合上图所示，如果一个第三方站点使用iframe的形式打开了a站点，a本身存储的数据会只存在该第三方站点+a站点下。<br>比如10月初a站点的scorm化，实际机制就等于是LMS平台作为顶级站点利用iframe的形式打开了a站点，这个时候存储的数据显示在118版本的浏览器上如下所示：<br>首先是scorm cloud这个平台的存储，有一个源地址：</p><p><img src="/img/blog/chrome/3.png" alt="img.png"></p><p>然后点击m-uat，比低版本的Chrome浏览器多了一个顶级站点和是否属于第三方的属性：</p><p><img src="/img/blog/chrome/4.png" alt="img.png"></p><p>再根据官方图例的机制，此时在scorm cloud的站点下，存储的数据等于是在【<a href="https://cloud.scorm.com/">https://cloud.scorm.com</a> + <a href="https://abc.abc】的站点上,这个时候新开tab页访问dna或者其他页面,实际是拿不到【https//abc.abc%E3%80%91%E8%BF%99%E4%B8%AA%E7%BC%93%E5%AD%98%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E3%80%82">https://abc.abc】的站点上，这个时候新开tab页访问DNA或者其他页面，实际是拿不到【https://abc.abc】这个缓存下的数据的。</a></p><p>所以此次报障的原因基本如上，最近几年关于用户信息在法律保护上越来越严格化，对于应用开发来说，需要跟随新技术或平台的机制做一些处理或技术方案升级。</p><h2 id="存储分区的技术方案"><a href="#存储分区的技术方案" class="headerlink" title="存储分区的技术方案"></a>存储分区的技术方案</h2><h3 id="官方技术方案"><a href="#官方技术方案" class="headerlink" title="官方技术方案"></a>官方技术方案</h3><p>针对存储分区来说，并不是限制了以后任何情况下都不能跨站点访问数据了，而是有了新的API：share storage。<br>顾名思义，是在不同顶级站点下，分享自己站点的数据给其他顶级站点下的相同站点访问。<br>具体文档：<a href="https://github.com/WICG/shared-storage/blob/main/README.md#worklets-can-outlive-the-associated-document">https://github.com/WICG/shared-storage/blob/main/README.md#worklets-can-outlive-the-associated-document</a><br>但由于是新技术，目前未在项目上去做尝试，并且此API在市面上的浏览器并不通用：<br>（可见Chrome和Edge且只有117和118才有）<br><img src="/img/blog/chrome/5.png" alt="img.png"></p><h3 id="应用上的技术方案"><a href="#应用上的技术方案" class="headerlink" title="应用上的技术方案"></a>应用上的技术方案</h3><p>假如后端服务已支持token机制，在大部分场景下可通过url中拼接token的方式来解决问题；<br>没有token机制？emmmm…..</p><h2 id="写在结尾："><a href="#写在结尾：" class="headerlink" title="写在结尾："></a>写在结尾：</h2><p>Chrome浏览器发版内容地址：<br><a href="https://chromestatus.com/roadmap">https://chromestatus.com/roadmap</a><br><a href="https://chromestatus.com/features#milestone%3D118">https://chromestatus.com/features#milestone%3D118</a><br>如果有在本月或者本周把Chrome升级到最新版本的小伙伴，可以看下对应的应用是否需要做一些处理（主要是被第三方使用iframe打卡&amp;&amp;打开新tab的相同站点）。<br>由于本次只在Chrome上做了新技术了解，其他如firefox等浏览器也许也有各自的限制或技术升级，如果有小伙伴在开发期间了解到或应用到了新的技术，可以分享给大家，共同学习，共同进步~</p>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SCORM入门学习记录</title>
    <link href="/2023/07/26/SCORM%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/07/26/SCORM%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>SCORM文档：<a href="https://scorm.com/scorm-explained/technical-scorm/">https://scorm.com/scorm-explained/technical-scorm/</a></p><h2 id="1-SCORM1-2规范"><a href="#1-SCORM1-2规范" class="headerlink" title="1. SCORM1.2规范"></a>1. SCORM1.2规范</h2><p>SCORM是”Sharable Content Object Reference Model（可共享课程对象参考模型）”的缩写，是由ADL组织所拟定的标准。已作为全世界通用的标准规格。</p><h3 id="SCORM规定一个标准的课件包应满足以下条件："><a href="#SCORM规定一个标准的课件包应满足以下条件：" class="headerlink" title="SCORM规定一个标准的课件包应满足以下条件："></a>SCORM规定一个标准的课件包应满足以下条件：</h3><ul><li>打包成ZIP文件。</li><li>在XML文件中描述。</li><li>通过JavaScript进行通信。</li><li>使用XML中的规则排序。</li></ul><h3 id="SCORM由三个子规范组成"><a href="#SCORM由三个子规范组成" class="headerlink" title="SCORM由三个子规范组成"></a>SCORM由三个子规范组成</h3><ul><li>CAM（Content Aggregation Model）： 指定应如何打包和描述内容。它主要基于XML。</li><li>Run-Time：指定内容应该如何启动以及它如何与LMS通信。它主要基于ECMAScript（JavaScript）。</li><li>Sequencing：指定学习者如何在课程的各个部分（SCOs）之间导航。它由一组用XML编写的规则和属性定义。</li></ul><p><img src="/img/blog/scorm/1.png" alt="img.png"></p><h2 id="2-LMS的API与DATA-MODEL"><a href="#2-LMS的API与DATA-MODEL" class="headerlink" title="2. LMS的API与DATA MODEL"></a>2. LMS的API与DATA MODEL</h2><p>API地址：<a href="https://scorm.com/scorm-explained/technical-scorm/run-time/run-time-reference/#section-2">https://scorm.com/scorm-explained/technical-scorm/run-time/run-time-reference/#section-2</a></p><p>常用API整理：</p><div class="code-wrapper"><pre><code class="hljs text">LMSInitialize 开始与LMS的通信会话。 LMSFinish 结束与LMS的通信会话。 LMSGetValue 存值 LMSSetValue 取值 LMSCommit 向LMS指示所有数据都应保存 LMSGetLastError 返回上次API调用导致的错误代码。 LMSGetErrorString 返回描述指定错误代码的短字符串。 LMSGetDiagnostic 返回有关上次发生的错误的详细信息。</code></pre></div><p>DATA MODEL:一组定义的数据点，内容和LMS可以通过SCORM API交换.示例数据模型元素包括“cmi.score.scaled”（以记录用户的测试分数）和“cmi.completion_status”以记录学习者何时/是否已经完成一些训练。<br>常用MODEL整理：</p><ul><li>cmi.core._children - returns “student_id, student_name, lesson_location, credit, lesson_status, entry, score, total_time, exit, session_time”</li><li>cmi.core.student_id</li><li>cmi.core.student_name</li><li>cmi.core.lesson_location - 255 char string typically used for bookmarking</li><li>cmi.core.credit - returns “no-credit” or “credit”</li><li>cmi.core.lesson_status - indicates SCO completion - returns one of the following: “passed”, “completed”, “failed”, “incomplete”, “browsed”, or “not attempted”</li><li>cmi.core.entry - returns “ab-initio”, “resume”, or “”</li><li>cmi.core.score._children - returns “raw, min, max”</li><li>cmi.core.score.raw - the raw score value</li><li>cmi.core.score.max - the maximum possible score - if not set, assumed 100</li><li>cmi.core.score.min - the minimum possible score - if not set, assumed 0</li><li>cmi.core.total_time - returns the sum of all a learner’s session times</li><li>cmi.core.lesson_mode - returns “browse”, “normal”, or “review”</li><li>cmi.suspend_data - 4096 char string usually used for progress data</li><li>cmi.launch_data - 4096 char string used to pass data to the SCO on launch from the LMS</li><li>cmi.objectives._children - returns “id, score, status”</li><li>cmi.objectives._count - returns the number of objectives currently stored for this SCO.</li><li>cmi.objectives.n.id - returns the objective identifier where “n” is the objective number</li><li>cmi.objectives.n.score._children - returns “raw, min, max “</li><li>cmi.objectives.n.score.raw - the raw objective score value</li><li>cmi.objectives.n.score.min - The minimum possible score - if not set, assumed 0</li><li>cmi.objectives.n.score.max - the maximum possible objective score - if not set, assumed 100</li><li>cmi.objectives.n.status - indicates if the learner has completed the objective - returns one of the following: “passed”, “completed”, “failed”, “incomplete”, “browsed”, or “not attempted”</li><li>cmi.core.exit</li><li>cmi.core.session_time</li></ul><h2 id="3-imsmanifest-xml"><a href="#3-imsmanifest-xml" class="headerlink" title="3. imsmanifest.xml"></a>3. imsmanifest.xml</h2><p>在SCORM 1.2规范中每个课程必须包含一个imsmanifest.xml文件，该文件向LMS描述其结构和其他特征。<br>清单文件由4个主要部分组成：</p><ol><li>Meta-data：内容包数据描述的入口。</li><li>Organizations：包含了学习资源的组织或内容结构。</li><li>Resources：在内容包中定义的学习资源（集合）。</li><li>SubManifest：嵌套的子清单。</li></ol><p>在”imsmanifest.xml”文件中，使用XML标记语言来定义课件包的结构和内容。以下是一些常用的XML标记和元素：</p><ul><li><code>&lt;manifest&gt;</code>：根元素，定义课件包的基本信息。</li><li><code>&lt;metadata&gt;</code>：元数据元素，用于描述课件包的相关信息，如标题、作者、描述等。</li><li><code>&lt;organizations&gt;</code>：组织元素，用于定义课程的组织结构和章节。</li><li><code>&lt;resources&gt;</code>：资源元素，用于定义课程所需的资源文件，如HTML、CSS、JavaScript等。</li><li><code>&lt;item&gt;</code>：项目元素，用于定义课程的章节和子章节。</li><li><code>&lt;file&gt;</code>：文件元素，用于引用课程所需的资源文件。<br>下面是一个基础的模板示例：</li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">identifier</span>=<span class="hljs-string">&quot;com.scorm.manifesttemplates.scorm12&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.imsproject.org/xsd/imscp_rootv1p1p2&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:adlcp</span>=<span class="hljs-string">&quot;http://www.adlnet.org/xsd/adlcp_rootv1p2&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.imsproject.org/xsd/imscp_rootv1p1p2 imscp_rootv1p1p2.xsd</span></span><span class="hljs-string"><span class="hljs-tag">                           http://www.imsglobal.org/xsd/imsmd_rootv1p2p1 imsmd_rootv1p2p1.xsd</span></span><span class="hljs-string"><span class="hljs-tag">                           http://www.adlnet.org/xsd/adlcp_rootv1p2 adlcp_rootv1p2.xsd&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">metadata</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">schema</span>&gt;</span>ADL SCORM<span class="hljs-tag">&lt;/<span class="hljs-name">schema</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">schemaversion</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">schemaversion</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">metadata</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">organizations</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;B0&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">organization</span> <span class="hljs-attr">identifier</span>=<span class="hljs-string">&quot;B0&quot;</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>演示文件<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>                         <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">identifier</span>=<span class="hljs-string">&quot;i1&quot;</span> <span class="hljs-attr">identifierref</span>=<span class="hljs-string">&quot;r1&quot;</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>                         <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">organization</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">organizations</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">resource</span> <span class="hljs-attr">identifier</span>=<span class="hljs-string">&quot;r1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;webcontent&quot;</span> <span class="hljs-attr">adlcp:scormtype</span>=<span class="hljs-string">&quot;sco&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;index.html&quot;</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">file</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;index.html&quot;</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span></code></pre></div><p>组织结构示例：</p><p><img src="/img/blog/scorm/2.png" alt="img.png"></p><p>有必要特别指出的是以下几点：</p><ol><li>各节点的“identifier”属性应该唯一；</li><li>“organizations”节点下可以有多个“organization”节点，通过“organizations”的“default”属性指向某一个</li><li>“organization”来决定使用那一种组织结构；</li><li>“organization”下的“item”节点是可以嵌套的，用来实现课程章节的层次关系；</li><li>“item”节点的“identifierref”属性的值为某一个“resource”节点的“identifier”属性的值，使某一章节与课程资源建立对应关系；</li><li>“title”节点里的文本是课程以及章节在平台上的显示文本；</li><li>“resource”节点的“href”属性是课程资源的存储位置。</li></ol><h2 id="4-制作一个SCORM课件"><a href="#4-制作一个SCORM课件" class="headerlink" title="4. 制作一个SCORM课件"></a>4. 制作一个SCORM课件</h2><p>基础示例：<br><img src="/img/blog/scorm/3.png" alt="img.png"></p><h2 id="5-SCORM打包流程图"><a href="#5-SCORM打包流程图" class="headerlink" title="5. SCORM打包流程图"></a>5. SCORM打包流程图</h2><p><img src="/img/blog/scorm/4.png" alt="img.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SCORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WEB技术调研：【视频切片+播放】</title>
    <link href="/2023/03/12/WEB%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%E8%A7%86%E9%A2%91%E5%88%87%E7%89%87%E6%92%AD%E6%94%BE/"/>
    <url>/2023/03/12/WEB%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%E8%A7%86%E9%A2%91%E5%88%87%E7%89%87%E6%92%AD%E6%94%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>此次调研的源代码已放在GitHub，欢迎访问：<br><a href="https://github.com/wenkil/video-m3u8-demo">https://github.com/wenkil/video-m3u8-demo</a></p><h2 id="调研背景"><a href="#调研背景" class="headerlink" title="调研背景"></a>调研背景</h2><p>SCORM视频包通常会将一些图片、视频资源直接放到包内提供，从公司产品角度需要考虑内容的传播和使用，比如直接打开包内找到视频的mp4文件，自己存下来或转播给其他人的操作是不被允许的，这时候需要借助一些手段来做一层防护，防止用户直接拿走mp4格式的视频资源。<br>本文主要借助ffmpeg视频分割技术来展示如何将一个MP4视频分割为M3U8列表格式的视频切片，并在前端项目里加载这些分割后的切片进行播放；</p><p>(以下内容来自智谱清言)</p><blockquote><p>什么是FFmpeg？</p></blockquote><blockquote><p>FFmpeg是一个开源项目，它包含了一套完整的跨平台的音视频处理工具和库，用于处理音频和视频文件。FFmpeg是由FFmpeg社区维护的，它支持大量的音视频格式，并且可以在多种操作系统上运行，包括Windows、macOS和Linux等。<br>FFmpeg的主要组件包括：<br>FFmpeg命令行工具：这是FFmpeg中最常用的部分，它提供了一个命令行界面，允许用户执行各种音视频处理任务，如转换格式、压缩、解码、编码、剪辑、过滤和播放等。<br>libavcodec：这是FFmpeg的核心库之一，提供了音视频编解码功能。它包含了大量的编解码器，可以处理几乎所有的音视频格式。<br>libavformat：这个库负责处理各种音视频封装格式，如MP4、MKV、OGG等。它提供了读取和写入这些格式的能力。<br>libavutil：这是一个包含了一些通用工具和实用程序的库，如数学计算、数据结构、随机数生成器等。<br>libavfilter：这个库提供了一系列的音视频过滤器，可以用来处理音视频流，如应用效果、进行转换等。<br>libavresample：这个库用于音视频采样率转换和通道布局转换。<br>FFmpeg的使用非常广泛，它被用于各种场合，如视频剪辑、视频转换、音频处理、流媒体传输等。FFmpeg的命令行工具是通过执行一系列的FFmpeg库来完成的，它提供了一个简洁的命令行界面，允许用户通过输入命令来执行各种操作。<br>FFmpeg的安装通常涉及到下载源代码或预编译的二进制文件，然后将其安装到系统中。在安装后，你可以在命令行中使用FFmpeg的命令来执行各种音视频处理任务。<br>例如，以下是一些常用的FFmpeg命令：<br>ffmpeg -i input.mp4 output.avi：将输入文件input.mp4转换为output.avi。<br>ffmpeg -i input.mp3 output.wav：将输入文件input.mp3转换为output.wav。<br>ffmpeg -i input.mp4 -ss 00:00:10 -to 00:00:20 -c copy output.mp4：从input.mp4中剪辑出从第10秒到第20秒的片段，并保存为output.mp4。<br>FFmpeg是一个功能强大的工具，对于音视频处理来说是一个非常有用的资源。由于其开源和跨平台的特性，它被广泛应用于个人和商业项目中。</p></blockquote><blockquote><p>什么是M3U8？</p></blockquote><blockquote><p>M3U8是一种用于多媒体播放列表的格式，它广泛用于网络流媒体中，尤其是用于视频流和音频流。M3U8播放列表可以包含多个媒体文件的URL，这些文件按顺序排列，以便于播放器能够依次播放它们。M3U8格式支持视频流媒体服务中的无缝播放，即视频在缓冲期间可以播放下一段的预加载内容，从而给用户带来平滑的观看体验。<br>M3U8播放列表的文件扩展名通常是.m3u8。这种格式的播放列表可以包含以下信息：<br>媒体文件的URL：播放列表中包含每个媒体文件的URL，这些URL指向存储媒体文件的服务器地址。<br>媒体文件的播放顺序：播放列表中文件的排列顺序指示了媒体文件应按照该顺序播放。<br>媒体文件的持续时间：有时播放列表中还包含媒体的持续时间信息，以便于播放器进行时间同步和播放进度控制。<br>M3U8格式有两种主要的变体：<br>基本M3U8：这种变体不包含关于媒体文件片段的任何信息，只是简单地列出了媒体文件的URL。基本M3U8适用于不支持流媒体的旧版播放器。<br>扩展M3U8：这种变体包含了关于媒体文件片段的更多信息，如片段的持续时间和byterange，这有助于播放器更有效地处理和播放视频流。扩展M3U8通常用于现代流媒体服务中。<br>在视频流媒体服务中，视频文件通常会被分割成多个较小的片段，每个片段是一个独立的媒体文件。M3U8播放列表包含了这些片段的URL，并且按照播放顺序排列。当用户请求播放视频时，流媒体服务器会根据M3U8播放列表依次传输这些片段，并在播放器中按顺序播放它们。由于M3U8支持无缝播放，视频流在缓冲期间可以播放下一段的预加载内容，从而实现平滑的观看体验，无需等待整个视频下载完成。<br>M3U8格式在直播视频和VoD（视频点播）服务中得到了广泛应用，因为它能够适应不同的网络条件和设备性能，提供稳定可靠的流媒体服务。</p></blockquote><h2 id="视频切片代码"><a href="#视频切片代码" class="headerlink" title="视频切片代码"></a>视频切片代码</h2><p>首先创建一个node项目，提供一个api，可以将提供的视频进行分割，主要借助FFmpeg 的npm库，执行FFmpeg 命令进行分割，代码如下：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">const</span> router = express.Router();<span class="hljs-keyword">const</span> multer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;multer&#x27;</span>);<span class="hljs-keyword">const</span> ffmpeg = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ffmpeg-static&#x27;</span>);<span class="hljs-keyword">const</span> &#123; exec &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-comment">// 设置上传目录和文件名</span><span class="hljs-keyword">const</span> storage = multer.diskStorage(&#123;    <span class="hljs-attr">destination</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, file, cb</span>) </span>&#123;        <span class="hljs-keyword">const</span> uploadDir = path.join(__dirname, <span class="hljs-string">&#x27;../uploads/&#x27;</span>);        <span class="hljs-comment">// 确保上传目录存在</span>        <span class="hljs-keyword">if</span> (!fs.existsSync(uploadDir))&#123;            fs.mkdirSync(uploadDir, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;);        &#125;        cb(<span class="hljs-literal">null</span>, uploadDir);    &#125;,    <span class="hljs-attr">filename</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, file, cb</span>) </span>&#123;        cb(<span class="hljs-literal">null</span>, file.originalname);    &#125;&#125;);<span class="hljs-keyword">const</span> upload = multer(&#123; <span class="hljs-attr">storage</span>: storage &#125;);<span class="hljs-comment">// 定义上传和转换视频的路由</span>router.post(<span class="hljs-string">&#x27;/upload&#x27;</span>, upload.single(<span class="hljs-string">&#x27;video&#x27;</span>), <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> videoPath = req.file.path;    <span class="hljs-keyword">const</span> outputDir = path.join(__dirname, <span class="hljs-string">&#x27;../uploads/&#x27;</span>, path.parse(videoPath).name);    <span class="hljs-keyword">if</span> (!fs.existsSync(outputDir))&#123;        fs.mkdirSync(outputDir, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;);    &#125;    <span class="hljs-keyword">const</span> outputPath = path.join(outputDir, <span class="hljs-string">&#x27;video.m3u8&#x27;</span>);    <span class="hljs-comment">// 使用FFmpeg转化视频</span>    <span class="hljs-keyword">const</span> ffmpegCommand = $&#123;ffmpeg&#125; -i <span class="hljs-string">&quot;$&#123;videoPath&#125;&quot;</span> -codec: copy -start_number <span class="hljs-number">0</span> -hls_time <span class="hljs-number">10</span> -hls_list_size <span class="hljs-number">0</span> -f hls <span class="hljs-string">&quot;$&#123;outputPath&#125;&quot;</span>;    exec(ffmpegCommand, <span class="hljs-function">(<span class="hljs-params">error, stdout, stderr</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (error) &#123;            <span class="hljs-built_in">console</span>.error(exec error: $&#123;error&#125;);            <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;视频转换失败：&#x27;</span>+error &#125;);        &#125;        <span class="hljs-built_in">console</span>.log(stdout: $&#123;stdout&#125;);        <span class="hljs-built_in">console</span>.error(stderr: $&#123;stderr&#125;);        res.send(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;视频转换完成，转换目录：&#x27;</span>, <span class="hljs-attr">path</span>: outputPath &#125;);    &#125;);&#125;);router.get(<span class="hljs-string">&#x27;/convert-videos&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> videosDir = path.join(__dirname, <span class="hljs-string">&#x27;../videos&#x27;</span>); <span class="hljs-comment">// 视频文件所在目录</span>    fs.readdir(videosDir, <span class="hljs-function">(<span class="hljs-params">err, files</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (err) &#123;            <span class="hljs-built_in">console</span>.error(<span class="hljs-built_in">Error</span> reading directory: $&#123;err&#125;);            <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;读取文件夹失败！！！&#x27;</span> &#125;);        &#125;        <span class="hljs-comment">// 过滤出视频文件，这里简单以.mp4为例</span>        <span class="hljs-keyword">const</span> videoFiles = files.filter(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> file.endsWith(<span class="hljs-string">&#x27;.mp4&#x27;</span>));        <span class="hljs-keyword">if</span> (videoFiles.length === <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> res.send(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;没有找到mp4文件！！！&#x27;</span> &#125;);        &#125;        videoFiles.forEach(<span class="hljs-function"><span class="hljs-params">videoName</span> =&gt;</span> &#123;            <span class="hljs-keyword">const</span> videoPath = path.join(videosDir, videoName);            <span class="hljs-keyword">const</span> outputDir = path.join(videosDir, <span class="hljs-string">&#x27;output&#x27;</span>, path.parse(videoName).name);            <span class="hljs-keyword">if</span> (!fs.existsSync(outputDir)) &#123;                fs.mkdirSync(outputDir, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;);            &#125;            <span class="hljs-keyword">const</span> outputPath = path.join(outputDir, <span class="hljs-string">&#x27;video.m3u8&#x27;</span>);            <span class="hljs-comment">// 使用FFmpeg转化视频</span>            <span class="hljs-keyword">const</span> ffmpegCommand = $&#123;ffmpeg&#125; -i <span class="hljs-string">&quot;$&#123;videoPath&#125;&quot;</span> -codec: copy -start_number <span class="hljs-number">0</span> -hls_time <span class="hljs-number">10</span> -hls_list_size <span class="hljs-number">0</span> -f hls <span class="hljs-string">&quot;$&#123;outputPath&#125;&quot;</span>;            exec(ffmpegCommand, <span class="hljs-function">(<span class="hljs-params">error, stdout, stderr</span>) =&gt;</span> &#123;                <span class="hljs-keyword">if</span> (error) &#123;                    <span class="hljs-built_in">console</span>.error(<span class="hljs-built_in">Error</span> converting $&#123;videoName&#125;: $&#123;error&#125;);                    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 在这里，我们简单地返回，你可能想要处理错误或记录到错误日志</span>                &#125;                <span class="hljs-built_in">console</span>.log($&#123;videoName&#125; conversion succeeded.);            &#125;);        &#125;);        res.send(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;videos文件夹下的所有视频转换完成！~~&#x27;</span> &#125;);    &#125;);&#125;);<span class="hljs-built_in">module</span>.exports = router;</code></pre></div><p>这里的js里提供了两种方式，一种上传的方式，一种是直接遍历指定文件夹下的所有视频而不需要上传的方式；</p><p>新建一个upload.html</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Upload Video<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Upload a Video<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/upload&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;video&quot;</span> <span class="hljs-attr">accept</span>=<span class="hljs-string">&quot;video/*&quot;</span> <span class="hljs-attr">required</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Upload Video<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>启动node项目，在浏览器打开：<a href="http://localhost:xxxx/upload.html">http://localhost:xxxx/upload.html</a> ， 展示如下:<br>点击选择文件，上传视频，然后点击Upload Video按钮，这时候会自动执行router.post(‘/upload’) 的方法，主要逻辑为读取视频文件名称，并通过ffmpeg命令执行分割，该命令会自动把分割后的文件输出到指定目录，即uploads文件夹下，页面展示如图：<br><img src="/img/blog/m3u8/1.png" alt="img.png"></p><p>在文件夹的目录展示如下：会有一个xxx.m3u8和n个ts格式的文件:<br><img src="/img/blog/m3u8/2.png" alt="img.png"><br>注：代码中/convert-videos 的方法逻辑相同，会将指定文件夹下的所有视频自动转换完成，并按照视频文件名进行单独的目录保存；<br><img src="/img/blog/m3u8/3.png" alt="img.png"></p><h2 id="前端播放m3u8格式的视频"><a href="#前端播放m3u8格式的视频" class="headerlink" title="前端播放m3u8格式的视频"></a>前端播放m3u8格式的视频</h2><p>接下来拿到这些切片的视频，在前端项目里进行保存；<br>前端播放主要使用了hls.js这个库，GitHub地址：<a href="https://github.com/video-dev/hls.js">https://github.com/video-dev/hls.js</a><br>以下是使用方式，及播放效果：</p><p>videoList.vue：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div class=&quot;flex-column-list&quot;&gt;    &lt;button class=&quot;video-btn&quot; v-for=&quot;(video, index) in videos&quot; :key=&quot;index&quot; @click=&quot;selectVideo(video)&quot;&gt;      &#123;&#123; video.name &#125;&#125;    &lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const videos = [  &#123;name: &#x27;Video 1&#x27;, url: &#x27;/video1/video.m3u8&#x27;&#125;,  &#123;name: &#x27;Video 2&#x27;, url: &#x27;/video2/video.m3u8&#x27;&#125;,  &#123;name: &#x27;Video 3&#x27;, url: &#x27;/video3/video.m3u8&#x27;&#125;,  &#123;name: &#x27;Video 4&#x27;, url: &#x27;/video4/video.m3u8&#x27;&#125;,  &#123;name: &#x27;Video 5&#x27;, url: &#x27;/video5/video.m3u8&#x27;&#125;,];const emit = defineEmits([&#x27;update:videoUrl&#x27;]);const selectVideo = (video) =&gt; &#123;  emit(&#x27;update:videoUrl&#x27;, video.url);&#125;;&lt;/script&gt;&lt;style scoped&gt;.flex-column-list &#123;  display: flex;  flex-direction: column;  flex-wrap: nowrap;&#125;.video-btn &#123;  margin: 5px;&#125;&lt;/style&gt;</code></pre></div><p>videoPlayer.vue：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;video ref=&quot;videoElement&quot; controls style=&quot;width: 100%; max-width: 640px;&quot;&gt;&lt;/video&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;;import Hls from &#x27;hls.js&#x27;;// Props to receive the selected video URLconst props = defineProps(&#123;  videoUrl: String,&#125;);const videoElement = ref(null);watchEffect(() =&gt; &#123;  if (!props.videoUrl) return;  if (Hls.isSupported()) &#123;    console.log(&#x27;HLS supported&#x27;);    const hls = new Hls();    hls.loadSource(props.videoUrl);    hls.attachMedia(videoElement.value);    hls.on(Hls.Events.MANIFEST_PARSED, function() &#123;      // videoElement.value.play();    &#125;);  &#125; else if (videoElement.value.canPlayType(&#x27;application/vnd.apple.mpegurl&#x27;)) &#123;    console.log(&#x27;不支持HLS&#x27;);    videoElement.value.src = props.videoUrl;    videoElement.value.addEventListener(&#x27;loadedmetadata&#x27;, () =&gt; &#123;      // videoElement.value.play();    &#125;);  &#125;&#125;);&lt;/script&gt;</code></pre></div><p>点击对应的video按钮，会加载对应的视频指向的地址，点击视频的播放按钮即可正常播放切片的视频，效果如图:<br><img src="/img/blog/m3u8/4.png" alt="img.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>FFmpeg</tag>
      
      <tag>M3U8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机首次安装centos系统常见问题</title>
    <link href="/2022/05/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%A6%96%E6%AC%A1%E5%AE%89%E8%A3%85centos%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/05/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%A6%96%E6%AC%A1%E5%AE%89%E8%A3%85centos%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>虚拟机首次安装打开centos 系统后的一些常见问题</p><h3 id="1-无法查看ip"><a href="#1-无法查看ip" class="headerlink" title="1.无法查看ip"></a>1.无法查看ip</h3><p>（原因：网络配置没打开）</p><div class="code-wrapper"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>sysconfig<span class="hljs-regexp">/network-scripts/i</span>fcfg-ens33ONBOOT=no  改为 ONBOOT=yes</code></pre></div><p>然后运行service network restart  重启网络</p><p>这个时候使用 ping <a href="http://www.baidu.com/">www.baidu.com</a> 测试网络是否可用</p><p>然后输入命令 ip addr show 即可查看：<br><img src="/img/blog/linux/ip.png"></p><p>这个解决办法还有一种是在虚拟机里刚开始安装centos系统时选择打开网络开关：<br><img src="/img/blog/linux/centos1.png"><br><img src="/img/blog/linux/centos2.png"><br><img src="/img/blog/linux/centos3.png"></p><h3 id="2-yum-命令报错"><a href="#2-yum-命令报错" class="headerlink" title="2.yum 命令报错"></a>2.yum 命令报错</h3><p><img src="/img/blog/linux/yum_error.jpg"></p><div class="code-wrapper"><pre><code class="hljs awk">首先进入到<span class="hljs-regexp">/etc/yum</span>.repos.dcd <span class="hljs-regexp">/etc/yum</span>.repos.d然后运行以下命令mv <span class="hljs-regexp">/etc/yum</span>.repos.d<span class="hljs-regexp">/CentOS-Base.repo /</span>etc<span class="hljs-regexp">/yum.repos.d/</span>CentOS-Base.repo.backup再更换repo源curl -o <span class="hljs-regexp">/etc/yum</span>.repos.d<span class="hljs-regexp">/CentOS-Base.repo http:/</span><span class="hljs-regexp">/mirrors.aliyun.com/</span>repo/Centos-<span class="hljs-number">7</span>.repo再运行yum clean all这时候就可以使用yum install xxx 了</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Centos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos系统基础环境搭建：部署node项目和前端项目</title>
    <link href="/2022/05/10/Centos%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%9A%E9%83%A8%E7%BD%B2node%E9%A1%B9%E7%9B%AE%E5%92%8C%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/05/10/Centos%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%9A%E9%83%A8%E7%BD%B2node%E9%A1%B9%E7%9B%AE%E5%92%8C%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h3><p>先安装依赖：</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>安装gccyum install -y gcc-c++<span class="hljs-regexp">//</span>安装PCRE pcre-develyum install -y pcre pcre-devel<span class="hljs-regexp">//</span>安装zlibyum install -y zlib zlib-devel <span class="hljs-regexp">//</span>安装Open SSLyum install -y openssl openssl-devel</code></pre></div><p>然后创建nginx目录</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>进入usr/local目录cd <span class="hljs-regexp">/usr/</span>local <span class="hljs-regexp">//</span>创建nginx目录mkdir nginxcd nginx</code></pre></div><p>下载安装步骤</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>下载tar包wget http:<span class="hljs-regexp">//</span>nginx.org<span class="hljs-regexp">/download/</span>nginx-<span class="hljs-number">1.20</span>.<span class="hljs-number">2</span>.tar.gz <span class="hljs-regexp">//</span>解压tartar -xvf nginx-<span class="hljs-number">1.20</span>.<span class="hljs-number">2</span>.tar.gzcd <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>nginx-<span class="hljs-number">1.20</span>.<span class="hljs-number">2</span> <span class="hljs-regexp">//</span>执行命令./configure <span class="hljs-regexp">//</span>执行make命令(要是执行不成功请检查最开始安装的四个依赖有没有安装成功)make <span class="hljs-regexp">//</span>执行make install命令make install</code></pre></div><p>启动nginx</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>进入<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin目录，输入./nginx即可启动nginx./nginx然后输入curl http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">80</span>可以看到一个nginx默认展示的html页面（或者通过公网ip直接访问云服务器的<span class="hljs-number">80</span>端口：http:<span class="hljs-regexp">//</span>xxx.xx.xx.xx:<span class="hljs-number">80</span>）</code></pre></div><p><img src="/img/blog/nginx/nginx_success.png"></p><p>常用命令</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>关闭nginx.<span class="hljs-regexp">/nginx -s quit  或者 ./</span>nginx -s stop<span class="hljs-regexp">//</span>改动配置文件后先检查配置文件是否有误<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin<span class="hljs-regexp">/nginx -t -c /u</span>sr<span class="hljs-regexp">/local/</span>nginx<span class="hljs-regexp">/conf/</span>nginx.conf <span class="hljs-regexp">//</span>再重启nginx<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin/nginx -s reload <span class="hljs-regexp">//</span>查看nginx进程ps -ef|grep nginx</code></pre></div><h3 id="Node-安装"><a href="#Node-安装" class="headerlink" title="Node 安装"></a>Node 安装</h3><div class="code-wrapper"><pre><code class="hljs crmsh">下载<span class="hljs-keyword">node</span><span class="hljs-title">包</span><span class="hljs-title">wget</span> https://nodejs.org/dist/v14.<span class="hljs-number">15.3</span>/<span class="hljs-keyword">node</span><span class="hljs-title">-v14</span>.<span class="hljs-number">15.3</span>-linux-x64.tar.xz解压<span class="hljs-keyword">node</span><span class="hljs-title">包</span><span class="hljs-title">xz</span> -d <span class="hljs-keyword">node</span><span class="hljs-title">*.xz</span>tar xvf <span class="hljs-keyword">node</span><span class="hljs-title">*.tar</span>mkdir /usr/local/<span class="hljs-keyword">node</span><span class="hljs-title">mv</span> ./<span class="hljs-keyword">node</span><span class="hljs-title">*/* /usr</span>/local/<span class="hljs-keyword">node</span><span class="hljs-title"></span></code></pre></div><p>安装后设置全局命令</p><div class="code-wrapper"><pre><code class="hljs awk">ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/node/</span>bin<span class="hljs-regexp">/node /u</span>sr<span class="hljs-regexp">/local/</span>bin/nodeln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/node/</span>bin<span class="hljs-regexp">/npm /u</span>sr<span class="hljs-regexp">/local/</span>bin/npm</code></pre></div><h3 id="Pm2-安装"><a href="#Pm2-安装" class="headerlink" title="Pm2 安装"></a>Pm2 安装</h3><div class="code-wrapper"><pre><code class="hljs awk">安装pm2 npm install pm2 -g设置全局命令ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/node/</span>bin<span class="hljs-regexp">/pm2 /u</span>sr<span class="hljs-regexp">/local/</span>bin/pm2</code></pre></div><h3 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h3><p>查看每个版本号，可以正常输出<br><img src="/img/blog/nginx/install_success.png"></p><p>参考博客：<a href="https://www.cnblogs.com/cainiaoyige1/p/15785911.html">https://www.cnblogs.com/cainiaoyige1/p/15785911.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Centos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习网站整理(持续更新...)</title>
    <link href="/2021/11/24/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/"/>
    <url>/2021/11/24/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="在线书籍或博客："><a href="#在线书籍或博客：" class="headerlink" title="在线书籍或博客："></a>在线书籍或博客：</h3><p>Github书籍汇总：<a href="https://github.com/itdevbooks/pdf">https://github.com/itdevbooks/pdf</a></p><p>​书栈：<a href="https://www.bookstack.cn/">https://www.bookstack.cn/</a> </p><p>​深入浅出Webpack ： <a href="http://webpack.wuhaolin.cn/">http://webpack.wuhaolin.cn/</a></p><p>​前端笔记： </p><p>​    <a href="https://www.kancloud.cn/surahe/front-end-notebook/781957">https://www.kancloud.cn/surahe/front-end-notebook/781957</a></p><p>​    <a href="https://webbj97.github.io/summary/">https://webbj97.github.io/summary/</a></p><p>​前端书籍汇总： <a href="https://f2edocs.com/books/#">https://f2edocs.com/books/#</a></p><p>​Vue组件通信全揭秘：<a href="https://juejin.cn/post/6844903702411608072#heading-14">https://juejin.cn/post/6844903702411608072#heading-14</a></p><p>​前端面试题：<a href="https://hzfe.github.io/awesome-interview/book1/browser-cross-origin">https://hzfe.github.io/awesome-interview/book1/browser-cross-origin</a></p><p>​Node社区：<a href="https://cnodejs.org/getstart">https://cnodejs.org/getstart</a></p><p>​七天学会Nodejs：<a href="http://nqdeng.github.io/7-days-nodejs/">http://nqdeng.github.io/7-days-nodejs/</a></p><p>​Node入门：<a href="https://cnodejs.org/getstart">https://cnodejs.org/getstart</a></p><p>​Github上的高分项目汇总：<a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts</a></p><p>​vue在线学习：<a href="https://www.kancloud.cn/cyyspring/vuejs/936385">https://www.kancloud.cn/cyyspring/vuejs/936385</a></p><p>​Vue源码分析：<br>    <a href="http://caibaojian.com.cn/vue-design/art/">http://caibaojian.com.cn/vue-design/art/</a><br>    <a href="https://ustbhuangyi.github.io/vue-analysis/v2/prepare/">https://ustbhuangyi.github.io/vue-analysis/v2/prepare/</a><br>    <a href="http://caibaojian.com.cn/vue-analysis/">http://caibaojian.com.cn/vue-analysis/</a></p><p>​ES6在线文档：<a href="http://caibaojian.com.cn/es6/">http://caibaojian.com.cn/es6/</a></p><p>​web开发知识汇总及面试：<a href="http://caibaojian.com.cn/interview-map/">http://caibaojian.com.cn/interview-map/</a></p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object.defineProperty的基本使用</title>
    <link href="/2021/11/19/Object-defineProperty%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/11/19/Object-defineProperty%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="如何实现一个对象属性监听？"><a href="#如何实现一个对象属性监听？" class="headerlink" title="如何实现一个对象属性监听？"></a>如何实现一个对象属性监听？</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = &#123;    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">b</span>: &#123;        <span class="hljs-attr">b1</span>: <span class="hljs-number">2</span>    &#125;,&#125;</code></pre></div><p>一个简单的对象，如何在改变它的某个属性值是监听得到当前属性,例如：</p><p>对某个元素进行操作时打印set xxx = xxx</p><div class="code-wrapper"><pre><code class="hljs javascript">data.a = <span class="hljs-string">&#x27;a&#x27;</span>  <span class="hljs-comment">//set a = a</span>data.b.b1 = <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-comment">// set b1 = b</span></code></pre></div><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><div class="code-wrapper"><pre><code class="hljs reasonml">语法: <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>define<span class="hljs-constructor">Property(<span class="hljs-params">obj</span>, <span class="hljs-params">prop</span>, <span class="hljs-params">descriptor</span>)</span>参数:obj要定义属性的对象。prop要定义或修改的属性的名称或 Symbol 。descriptor要定义或修改的属性描述符。返回值被传递给函数的对象。</code></pre></div><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = &#123;    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;<span class="hljs-built_in">Object</span>.defineProperty(data, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;    <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">return</span> value    &#125;,    <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;        value = v        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`set a = <span class="hljs-subst">$&#123;v&#125;</span>`</span>);    &#125;&#125;)data.a = <span class="hljs-string">&#x27;a&#x27;</span></code></pre></div><p>此时运行后显示</p><p><img src="/img/blog/js/o2.png"></p><h3 id="如何监听多层对象？"><a href="#如何监听多层对象？" class="headerlink" title="如何监听多层对象？"></a>如何监听多层对象？</h3><p>初始化一个复杂对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = &#123;    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">b</span>: &#123;        <span class="hljs-attr">b1</span>: <span class="hljs-number">2</span>,        <span class="hljs-attr">b2</span>: &#123;            <span class="hljs-attr">b31</span>: <span class="hljs-number">4</span>,            <span class="hljs-attr">b32</span>: <span class="hljs-number">5</span>        &#125;    &#125;,    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;</code></pre></div><p>写一个方法进行遍历：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watcher</span>(<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;        observer(obj, key)    &#125;&#125;</code></pre></div><p>将监听写到一个observer方法里，并判断该下面的方法是否是对象，是的话递归调用监听方法，可以监听某对象下的属性</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, prop</span>) </span>&#123;    <span class="hljs-keyword">if</span> (obj &amp;&amp; <span class="hljs-keyword">typeof</span> (obj[prop]) === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;        watcher(obj[prop])    &#125;    <span class="hljs-keyword">var</span> value = obj[prop]    <span class="hljs-built_in">Object</span>.defineProperty(obj, prop, &#123;        <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-keyword">return</span> value        &#125;,        <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;            value = v            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`set <span class="hljs-subst">$&#123;prop&#125;</span> = <span class="hljs-subst">$&#123;v&#125;</span>`</span>);        &#125;    &#125;)&#125;</code></pre></div><p>运行结果如图所示：</p><p><img src="/img/blog/js/o1.png"></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> observer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, prop</span>) </span>&#123;    <span class="hljs-keyword">if</span> (obj &amp;&amp; <span class="hljs-keyword">typeof</span> (obj[prop]) === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;        watcher(obj[prop])    &#125;    <span class="hljs-keyword">var</span> value = obj[prop]    <span class="hljs-built_in">Object</span>.defineProperty(obj, prop, &#123;        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-keyword">return</span> value        &#125;,        <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (v !== value) &#123;                value = v                watcher(v)                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`set <span class="hljs-subst">$&#123;prop&#125;</span> = <span class="hljs-subst">$&#123;v&#125;</span>`</span>);            &#125;        &#125;    &#125;)&#125;<span class="hljs-keyword">var</span> data = &#123;    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">b</span>: &#123;        <span class="hljs-attr">b1</span>: <span class="hljs-number">2</span>,        <span class="hljs-attr">b2</span>: &#123;            <span class="hljs-attr">b31</span>: <span class="hljs-number">4</span>,            <span class="hljs-attr">b32</span>: <span class="hljs-number">5</span>        &#125;    &#125;,    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watcher</span>(<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;        observer(obj, key)    &#125;&#125;watcher(data)data.a = <span class="hljs-string">&#x27;a&#x27;</span>  <span class="hljs-comment">//set c = a</span>data.b.b1 = <span class="hljs-string">&#x27;b&#x27;</span><span class="hljs-comment">// set b1 = b</span>data.b.b2.b31 = <span class="hljs-string">&#x27;b3&#x27;</span><span class="hljs-comment">// set b3 = b3</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data&#x27;</span>, data);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】 使用vue init  webpack 创建项目，打包后在 github.io上无法运行</title>
    <link href="/2021/10/13/%E4%BD%BF%E7%94%A8vue-init-webpack-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%EF%BC%8C%E6%89%93%E5%8C%85%E5%90%8E%E5%9C%A8-github-io%E4%B8%8A%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C/"/>
    <url>/2021/10/13/%E4%BD%BF%E7%94%A8vue-init-webpack-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%EF%BC%8C%E6%89%93%E5%8C%85%E5%90%8E%E5%9C%A8-github-io%E4%B8%8A%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="https://www.cnblogs.com/auto-ajax/p/14051141.html">https://www.cnblogs.com/auto-ajax/p/14051141.html</a></p><p>修改config.index</p><div class="code-wrapper"><pre><code class="hljs js">assetsPublicPath: <span class="hljs-string">&#x27;/&#x27;</span>,</code></pre></div><p>改为</p><div class="code-wrapper"><pre><code class="hljs js">assetsPublicPath: <span class="hljs-string">&#x27;./&#x27;</span>,</code></pre></div><p>修改webpack.prod.conf.js</p><p>在output下增加</p><div class="code-wrapper"><pre><code class="hljs js">publicPath:<span class="hljs-string">&#x27;./&#x27;</span></code></pre></div><p>修改utils.js<br>增加以下代码</p><div class="code-wrapper"><pre><code class="hljs js">publicPath:<span class="hljs-string">&#x27;../../&#x27;</span>,<span class="hljs-keyword">if</span> (options.extract) &#123;  <span class="hljs-keyword">return</span> ExtractTextPlugin.extract(&#123;    <span class="hljs-attr">publicPath</span>:<span class="hljs-string">&#x27;../../&#x27;</span>,    <span class="hljs-attr">use</span>: loaders,    <span class="hljs-attr">fallback</span>: <span class="hljs-string">&#x27;vue-style-loader&#x27;</span>  &#125;)&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 拖选表格: 模拟排班功能</title>
    <link href="/2021/10/12/vue-%E6%8B%96%E9%80%89%E8%A1%A8%E6%A0%BC-%E6%A8%A1%E6%8B%9F%E6%8E%92%E7%8F%AD%E5%8A%9F%E8%83%BD/"/>
    <url>/2021/10/12/vue-%E6%8B%96%E9%80%89%E8%A1%A8%E6%A0%BC-%E6%A8%A1%E6%8B%9F%E6%8E%92%E7%8F%AD%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><h4 id="在线访问-https-wenkil-github-io-drag-table-demo-请使用PC端打开"><a href="#在线访问-https-wenkil-github-io-drag-table-demo-请使用PC端打开" class="headerlink" title="在线访问:   https://wenkil.github.io/drag_table_demo   (请使用PC端打开)"></a>在线访问:   <a href="https://wenkil.github.io/drag_table_demo">https://wenkil.github.io/drag_table_demo</a>   (请使用PC端打开)</h4><h4 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h4><p><img src="/img/blog/drag_table/d1.png"></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;div style=&quot;margin: 30px 0; text-align: right;&quot;&gt;      &lt;el-button @click=&quot;reset&quot; class=&quot;reset-btn&quot;&gt;重置&lt;/el-button&gt;      &lt;!--      &lt;el-button type=&quot;primary&quot; @click=&quot;changeGrid&quot;&gt;确认修改&lt;/el-button&gt;--&gt;    &lt;/div&gt;    &lt;div class=&quot;box&quot; @mousedown=&quot;handleMouseDown&quot;&gt;      &lt;div class=&quot;mask&quot; v-show=&quot;is_show_mask&quot;           :style=&quot;&#x27;width:&#x27;+mask_width+&#x27;left:&#x27;+mask_left+&#x27;height:&#x27;+mask_height+&#x27;top:&#x27;+mask_top&quot;&gt;      &lt;/div&gt;      &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; class=&quot;table&quot;&gt;        &lt;th v-for=&quot;(item,index) in weekEnum&quot; class=&quot;week-data-th&quot; :key=&quot;index&quot;&gt;          &#123;&#123; item &#125;&#125;        &lt;/th&gt;        &lt;tr v-for=&quot;(item,index) in list&quot;&gt;          &lt;td              v-for=&quot;(temp,idx) in item.child&quot;              @click=&quot;handleClickTimeData(temp,index)&quot;              :key=&quot;idx&quot;              class=&quot;week-data-td&quot;              :style=&quot;`background:$&#123;temp.checked?&#x27;#3af&#x27;:&#x27;&#x27;&#125;`&quot;          &gt;            &lt;p&gt;&#123;&#123; temp.val &#125;&#125;&lt;/p&gt;          &lt;/td&gt;        &lt;/tr&gt;      &lt;/table&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  components: &#123;&#125;,  props: &#123;    tHead: &#123;      type: Array,      default: () =&gt; []    &#125;,    tBody: &#123;      type: Array,      default: () =&gt; []    &#125;  &#125;,  data() &#123;    return &#123;      is_show_mask: false,      start_x: 0,      start_y: 0,      end_x: 0,      end_y: 0,      box_screen_left: 0,      box_screen_top: 0,      weekEnum: [        &quot;星期一&quot;,        &quot;星期二&quot;,        &quot;星期三&quot;,        &quot;星期四&quot;,        &quot;星期五&quot;,        &quot;星期六&quot;,        &quot;星期日&quot;      ],      list: [],      tdLength: 30    &#125;;  &#125;,  computed: &#123;    // 框选操作    mask_width() &#123;      return `$&#123;Math.abs(this.end_x - this.start_x)&#125;px;`;    &#125;,    mask_height() &#123;      return `$&#123;Math.abs(this.end_y - this.start_y)&#125;px;`;    &#125;,    mask_left() &#123;      return `$&#123;          Math.min(this.start_x, this.end_x) - this.box_screen_left      &#125;px;`;    &#125;,    mask_top() &#123;      return `$&#123;          Math.min(this.start_y, this.end_y) - this.box_screen_top      &#125;px;`;    &#125;  &#125;,  mounted() &#123;    window.addEventListener(&quot;scroll&quot;, this.windowScroll);//监听页面滚动    this.initTable();    this.initWidth();  &#125;,  beforeDestroy() &#123;    window.removeEventListener(&quot;scroll&quot;, this.windowScroll);  &#125;,  methods: &#123;    initWidth() &#123;      const dom_box = document.querySelector(&quot;.box&quot;);      this.box_screen_left = dom_box.getBoundingClientRect().left;      this.box_screen_top = dom_box.getBoundingClientRect().top;      console.log(&quot;this.box_screen_left&quot;, this.box_screen_left);      console.log(&quot;this.box_screen_top&quot;, this.box_screen_top);    &#125;,    //页面滚动时初始化位置    windowScroll() &#123;      this.resSetXY();      this.initWidth();    &#125;,    initTable() &#123;      let tableList = [...new Array(this.tdLength).keys()];      console.log(&quot;tableList&quot;, tableList);      this.list = tableList.map((item, index) =&gt; &#123;        let temp = Array.from(new Array(7).keys());        console.log(&quot;temp&quot;, temp);        let child = temp.map((v, key) =&gt; &#123;          return &#123;            key: key + index * 7,            val: &quot;&quot;          &#125;;        &#125;);        console.log(&quot;child&quot;, child);        return &#123; child &#125;;      &#125;);      console.log(&quot;this.list&quot;, this.list);    &#125;,    reset() &#123;      let tableList = JSON.parse(JSON.stringify(this.list));      tableList.map((item) =&gt; &#123;        item.child.map((temp) =&gt; &#123;          temp.checked = false;        &#125;);      &#125;);      this.list = tableList;    &#125;,    handleClickTimeData(obj, index) &#123;      let tableList = JSON.parse(JSON.stringify(this.list));      console.log(&quot;tableList&quot;, tableList);      tableList[index].child.map((item) =&gt; &#123;        if (item.key == obj.key) &#123;          item.checked = !item.checked;        &#125;      &#125;);      this.list = tableList;    &#125;,    changeGrid() &#123;      this.handleDomSelect();//选中后的判断,找到框选内的格子      this.resSetXY();//调用此方法让框选消失    &#125;,    handleMouseDown(e) &#123;      console.log(&quot;event&quot;, e);      this.is_show_mask = true;      this.start_x = e.clientX;      this.start_y = e.clientY;      this.end_x = e.clientX;      this.end_y = e.clientY;      window.addEventListener(&quot;mousemove&quot;, this.handleMouseMove);      window.addEventListener(&quot;mouseup&quot;, this.handleMouseUp);    &#125;,    handleMouseMove(event) &#123;      this.end_x = event.clientX;      this.end_y = event.clientY;    &#125;,    handleMouseUp() &#123;      window.removeEventListener(&quot;mousemove&quot;, this.handleMouseMove);      window.removeEventListener(&quot;mouseup&quot;, this.handleMouseUp);      this.changeGrid();    &#125;,    resSetXY() &#123;      this.start_x = 0;      this.start_y = 0;      this.end_x = 0;      this.end_y = 0;    &#125;,    handleDomSelect() &#123;      const dom_mask = window.document.querySelector(&quot;.mask&quot;);      const rect_select = dom_mask.getClientRects()[0];      console.log(&quot;rect_select&quot;, rect_select);      let selectKeys = [];      document.querySelectorAll(&quot;.week-data-td&quot;).forEach((node, index) =&gt; &#123;        const rects = node.getClientRects()[0];        console.log(&quot;rects&quot;, rects);        if (this.collide(rects, rect_select) === true) &#123;          selectKeys.push(index);        &#125;      &#125;);      console.log(&quot;selectKeys&quot;, selectKeys);      if (selectKeys.length &lt; 2) return;      let tableList = JSON.parse(JSON.stringify(this.list));      tableList = tableList.map((item, key) =&gt; &#123;        let child = item.child.map((temp) =&gt; &#123;          if (selectKeys.indexOf(temp.key) &gt; -1) &#123;            temp.checked = !temp.checked;          &#125;          return temp;        &#125;);        return &#123; child &#125;;      &#125;);      this.list = tableList;      console.log(&quot;this.list&quot;, this.list);    &#125;,    collide(rect1, rect2) &#123;      const maxX = Math.max(rect1.x + rect1.width, rect2.x + rect2.width);      const maxY = Math.max(rect1.y + rect1.height, rect2.y + rect2.height);      const minX = Math.min(rect1.x, rect2.x);      const minY = Math.min(rect1.y, rect2.y);      if (maxX - minX &lt;= rect1.width + rect2.width &amp;&amp; maxY - minY &lt;= rect1.height + rect2.height) &#123;        return true;      &#125;      else &#123;        return false;      &#125;    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;td &#123;  width: 300px;  text-align: center;&#125;.box &#123;  width: 100%;  height: auto;  margin: 20px auto;  position: relative;  user-select: none;  .table &#123;    width: 100%;  &#125;  .mask &#123;    position: absolute;    background: #409eff;    opacity: 0.4;  &#125;&#125;.week-data-th &#123;  min-width: 100px;  height: 30px;&#125;.week-data-td &#123;  height: 50px;&#125;&lt;/style&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Element UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于此博客的搭建</title>
    <link href="/2021/10/01/%E5%85%B3%E4%BA%8E%E6%AD%A4%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/10/01/%E5%85%B3%E4%BA%8E%E6%AD%A4%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="搭建背景"><a href="#搭建背景" class="headerlink" title="搭建背景"></a>搭建背景</h3><p>以往记录笔记主要是使用印象笔记这个软件,但作为开发来说还是得有个自己的技术博客之类的网站方便分享和交流,毕竟学习的东西也是通过别人的分享一点点积累起来的。</p><p>写在这里自己可以用到的时候翻一下,也希望自己写的东西能帮助到碰到相同问题的人。</p><p>所有文章都是记录一些开发过程中遇到的问题或者学习中的一些知识点, So : 本站所有文章皆非技术专栏非某技术官方文档, 且有些地方并不会详细介绍, 如有疑惑的地方可以<a href="https://github.com/wenkil">联系我</a>, 如有错误之处还望指点一二。</p><p>部分知识点转载自其他网站,会注明转载地址且标题告知。如果写的内容能帮到眼前的你，请不要吝啬的帮助下一位需要帮助的人 (只要人人都献出一点爱~~~)。</p><p>另外会写一些随笔、吐槽、感悟；总之一句话：一切看心情，自己的网站自己做主~~~😎😎😎</p><h3 id="博客简介"><a href="#博客简介" class="headerlink" title="博客简介"></a>博客简介</h3><h4 id="nbsp-nbsp-nbsp-博客框架：Hexo"><a href="#nbsp-nbsp-nbsp-博客框架：Hexo" class="headerlink" title="&nbsp;&nbsp;&nbsp;  博客框架：Hexo"></a>&nbsp;&nbsp;&nbsp;  博客框架：<a href="https://hexo.io/zh-cn/">Hexo</a></h4><h4 id="nbsp-nbsp-nbsp-博客主题：Fluid-好用-已给Star"><a href="#nbsp-nbsp-nbsp-博客主题：Fluid-好用-已给Star" class="headerlink" title="&nbsp;&nbsp;&nbsp;  博客主题：Fluid(好用,已给Star)"></a>&nbsp;&nbsp;&nbsp;  博客主题：<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>(好用,已给Star)</h4><h4 id="nbsp-nbsp-nbsp-托管平台：Github"><a href="#nbsp-nbsp-nbsp-托管平台：Github" class="headerlink" title="&nbsp;&nbsp;&nbsp;  托管平台：Github"></a>&nbsp;&nbsp;&nbsp;  托管平台：<a href="https://github.com/">Github</a></h4><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><p> 主要参考<a href="https://hexo.io/zh-cn/docs/">Hexo文档</a> 和 <a href="https://www.baidu.com/">啥都有的网站</a>：</p><div class="code-wrapper"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">hexo init my_blog<span class="hljs-built_in">cd</span> my_blognpm install</code></pre></div><p>此时安装完成，但要运行项目需要安装hexo服务：</p><div class="code-wrapper"><pre><code class="hljs pgsql">npm install hexo -<span class="hljs-keyword">server</span> <span class="hljs-comment">--save</span></code></pre></div><p>安装完成之后开始运行项目：</p><div class="code-wrapper"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span> 或者hexo s</code></pre></div><p>此时运行完成，控制台打印以下信息：</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">Hexo is running <span class="hljs-keyword">at</span> <span class="hljs-keyword">http</span>://localhost:<span class="hljs-number">4000</span> . Press Ctrl+C <span class="hljs-built_in">to</span> <span class="hljs-built_in">stop</span>.</code></pre></div><p>在浏览器输入localhost:4000 。恭喜你！你的博客已经在你本地运行成功了！</p><p>接下来，你将要了解和学习的包括但不限于以下内容：</p><ul><li><a href="https://hexo.io/themes/">hexo博客</a> 的使用方法</li><li><a href="https://markdown.com.cn/">markdown</a> 标记语言的学习</li><li>Github 或者 你自己的云服务器 的网站托管流程</li></ul><p>整个搭建过程如果全部写完篇幅较长，且每部分的功能官网都有详细文档，在这写下来也没有意义(所以自称非专栏非官方~~😄😄😄)。如果你也想记录自己的学习历程，可以去学习一下搭建过程，一定会有收获的。奥里给!!!</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>博客</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发环境搭建必装软件</title>
    <link href="/2021/10/01/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%BF%85%E8%A3%85%E8%BD%AF%E4%BB%B6/"/>
    <url>/2021/10/01/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%BF%85%E8%A3%85%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="个人新电脑搭建开发环境常用软件-："><a href="#个人新电脑搭建开发环境常用软件-：" class="headerlink" title="个人新电脑搭建开发环境常用软件 ："></a>个人新电脑搭建开发环境常用软件 ：</h4><h3 id="开发环境："><a href="#开发环境：" class="headerlink" title="开发环境："></a>开发环境：</h3><p>nvm || node</p><p>nginx</p><p>mysql</p><p>git || svn</p><h3 id="必装软件推荐"><a href="#必装软件推荐" class="headerlink" title="必装软件推荐"></a>必装软件推荐</h3><p>Apifox || Postman</p><p>Cursor 、 Webstorm 、 Pycharm</p><p>Beyond Compare 4 (文件对比工具)</p><p>Sourcetree (git图形化应用)</p><p>ssh工具：xterminal  || Xshell || Electerm</p><p>Snipaste（截图工具）</p><p>EmEditor (文本编辑工具)</p><p>SwitchHosts!(host工具)</p><p>7-zip （解压缩软件）</p><p>EV录屏</p><p>VMware Workstation Pro（虚拟机）</p><p>Navicat Premium（链接数据库）</p><p>Fences桌面管理工具</p>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows下安装nginx配置接口转发</title>
    <link href="/2021/09/15/%E9%85%8D%E7%BD%AE%E6%8E%A5%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <url>/2021/09/15/%E9%85%8D%E7%BD%AE%E6%8E%A5%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>前后端联调接口时，需要连接后端大佬本地程序进行联调；有时需求多时，可能会与多个不同地址本地调试，前端每次都得重新配置代理重新运行项目。<br>为了解决快速调试问题，直接在本地起个nginx代理接口转发，这样每个前端项目只需要监听一个端口就可以了，api地址也只需要在nginx配置一次， 简直爽歪歪，谁用谁知道~~~</p><h3 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h3><p>监听自己本地9001端口即可</p><div class="code-wrapper"><pre><code class="hljs vue">proxy: &#123;      [process.env.VUE_APP_BASE_API]: &#123;        target: &quot;http://127.0.0.1:9001&quot;,        changeOrigin: true,        pathRewrite: &#123;          [&#x27;^&#x27; + process.env.VUE_APP_BASE_API]: &#x27;&#x27;        &#125;      &#125;,&#125;</code></pre></div><h3 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h3><p>windows下 的nginx.config 配置  监听9001端口及路由匹配：</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-comment">#user  nobody;</span>worker_processes  <span class="hljs-number">4</span>; 线程数，一般为核数的倍数<span class="hljs-comment">#error_log  logs/error.log;</span><span class="hljs-comment">#error_log  logs/error.log  notice;</span><span class="hljs-comment">#error_log  logs/error.log  info;</span>events &#123;    worker_connections  <span class="hljs-number">1024</span>;  最大连接数默认<span class="hljs-number">1024</span>    multi_accept on;           如果禁用multi_accept，工作进程将一次接受一个新连接。否则，工作进程将一次接受所有新连接。如果使用kqueue连接处理方法，该指令将被忽略，                                因为它报告等待接受的新连接的数量。&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    <span class="hljs-comment">#tcp_nopush     on;</span>    <span class="hljs-comment">#keepalive_timeout  0;</span>    keepalive_timeout  <span class="hljs-number">65</span>;    gzip on;              开启gzip       server &#123;        listen       <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">9001</span>; 监听<span class="hljs-number">9001</span>端口                <span class="hljs-comment">#charset koi8-r;</span>        <span class="hljs-comment">#access_log  logs/host.access.log  main;</span>        以下配置为路由识别：^~ 的意思是匹配符号后面的字段开头的路由                location ^~ <span class="hljs-regexp">/api/</span>admin/adminInfo &#123;            proxy_pass   https:<span class="hljs-regexp">//</span>xxx.xxx.xx;        &#125;        location ^~ <span class="hljs-regexp">/api/</span>admin &#123;            proxy_pass   https:<span class="hljs-regexp">//</span>xxx.xxx.x;        &#125;        location ^~ <span class="hljs-regexp">/api/</span>xtorder &#123;            proxy_pass   http:<span class="hljs-regexp">//</span>xxx.xxx.x;          &#125;        location ^~ <span class="hljs-regexp">/api/</span>edu &#123;            proxy_pass   http:<span class="hljs-regexp">//</span>xxx.xxx.x;        &#125;        location ^~ <span class="hljs-regexp">/api/</span>contract &#123;            proxy_pass   http:<span class="hljs-regexp">//</span>xxx.xxx.x;        &#125;        <span class="hljs-comment">#error_page  404              /404.html;</span>        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;        location = /<span class="hljs-number">50</span>x.html &#123;            root   html;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Element Table 自定义表格横向展示</title>
    <link href="/2021/06/16/Element-Table-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E6%A0%BC%E6%A8%AA%E5%90%91%E5%B1%95%E7%A4%BA/"/>
    <url>/2021/06/16/Element-Table-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E6%A0%BC%E6%A8%AA%E5%90%91%E5%B1%95%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><h3 id="支持自定义：展示列数"><a href="#支持自定义：展示列数" class="headerlink" title="支持自定义：展示列数"></a>支持自定义：展示列数</h3><p><img src="/img/blog/element/transverse-table1.png"></p><h3 id="超出多行时：隐藏多余格子"><a href="#超出多行时：隐藏多余格子" class="headerlink" title="超出多行时：隐藏多余格子"></a>超出多行时：隐藏多余格子</h3><p><img src="/img/blog/element/transverse-table2.png"></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="1-npm安装方式"><a href="#1-npm安装方式" class="headerlink" title="1. npm安装方式"></a>1. npm安装方式</h3><p>npm 包地址： <a href="https://www.npmjs.com/package/wenkil-transverse-table">https://www.npmjs.com/package/wenkil-transverse-table</a></p><div class="code-wrapper"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> wenkil-transverse-<span class="hljs-selector-tag">table</span></code></pre></div><p>项目中需要使用以下方式引入element-ui和样式</p><div class="code-wrapper"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app-container&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">TransverseTable</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;transverseTable&quot;</span>  <span class="hljs-attr">:tableData</span>=<span class="hljs-string">&quot;[</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">            </span></span></span><span class="xquery"><span class="hljs-built_in">&#123;key</span>:<span class="hljs-string">&#x27;test&#x27;</span>,value: <span class="hljs-number">1</span>&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">            </span></span></span><span class="xquery"><span class="hljs-built_in">&#123;key</span>:<span class="hljs-string">&#x27;test&#x27;</span>,value: <span class="hljs-number">1</span>&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">            </span></span></span><span class="xquery"><span class="hljs-built_in">&#123;key</span>:<span class="hljs-string">&#x27;test&#x27;</span>,value: <span class="hljs-number">1</span>&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">            </span></span></span><span class="xquery"><span class="hljs-built_in">&#123;key</span>:<span class="hljs-string">&#x27;test&#x27;</span>,value: <span class="hljs-number">1</span>&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">            </span></span></span><span class="xquery"><span class="hljs-built_in">&#123;key</span>:<span class="hljs-string">&#x27;test&#x27;</span>,value: <span class="hljs-number">1</span>&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">            </span></span></span><span class="xquery"><span class="hljs-built_in">&#123;key</span>:<span class="hljs-string">&#x27;test&#x27;</span>,value: <span class="hljs-number">1</span>&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml"></span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml"></span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">          ]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TransverseTable</span>&gt;</span></span><span class="xml"></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/template&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><span class="javascript"><span class="xml">  <span class="hljs-keyword">import</span> Element <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-ui&quot;</span>;</span></span><span class="javascript"><span class="xml">  <span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span></span><span class="javascript"><span class="xml">  <span class="hljs-keyword">import</span> TransverseTable <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;wenkil-transverse-table&#x27;</span></span></span><span class="javascript"><span class="xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> </span></span><span class="xquery">&#123;</span><span class="xquery">   <span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;test&quot;</span>,</span><span class="xquery">    components: &#123;TransverseTable&#125;</span><span class="xml">,</span><span class="xml">    data() </span><span class="xquery">&#123;</span><span class="xquery">      <span class="hljs-keyword">return</span> &#123;&#125;</span><span class="xml"></span><span class="xml">    &#125;,</span><span class="xml">    created() </span><span class="xquery">&#123;</span><span class="xquery"></span><span class="xquery">    &#125;</span><span class="xml">,</span><span class="xml">    mounted() </span><span class="xquery">&#123;</span><span class="xquery">      this.<span class="hljs-variable">$refs</span>.transverseTable.setTable()</span><span class="xquery">    &#125;</span><span class="xml">,</span><span class="xml">    methods: </span><span class="xquery">&#123;&#125;</span><span class="xml">,</span><span class="xml">  &#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>&lt;style scoped&gt;&lt;/style&gt;</code></pre></div><h3 id="2-组件方式"><a href="#2-组件方式" class="headerlink" title="2. 组件方式"></a>2. 组件方式</h3><p>在项目里自定义组件目录,写入以下代码</p><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-table</span></span></span><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">border</span></span></span><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;tableList&quot;</span></span></span><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">:show-header</span>=<span class="hljs-string">&quot;false&quot;</span></span></span><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">:cell-style</span>=<span class="hljs-string">&quot;cellStyle&quot;</span></span></span><span class="hljs-tag"><span class="xml">    &gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">min-width</span>=<span class="hljs-string">&quot;50&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in headList&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.prop&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">:label</span>=<span class="hljs-string">&quot;item.prop&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">:prop</span>=<span class="hljs-string">&quot;item.prop&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span></span></span><span class="hljs-tag"><span class="xml">      &gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;&#123; row &#125;&quot;</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">row</span>[item.prop] &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-table</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml"></span><span class="xml"></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><span class="javascript"><span class="xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="javascript"><span class="xml">    <span class="hljs-attr">components</span>: &#123;&#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-attr">props</span>: &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">tableData</span>: &#123; <span class="hljs-comment">//传进key value格式的数组</span></span></span><span class="javascript"><span class="xml">        <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>,</span></span><span class="javascript"><span class="xml">        <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">return</span> []</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">      &#125;,</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">columnNum</span>: &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span>,</span></span><span class="javascript"><span class="xml">        <span class="hljs-attr">default</span>: <span class="hljs-number">6</span></span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">return</span> &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-attr">tableList</span>: [],</span></span><span class="javascript"><span class="xml">        <span class="hljs-attr">headList</span>: [],</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-attr">methods</span>: &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-function"><span class="hljs-title">setTable</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.tableList = []</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.headList = []</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.columnNum; i++) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-built_in">this</span>.headList.push(</span></span><span class="javascript"><span class="xml">            &#123;<span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;key&#x27;</span> + (i + <span class="hljs-number">1</span>)&#125;,</span></span><span class="javascript"><span class="xml">            &#123;<span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;value&#x27;</span> + (i + <span class="hljs-number">1</span>)&#125;</span></span><span class="javascript"><span class="xml">          )</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> newArr = [];</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.tableData.length; i += <span class="hljs-built_in">this</span>.columnNum) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">let</span> temp = <span class="hljs-built_in">this</span>.tableData.slice(i, i + <span class="hljs-built_in">this</span>.columnNum)</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">if</span> (temp.length &lt; <span class="hljs-built_in">this</span>.columnNum) &#123;</span></span><span class="javascript"><span class="xml">            <span class="hljs-keyword">let</span> d = temp.length</span></span><span class="javascript"><span class="xml">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.columnNum - d; i++) &#123;</span></span><span class="javascript"><span class="xml">              temp.push(&#123;</span></span><span class="javascript"><span class="xml">                <span class="hljs-attr">key</span>:<span class="hljs-literal">undefined</span>,</span></span><span class="javascript"><span class="xml">                <span class="hljs-attr">value</span>:<span class="hljs-literal">undefined</span></span></span><span class="javascript"><span class="xml">              &#125;)</span></span><span class="javascript"><span class="xml">            &#125;</span></span><span class="javascript"><span class="xml">          &#125;</span></span><span class="javascript"><span class="xml">          newArr.push(temp);</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">let</span> tempArr = []</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; newArr.length; i++) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span></span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">let</span> temp = &#123;&#125;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> newArr[i]) &#123;</span></span><span class="javascript"><span class="xml">            temp[<span class="hljs-string">&#x27;key&#x27;</span> + index] = item.key</span></span><span class="javascript"><span class="xml">            temp[<span class="hljs-string">&#x27;value&#x27;</span> + index] = item.value</span></span><span class="javascript"><span class="xml">            index++</span></span><span class="javascript"><span class="xml">          &#125;</span></span><span class="javascript"><span class="xml">          tempArr.push(temp)</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.tableList = tempArr</span></span><span class="javascript"><span class="xml">      &#125;,</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">      <span class="hljs-function"><span class="hljs-title">cellStyle</span>(<span class="hljs-params">&#123;row, column, rowIndex, columnIndex&#125;</span>)</span> &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span> (row[column.property] != <span class="hljs-number">0</span> &amp;&amp; !row[column.property]) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">return</span> &#123;</span></span><span class="javascript"><span class="xml">            <span class="hljs-attr">visibility</span>: <span class="hljs-string">&#x27;hidden&#x27;</span></span></span><span class="javascript"><span class="xml">          &#125;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span> (columnIndex % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">return</span> &#123;</span></span><span class="javascript"><span class="xml">            <span class="hljs-attr">background</span>: <span class="hljs-string">&#x27;#f0f0f0&#x27;</span></span></span><span class="javascript"><span class="xml">          &#125;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">  &#125;</span></span><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css"></span></span><span class="css"><span class="xml">  /deep/ <span class="hljs-selector-class">.el-table--group</span><span class="hljs-selector-pseudo">::after</span>, <span class="hljs-selector-class">.el-table--border</span><span class="hljs-selector-pseudo">::after</span>, <span class="hljs-selector-class">.el-table</span><span class="hljs-selector-pseudo">::before</span> &#123;</span></span><span class="css"><span class="xml">    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span></span><span class="css"><span class="xml">    <span class="hljs-attribute">border</span>: none <span class="hljs-meta">!important</span>;</span></span><span class="css"><span class="xml">    <span class="hljs-attribute">background-color</span>: transparent <span class="hljs-meta">!important</span>;</span></span><span class="css"><span class="xml">  &#125;</span></span><span class="css"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></code></pre></div><p>使用时：</p><div class="code-wrapper"><pre><code class="hljs dust"><span class="xml">import TransverseTable from &quot;@/components/TransverseTable&quot;;</span><span class="xml"></span><span class="xml">components:</span><span class="hljs-template-variable">&#123;TransverseTable&#125;</span><span class="xml"></span><span class="xml"></span><span class="xml"></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">transverse-table</span></span></span><span class="hljs-tag"><span class="xml">  <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;transverseTable&quot;</span></span></span><span class="hljs-tag"><span class="xml">  <span class="hljs-attr">:columnNum</span>=<span class="hljs-string">&quot;4&quot;</span></span></span><span class="hljs-tag"><span class="xml">  <span class="hljs-attr">:tableData</span>=<span class="hljs-string">&quot;[</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">  </span></span></span><span class="hljs-template-variable">&#123;key:&#x27;测试&#x27;,value: 1&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">  </span></span></span><span class="hljs-template-variable">&#123;key:&#x27;测试&#x27;,value: 1&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">  </span></span></span><span class="hljs-template-variable">&#123;key:&#x27;测试&#x27;,value: 1&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">  </span></span></span><span class="hljs-template-variable">&#123;key:&#x27;测试&#x27;,value: 1&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">  </span></span></span><span class="hljs-template-variable">&#123;key:&#x27;测试&#x27;,value: 1&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">  </span></span></span><span class="hljs-template-variable">&#123;key:&#x27;测试&#x27;,value: 1&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">  </span></span></span><span class="hljs-template-variable">&#123;key:&#x27;测试&#x27;,value: 1&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="xml">  </span></span></span><span class="hljs-template-variable">&#123;key:&#x27;测试&#x27;,value: 1&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,]&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">transverse-table</span>&gt;</span></span><span class="xml"></span><span class="xml"></span><span class="xml">在父组件里,动态获取数据时需要调用下this.$refs.transverseTable.setTable() 来渲染数据</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Element UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Element UI 自定义下拉框组件</title>
    <link href="/2021/06/09/Element-UI-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8B%E6%8B%89%E6%A1%86%E7%BB%84%E4%BB%B6/"/>
    <url>/2021/06/09/Element-UI-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8B%E6%8B%89%E6%A1%86%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p>支持全选反选，及模糊搜索</p><p><img src="/img/blog/element/self_select.png"></p><h3 id="组件源码"><a href="#组件源码" class="headerlink" title="组件源码"></a>组件源码</h3><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-select</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;subjectSelect&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;subjectNameIds&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;hideSelect&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:100%&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">multiple</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;selectKeys&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">value-key</span>=<span class="hljs-string">&quot;id&quot;</span></span></span><span class="hljs-tag"><span class="xml">        @<span class="hljs-attr">click.native</span>=<span class="hljs-string">&quot;subjectSelectClick&quot;</span></span></span><span class="hljs-tag"><span class="xml">        @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;subjectChange&quot;</span></span></span><span class="hljs-tag"><span class="xml">    &gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-option</span></span></span><span class="hljs-tag"><span class="xml">          <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in copy_subjectTypeList&quot;</span></span></span><span class="hljs-tag"><span class="xml">          <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span></span></span><span class="hljs-tag"><span class="xml">          <span class="hljs-attr">:label</span>=<span class="hljs-string">&quot;item.name&quot;</span></span></span><span class="hljs-tag"><span class="xml">          <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;item.id&quot;</span></span></span><span class="hljs-tag"><span class="xml">      &gt;</span></span><span class="xml">        </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.name</span> &#125;&#125;</span><span class="xml"></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-option</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-select</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-popover</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;popover&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">placement</span>=<span class="hljs-string">&quot;bottom&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">trigger</span>=<span class="hljs-string">&quot;manual&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;popShow&quot;</span></span></span><span class="hljs-tag"><span class="xml">    &gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;close-btn&quot;</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span></span></span><span class="hljs-tag"><span class="xml">            <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;mini&quot;</span></span></span><span class="hljs-tag"><span class="xml">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span></span></span><span class="hljs-tag"><span class="xml">            @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;subjectSelectClick&quot;</span></span></span><span class="hljs-tag"><span class="xml">        &gt;</span>关闭</span><span class="xml">        &lt;/el-button</span><span class="xml">        &gt;</span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"></span><span class="xml"></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;poper__head&quot;</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;checkBoxTitle&quot;</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">el-checkbox</span></span></span><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;hideCheckBox&quot;</span></span></span><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">:indeterminate</span>=<span class="hljs-string">&quot;isIndeterminate&quot;</span></span></span><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkAll&quot;</span></span></span><span class="hljs-tag"><span class="xml">              @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handleCheckAllChange&quot;</span></span></span><span class="hljs-tag"><span class="xml">          &gt;</span>全选</span><span class="xml">          &lt;/el-checkbox</span><span class="xml">          &gt;</span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span></span></span><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入关键字模糊搜索&quot;</span></span></span><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;subject_name&quot;</span></span></span><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-with-select&quot;</span></span></span><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">clearable</span></span></span><span class="hljs-tag"><span class="xml">          &gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span></span></span><span class="hljs-tag"><span class="xml">                <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;append&quot;</span></span></span><span class="hljs-tag"><span class="xml">                <span class="hljs-attr">icon</span>=<span class="hljs-string">&quot;el-icon-search&quot;</span></span></span><span class="hljs-tag"><span class="xml">                @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;searchSubjectName&quot;</span></span></span><span class="hljs-tag"><span class="xml">            &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;popChild&quot;</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">el-checkbox-group</span></span></span><span class="hljs-tag"><span class="xml">            <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;hideCheckBox&quot;</span></span></span><span class="hljs-tag"><span class="xml">            <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedSubjects&quot;</span></span></span><span class="hljs-tag"><span class="xml">            @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handleCheckedCitiesChange&quot;</span></span></span><span class="hljs-tag"><span class="xml">        &gt;</span></span><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">el-checkbox</span></span></span><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in copy_subjectTypeList&quot;</span></span></span><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">:label</span>=<span class="hljs-string">&quot;item.id&quot;</span></span></span><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span></span></span><span class="hljs-tag"><span class="xml">          &gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.name</span> &#125;&#125;</span><span class="xml"></span><span class="xml">          &lt;/el-checkbox</span><span class="xml">          &gt;</span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">el-checkbox-group</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-popover</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml"></span><span class="xml"></span><span class="xml"></span><span class="xml"></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="javascript"><span class="xml">  <span class="hljs-attr">props</span>: &#123;</span></span><span class="javascript"><span class="xml">    <span class="hljs-attr">subjectTypeList</span>: &#123; <span class="hljs-comment">//传入的可筛选数组</span></span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Array</span>,</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">default</span>: []</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-attr">hideSelect</span>: &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Boolean</span>,</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">default</span>: <span class="hljs-literal">false</span></span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-attr">hideCheckBox</span>: &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Boolean</span>,</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">default</span>: <span class="hljs-literal">false</span></span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-attr">panelTitle</span>: &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;请选择数据&quot;</span></span></span><span class="javascript"><span class="xml">    &#125;</span></span><span class="javascript"><span class="xml">  &#125;,</span></span><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">    <span class="hljs-keyword">return</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">alreadySelectList</span>: [],<span class="hljs-comment">//已经选中的数据,编辑时展示</span></span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">copy_subjectTypeList</span>: [],<span class="hljs-comment">//复制的可筛选数组,子组件不可直接更改父组件传来的值</span></span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">subjectNameIds</span>: [],<span class="hljs-comment">//当前选中的科目</span></span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">primeSubjectTypeList</span>: [],</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">selectKeys</span>: <span class="hljs-number">1</span>,</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">checkAll</span>: <span class="hljs-literal">false</span>,</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">isIndeterminate</span>: <span class="hljs-literal">false</span>,</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">checkedSubjects</span>: [], <span class="hljs-comment">//当前勾选的复选框</span></span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">subject_name</span>: <span class="hljs-string">&quot;&quot;</span>,</span></span><span class="javascript"><span class="xml">      <span class="hljs-attr">popShow</span>: <span class="hljs-literal">false</span></span></span><span class="javascript"><span class="xml">    &#125;;</span></span><span class="javascript"><span class="xml">  &#125;,</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">  <span class="hljs-attr">watch</span>: &#123;</span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">subjectTypeList</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.copy_subjectTypeList = <span class="hljs-built_in">this</span>.subjectTypeList.concat();</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.primeSubjectTypeList = <span class="hljs-built_in">this</span>.subjectTypeList.concat();</span></span><span class="javascript"><span class="xml">    &#125;</span></span><span class="javascript"><span class="xml">  &#125;,</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">  &#125;,</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">    <span class="hljs-built_in">this</span>.initSelectAndPanel();</span></span><span class="javascript"><span class="xml">    <span class="hljs-built_in">this</span>.$refs.popover.$refs.popper.style.width = <span class="hljs-built_in">this</span>.$el.clientWidth + <span class="hljs-string">&quot;px&quot;</span>;</span></span><span class="javascript"><span class="xml">  &#125;,</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">    <span class="hljs-comment">//子组件需要每次操作后向父级传递选中科目</span></span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">emitParent</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;selectData&quot;</span>, <span class="hljs-built_in">this</span>.subjectNameIds);</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">    <span class="hljs-comment">//初始化当前下拉框和复选框</span></span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">initSelectAndPanel</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.subject_name = <span class="hljs-string">&quot;&quot;</span>;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.checkAll = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.isIndeterminate = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.popShow = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.checkedSubjects = [];</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.subjectNameIds = [];</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.copy_subjectTypeList = [];</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.primeSubjectTypeList = [];</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.updateSelectCompoment([]);</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">    <span class="hljs-comment">//设置当前已经选中的数据,仅作展示</span></span></span><span class="javascript"><span class="xml">    <span class="hljs-comment">// (当前逻辑编辑时不可修改,如需编辑时可修改需要变动当前页面逻辑和调用逻辑)</span></span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">setSelfAlreadySelect</span>(<span class="hljs-params">list</span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.subjectNameIds = list;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">let</span> test = <span class="hljs-built_in">this</span>.copy_subjectTypeList.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">return</span> item.id == list[<span class="hljs-number">0</span>];</span></span><span class="javascript"><span class="xml">      &#125;);</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.$forceUpdate();</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">subjectChange</span>(<span class="hljs-params">val</span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.checkedSubjects = val;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.handleCheckedCitiesChange(<span class="hljs-built_in">this</span>.subjectNameIds);</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-comment">//点击下拉框时打开pop框</span></span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">subjectSelectClick</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.hideSelect) &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.subject_name = <span class="hljs-string">&quot;&quot;</span>;</span></span><span class="javascript"><span class="xml">        <span class="hljs-comment">//只有新增时才可显示</span></span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.$refs.subjectSelect.blur();</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.popShow = !<span class="hljs-built_in">this</span>.popShow;</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-comment">//每此点击复选框的时候判断:全选按钮显示逻辑和下拉框选项合并逻辑</span></span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">handleCheckedCitiesChange</span>(<span class="hljs-params">value</span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.subjectNameIds = value;</span></span><span class="javascript"><span class="xml">      <span class="hljs-comment">//如果当前下拉框里的列表选项已被全部选择: 全选为true，否则为false</span></span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">let</span> ids = <span class="hljs-built_in">this</span>.subjectNameIds.sort();</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">let</span> list = <span class="hljs-built_in">this</span>.copy_subjectTypeList.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">return</span> a.id &gt; b.id;</span></span><span class="javascript"><span class="xml">      &#125;);</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">if</span> (</span></span><span class="javascript"><span class="xml">          value.length &gt; <span class="hljs-number">0</span> &amp;&amp;</span></span><span class="javascript"><span class="xml">          (value.length &gt; <span class="hljs-built_in">this</span>.copy_subjectTypeList.length ||</span></span><span class="javascript"><span class="xml">              value.length == <span class="hljs-built_in">this</span>.copy_subjectTypeList.length)</span></span><span class="javascript"><span class="xml">      ) &#123;</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">let</span> temp = <span class="hljs-number">0</span>;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ids.length; i++) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">let</span> Index = list.findIndex(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;</span></span><span class="javascript"><span class="xml">            <span class="hljs-keyword">return</span> item.id === ids[i];</span></span><span class="javascript"><span class="xml">          &#125;);</span></span><span class="javascript"><span class="xml">          temp = Index &gt;= <span class="hljs-number">0</span> ? (temp += <span class="hljs-number">1</span>) : temp;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">        <span class="hljs-comment">// console.log(&quot;相同的数量&quot;, temp);</span></span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span> (temp &gt; <span class="hljs-number">0</span>) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">if</span> (list.length == temp) &#123;</span></span><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.checkAll = <span class="hljs-literal">true</span>;</span></span><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.isIndeterminate = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">          &#125;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">else</span> &#123;</span></span><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.checkAll = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.isIndeterminate = <span class="hljs-literal">true</span>;</span></span><span class="javascript"><span class="xml">          &#125;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">else</span> &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-built_in">this</span>.checkAll = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (</span></span><span class="javascript"><span class="xml">          value.length &gt; <span class="hljs-number">0</span> &amp;&amp;</span></span><span class="javascript"><span class="xml">          value.length &lt; <span class="hljs-built_in">this</span>.copy_subjectTypeList.length</span></span><span class="javascript"><span class="xml">      ) &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-comment">//判断剩余的选项里有咩有列表里的元素</span></span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">let</span> temp = <span class="hljs-number">0</span>;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ids.length; i++) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">let</span> Index = list.findIndex(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;</span></span><span class="javascript"><span class="xml">            <span class="hljs-keyword">return</span> item.id === ids[i];</span></span><span class="javascript"><span class="xml">          &#125;);</span></span><span class="javascript"><span class="xml">          temp = Index &gt;= <span class="hljs-number">0</span> ? (temp += <span class="hljs-number">1</span>) : temp;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.isIndeterminate = temp &gt; <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">else</span> &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-comment">// console.log(&quot;选项里没有数据&quot;);</span></span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.isIndeterminate = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.checkAll = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.emitParent();</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.$forceUpdate();</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-comment">//模糊搜索科目,每次都从primeSubjectTypeList列表里搜</span></span></span><span class="javascript"><span class="xml">    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">searchSubjectName</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.subject_name != <span class="hljs-string">&quot;&quot;</span>) &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.copy_subjectTypeList = <span class="hljs-built_in">this</span>.fuzzySearch(</span></span><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.subject_name,</span></span><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.primeSubjectTypeList</span></span><span class="javascript"><span class="xml">        );</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.copy_subjectTypeList.length == <span class="hljs-number">0</span>) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-built_in">this</span>.isIndeterminate = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">          <span class="hljs-built_in">this</span>.checkAll = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">else</span> &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-built_in">this</span>.checkSubjectList();</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">else</span> &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.copy_subjectTypeList = <span class="hljs-built_in">this</span>.primeSubjectTypeList; <span class="hljs-comment">//直接显示原始数据,不需要再次向服务器请求</span></span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.checkSubjectList();</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-comment">//每次搜索出结果进行比对：检测两个数组显示反选全选的显示</span></span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">checkSubjectList</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-comment">//需要判断当前已选择的和下拉框里的数组进行比较，用来显示全选按钮的状态</span></span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">let</span> ids = <span class="hljs-built_in">this</span>.subjectNameIds.sort();</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">let</span> list = <span class="hljs-built_in">this</span>.copy_subjectTypeList.sort();</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">let</span> temp = <span class="hljs-number">0</span>;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ids.length; i++) &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">let</span> Index = list.findIndex(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">return</span> item.id === ids[i];</span></span><span class="javascript"><span class="xml">        &#125;);</span></span><span class="javascript"><span class="xml">        temp = Index &gt;= <span class="hljs-number">0</span> ? (temp += <span class="hljs-number">1</span>) : temp;</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">      <span class="hljs-comment">//默认将两个bool设置成false,根据结果设置不同显示</span></span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.isIndeterminate = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.checkAll = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">if</span> (ids.length &gt; list.length || ids.length == list.length) &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span> (temp &gt; <span class="hljs-number">0</span> &amp;&amp; list.length == temp) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-comment">// console.log(&quot;完全包含列表里所有选项&quot;);</span></span></span><span class="javascript"><span class="xml">          <span class="hljs-built_in">this</span>.checkAll = <span class="hljs-literal">true</span>;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp &gt; <span class="hljs-number">0</span> &amp;&amp; list.length != temp) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-comment">// console.log(&quot;不完全包含列表里的选项&quot;);</span></span></span><span class="javascript"><span class="xml">          <span class="hljs-built_in">this</span>.isIndeterminate = <span class="hljs-literal">true</span>;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">else</span> &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span> (temp &gt; <span class="hljs-number">0</span>) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-built_in">this</span>.isIndeterminate = <span class="hljs-literal">true</span>;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">fuzzySearch</span>(<span class="hljs-params">str, container</span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> newList = [];</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> startChar = str.charAt(<span class="hljs-number">0</span>);</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">var</span> strLen = str.length;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; container.length; i++) &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> obj = container[i];</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> isMatch = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> obj) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">var</span> curItem = <span class="hljs-string">&quot;&quot;</span>;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">if</span> (obj[p] != <span class="hljs-literal">null</span>) &#123;</span></span><span class="javascript"><span class="xml">            curItem = obj[p];</span></span><span class="javascript"><span class="xml">          &#125;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; curItem.length; j++) &#123;</span></span><span class="javascript"><span class="xml">            <span class="hljs-keyword">if</span> (curItem.charAt(j) == startChar) &#123;</span></span><span class="javascript"><span class="xml">              <span class="hljs-keyword">if</span> (curItem.substring(j).substring(<span class="hljs-number">0</span>, strLen) == str) &#123;</span></span><span class="javascript"><span class="xml">                isMatch = <span class="hljs-literal">true</span>;</span></span><span class="javascript"><span class="xml">                <span class="hljs-keyword">break</span>;</span></span><span class="javascript"><span class="xml">              &#125;</span></span><span class="javascript"><span class="xml">            &#125;</span></span><span class="javascript"><span class="xml">          &#125;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span> (isMatch) &#123;</span></span><span class="javascript"><span class="xml">          newList.push(obj);</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">return</span> newList;</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">handleCheckAllChange</span>(<span class="hljs-params">val</span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">let</span> ids = <span class="hljs-built_in">this</span>.copy_subjectTypeList.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">return</span> item.id;</span></span><span class="javascript"><span class="xml">      &#125;);</span></span><span class="javascript"><span class="xml">      <span class="hljs-comment">//如果是全选需要将已保存的和下拉框里的合并去重</span></span></span><span class="javascript"><span class="xml">      <span class="hljs-comment">//如果是反选,需要将已选的数组进行判断是否有下拉框里的数组，有的话直接移除</span></span></span><span class="javascript"><span class="xml">      <span class="hljs-comment">// console.log(&quot;当前是否是全选&quot;, this.checkAll);</span></span></span><span class="javascript"><span class="xml">      <span class="hljs-comment">// console.log(&quot;当前下拉框里的数组&quot;, ids);</span></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.checkAll) &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-comment">//去重显示合并后的数组</span></span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">let</span> newArr = [];</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">this</span>.subjectNameIds.concat(ids).sort();</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">if</span> (newArr.indexOf(arr[i]) &lt; <span class="hljs-number">0</span>) &#123;</span></span><span class="javascript"><span class="xml">            newArr.push(arr[i]);</span></span><span class="javascript"><span class="xml">          &#125;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">        <span class="hljs-comment">// console.log(&quot;去重显示合并后的数组&quot;, newArr);</span></span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.subjectNameIds = newArr;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.checkedSubjects = newArr;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.isIndeterminate = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">else</span> &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">let</span> temp = [];</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>.subjectNameIds) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-keyword">if</span> (ids.indexOf(<span class="hljs-built_in">this</span>.subjectNameIds[i]) &lt; <span class="hljs-number">0</span>) &#123;</span></span><span class="javascript"><span class="xml">            temp.push(<span class="hljs-built_in">this</span>.subjectNameIds[i]);</span></span><span class="javascript"><span class="xml">          &#125;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">        <span class="hljs-comment">// console.log(&quot;不相同的元素&quot;, temp);</span></span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.subjectNameIds = temp;</span></span><span class="javascript"><span class="xml">        <span class="hljs-comment">//如果是取消全选，清空下拉框的数据，再重新渲染下拉组件，否则下拉框不显示选项文字</span></span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.updateSelectCompoment(temp);</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.subject_name != <span class="hljs-string">&quot;&quot;</span>) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-built_in">this</span>.copy_subjectTypeList = <span class="hljs-built_in">this</span>.primeSubjectTypeList;</span></span><span class="javascript"><span class="xml">          <span class="hljs-built_in">this</span>.subject_name = <span class="hljs-string">&quot;&quot;</span>;</span></span><span class="javascript"><span class="xml">          <span class="hljs-built_in">this</span>.handleCheckedCitiesChange(<span class="hljs-built_in">this</span>.subjectNameIds);</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span> (temp.length == <span class="hljs-number">0</span>) &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-built_in">this</span>.isIndeterminate = <span class="hljs-literal">false</span>;</span></span><span class="javascript"><span class="xml">        &#125;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.checkedSubjects = temp;</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.emitParent();</span></span><span class="javascript"><span class="xml">      <span class="hljs-built_in">this</span>.$forceUpdate();</span></span><span class="javascript"><span class="xml">      <span class="hljs-comment">// console.log(&#x27;当前选中的科目提交给父级&#x27;,this.subjectNameIds)</span></span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">updateSelectCompoment</span>(<span class="hljs-params">temp</span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$refs.subjectSelect) &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.$refs.subjectSelect.cachedOptions = temp;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.$refs.subjectSelect.selected = temp;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.selectKeys += <span class="hljs-number">1</span>;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.$forceUpdate();</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">    &#125;</span></span><span class="javascript"><span class="xml">  &#125;</span></span><span class="javascript"><span class="xml">&#125;;</span></span><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"></span><span class="xml"></span><span class="xml"></span><span class="xml"></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css"></span></span><span class="css"><span class="xml"><span class="hljs-selector-class">.close-btn</span> &#123;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">direction</span>: rtl;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">15px</span>;</span></span><span class="css"><span class="xml">&#125;</span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"><span class="hljs-selector-class">.poper__head</span> &#123;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">display</span>: flex;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">flex-wrap</span>: wrap;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">align-items</span>: center;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">justify-content</span>: space-between;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">flex-direction</span>: row;</span></span><span class="css"><span class="xml">&#125;</span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"><span class="hljs-selector-class">.popChild</span> &#123;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">max-height</span>: <span class="hljs-number">300px</span>;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">overflow-y</span>: scroll;</span></span><span class="css"><span class="xml">&#125;</span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml">/deep/ <span class="hljs-selector-class">.el-select__tags</span> &#123;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">max-height</span>: <span class="hljs-number">400px</span>;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">overflow-y</span>: auto;</span></span><span class="css"><span class="xml">&#125;</span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml">/deep/ <span class="hljs-selector-class">.el-checkbox</span> &#123;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">26px</span>;</span></span><span class="css"><span class="xml">&#125;</span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml">/deep/ <span class="hljs-selector-class">.el-checkbox-group</span> &#123;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">display</span>: flex;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">flex-direction</span>: column;</span></span><span class="css"><span class="xml">&#125;</span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml">/deep/ <span class="hljs-selector-class">.el-tag</span><span class="hljs-selector-class">.el-tag--info</span> &#123;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">540px</span>;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">height</span>: auto;</span></span><span class="css"><span class="xml">&#125;</span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml">/deep/ <span class="hljs-selector-class">.el-select__tags-text</span> &#123;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">540px</span>;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">white-space</span>: normal;</span></span><span class="css"><span class="xml">&#125;</span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml">/deep/ <span class="hljs-selector-class">.el-input__inner</span> &#123;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">height</span>: auto;</span></span><span class="css"><span class="xml">&#125;</span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"></span></span><span class="css"><span class="xml"><span class="hljs-selector-class">.checkBoxTitle</span> &#123;</span></span><span class="css"><span class="xml">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;</span></span><span class="css"><span class="xml">&#125;</span></span><span class="css"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></code></pre></div><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>调用该组件的脚本：<br><del>需要手动修改下拉框展示样式，否则下拉框和pop框宽度不一致。</del><br>如果是编辑时需要展示数据,则调用this.$refs.xxxx.setSelfAlreadySelect(list) ,传入要展示的数据id数组</p><div class="code-wrapper"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app-container&quot;</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">el-form</span> <span class="hljs-attr">inline</span>&gt;</span></span><span class="xml">            </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label-width</span>=<span class="hljs-string">&quot;80&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;测试&quot;</span>&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">SelectComponent</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 380px&quot;</span> <span class="hljs-attr">:subjectTypeList</span>=<span class="hljs-string">&quot;list&quot;</span> @<span class="hljs-attr">selectData</span>=<span class="hljs-string">&quot;selectData&quot;</span>/&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span></span><span class="xml"></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">el-form</span>&gt;</span></span><span class="xml"></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/template&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> SelectComponent <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./select-pop.vue&#x27;</span></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> </span></span><span class="xquery">&#123;</span><span class="xquery"> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;index2&#x27;</span>,</span><span class="xquery">  components: &#123; SelectComponent &#125;</span><span class="xml">,</span><span class="xml">  data()</span><span class="xquery">&#123;</span><span class="xquery">    <span class="hljs-keyword">return</span>&#123;</span><span class="xquery">      list:[]</span><span class="xquery">    &#125;</span><span class="xml"></span><span class="xml">  &#125;,</span><span class="xml"></span><span class="xml">  created() </span><span class="xquery">&#123;&#125;</span><span class="xml">,</span><span class="xml"></span><span class="xml">  mounted() </span><span class="xquery">&#123;</span><span class="xquery">    this.list = [</span><span class="xquery">     <span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">1</span><span class="hljs-built_in">,name</span>:<span class="hljs-string">&#x27;测试&#x27;</span>&#125;</span><span class="xml">,</span><span class="xml">     </span><span class="xquery"><span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">2</span><span class="hljs-built_in">,name</span>:<span class="hljs-string">&#x27;测试1&#x27;</span>&#125;</span><span class="xml">,</span><span class="xml">     </span><span class="xquery"><span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">3</span><span class="hljs-built_in">,name</span>:<span class="hljs-string">&#x27;测试2&#x27;</span>&#125;</span><span class="xml">,</span><span class="xml">     </span><span class="xquery"><span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">4</span><span class="hljs-built_in">,name</span>:<span class="hljs-string">&#x27;测试3&#x27;</span>&#125;</span><span class="xml">,</span><span class="xml">     </span><span class="xquery"><span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">5</span><span class="hljs-built_in">,name</span>:<span class="hljs-string">&#x27;测试4&#x27;</span>&#125;</span><span class="xml">,</span><span class="xml">     </span><span class="xquery"><span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">6</span><span class="hljs-built_in">,name</span>:<span class="hljs-string">&#x27;测试44&#x27;</span>&#125;</span><span class="xml">,</span><span class="xml">     </span><span class="xquery"><span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">7</span><span class="hljs-built_in">,name</span>:<span class="hljs-string">&#x27;测试45&#x27;</span>&#125;</span><span class="xml">,</span><span class="xml">     </span><span class="xquery"><span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">8</span><span class="hljs-built_in">,name</span>:<span class="hljs-string">&#x27;测试46&#x27;</span>&#125;</span><span class="xml">,</span><span class="xml">     </span><span class="xquery"><span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">9</span><span class="hljs-built_in">,name</span>:<span class="hljs-string">&#x27;测试47&#x27;</span>&#125;</span><span class="xml">,</span><span class="xml">     </span><span class="xquery"><span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">10</span><span class="hljs-built_in">,name</span>:<span class="hljs-string">&#x27;测试48&#x27;</span>&#125;</span><span class="xml">,</span><span class="xml">     </span><span class="xquery"><span class="hljs-built_in">&#123;id</span>:<span class="hljs-number">11</span><span class="hljs-built_in">,name</span>:<span class="hljs-string">&#x27;试测试测试测试测试测试49&#x27;</span>&#125;</span><span class="xml">,</span><span class="xml">    ]</span><span class="xml">  &#125;,</span><span class="xml"></span><span class="xml"></span><span class="xml"></span><span class="xml"></span><span class="xml">  methods:</span><span class="xquery">&#123;</span><span class="xquery">    selectData(list)&#123;</span><span class="xquery">      console.log(<span class="hljs-string">&#x27;子组件返回的选项&#x27;</span>,list)</span><span class="xquery">    &#125;</span><span class="xml"></span><span class="xml">  &#125;</span><span class="xml">&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>&lt;style scoped&gt;&lt;/style&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Element UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Element-ui 时间组件指定选择开始日期和结束日期</title>
    <link href="/2021/05/21/Element-ui-%E6%97%B6%E9%97%B4%E7%BB%84%E4%BB%B6%E6%8C%87%E5%AE%9A%E9%80%89%E6%8B%A9%E5%BC%80%E5%A7%8B%E6%97%A5%E6%9C%9F%E5%92%8C%E7%BB%93%E6%9D%9F%E6%97%A5%E6%9C%9F/"/>
    <url>/2021/05/21/Element-ui-%E6%97%B6%E9%97%B4%E7%BB%84%E4%BB%B6%E6%8C%87%E5%AE%9A%E9%80%89%E6%8B%A9%E5%BC%80%E5%A7%8B%E6%97%A5%E6%9C%9F%E5%92%8C%E7%BB%93%E6%9D%9F%E6%97%A5%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><h4 id="点击开始事件后展示出前后30天的时间，其他日期不可选"><a href="#点击开始事件后展示出前后30天的时间，其他日期不可选" class="headerlink" title="点击开始事件后展示出前后30天的时间，其他日期不可选"></a>点击开始事件后展示出前后30天的时间，其他日期不可选</h4><p><img src="/img/blog/element/el-picker.png"></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><div class="code-wrapper"><pre><code class="hljs vue">&lt;el-date-picker  v-model=&quot;form.date&quot;  class=&quot;custom__item&quot;  type=&quot;daterange&quot;  range-separator=&quot;至&quot;  start-placeholder=&quot;开始日期&quot;  end-placeholder=&quot;结束日期&quot;  value-format=&quot;yyyy-MM-dd&quot;  @blur=&quot;onMonthBlur&quot;  @change=&quot;changeDate&quot;  clearable  :picker-options=&quot;pickerOptions&quot;/&gt;</code></pre></div><h3 id="配置项代码"><a href="#配置项代码" class="headerlink" title="配置项代码"></a>配置项代码</h3><div class="code-wrapper"><pre><code class="hljs vue">timeOptionRange: null,pickerOptions:&#123;    onPick: time =&gt; &#123;      //当第一时间选中才设置禁用      if (time.minDate &amp;&amp; !time.maxDate) &#123;        this.timeOptionRange = time.minDate;      &#125;      if (time.maxDate) &#123;        this.timeOptionRange = null;      &#125;    &#125;,    disabledDate: time =&gt; &#123;      let timeOptionRange = this.timeOptionRange;      let secondNum = 60 * 60 * 24 * 29 * 1000;      if (timeOptionRange) &#123;        return (time.getTime() != timeOptionRange.getTime() + secondNum &amp;&amp;          time.getTime() != timeOptionRange.getTime() - secondNum);      &#125;    &#125;  &#125;,</code></pre></div><div class="code-wrapper"><pre><code class="hljs vue">//失去焦点就把选中项清空,方便下次进入时间组件时显示初始化状态onMonthBlur() &#123;  this.timeOptionRange = null&#125;,</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Element UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6判断两个数组是否完全相等</title>
    <link href="/2021/05/21/ES6%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/"/>
    <url>/2021/05/21/ES6%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span>  listA = val;<span class="hljs-comment">//当前选中数据</span><span class="hljs-keyword">let</span>  listB = <span class="hljs-built_in">this</span>.plainOptions;<span class="hljs-comment">//原始数据</span><span class="hljs-keyword">if</span>(listA.length === listB.length &amp;&amp; listA.every(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> listB.some(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> a === b)) &amp;&amp; listB.every(<span class="hljs-function"><span class="hljs-params">_b</span> =&gt;</span> listA.some(<span class="hljs-function"><span class="hljs-params">_a</span> =&gt;</span> _a === _b)))&#123;    <span class="hljs-comment">//to do </span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Element Select下拉框瞬间清空多选的延迟问题</title>
    <link href="/2021/03/12/%E4%B8%8B%E6%8B%89%E6%A1%86%E7%9E%AC%E9%97%B4%E6%B8%85%E7%A9%BA%E5%A4%9A%E9%80%89%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/12/%E4%B8%8B%E6%8B%89%E6%A1%86%E7%9E%AC%E9%97%B4%E6%B8%85%E7%A9%BA%E5%A4%9A%E9%80%89%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>下拉框组件的refs里有选项数组和缓存数组，将其清空，再利用更新key值来重置组件</p><p><img src="/img/blog/vueinit/v3.png"></p>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Element UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Element-UI 自定义Tree组件</title>
    <link href="/2021/02/18/Element-UI-%E8%87%AA%E5%AE%9A%E4%B9%89Tree%E7%BB%84%E4%BB%B6/"/>
    <url>/2021/02/18/Element-UI-%E8%87%AA%E5%AE%9A%E4%B9%89Tree%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>根据业务修改element tree 组件，实现增删改节点时不收起节点不需要重新渲染整个树组件</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;el-tree      :props=&quot;props&quot;      :load=&quot;loadNode&quot;      :data=&quot;setTree&quot;      @node-click=&quot;clickFn&quot;      lazy      ref=&quot;tree&quot;    &gt;      &lt;span class=&quot;custom-tree-node&quot; slot-scope=&quot;&#123; node, data &#125;&quot;&gt;        &lt;span class=&quot;label&quot;&gt;&#123;&#123; node.label &#125;&#125;&lt;/span&gt;        &lt;span&gt;          &lt;template v-for=&quot;(item, index) in methodName&quot;&gt;          &lt;template v-if=&quot;data.unIcon&quot;&gt;          &lt;i            :class=&quot;&#x27;el-icon-&#x27; + item&quot;            @click.stop=&quot;() =&gt; update(node, data, item)&quot;            style=&quot;margin-right: 10px&quot;            :key=&quot;index&quot;            v-if=&quot;!data.unIcon.includes(item)&quot;          &gt;&lt;/i&gt;          &lt;/template&gt;          &lt;template v-else&gt;          &lt;i            :class=&quot;&#x27;el-icon-&#x27; + item&quot;            @click.stop=&quot;() =&gt; update(node, data, item)&quot;            style=&quot;margin-right: 10px&quot;            :key=&quot;index&quot;          &gt;&lt;/i&gt;          &lt;/template&gt;          &lt;/template&gt;        &lt;/span&gt;      &lt;/span&gt;    &lt;/el-tree&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Element from &quot;element-ui&quot;;export default &#123;  props: &#123;    getTreeData: [Function],    addFn: [Function],    editFn: [Function],    method: [Array, Object]  &#125;,  computed: &#123;    methodName() &#123;      let arr = [];      for (let k in this.method) &#123;        arr.push(k);      &#125;      return arr;    &#125;  &#125;,  data() &#123;    return &#123;      setTree:[],      oneTree: [],      props: &#123;        label: &quot;name&quot;,        isLeaf: &quot;leaf&quot;      &#125;,      currentModel: false    &#125;;  &#125;,  methods: &#123;    clickFn(data,node,dom) &#123;      this.$emit(&quot;getNode&quot;, &#123;node: node, type: &#x27;click&#x27;&#125;)    &#125;,    async loadNode(node, resolve) &#123;      //判断一级 二级      let data =        node.level === 0          ? &#123;&#125;          : &#123;              type: node.level,              id: node.data.id            &#125;;      let list = await this.getTreeData(data);      if(node.level === 0) &#123;        this.oneTree = list;      &#125;      return resolve(list);    &#125;,    async update(node, data, type) &#123;      this.$emit(&quot;getNode&quot;, &#123;node: node, type: type&#125;)      this.currentModel = true;      let type_title = &quot;&quot;; // 弹窗标题      let type_text = &quot;&quot;; // 弹窗内容      let defaultData = &#123;&#125;;      switch (type) &#123;        case &quot;add&quot;:          type_title = &quot;新增&quot;;          //填充默认值          defaultData = &#123;            inputPlaceholder: `请输入$&#123;data.title&#125;`          &#125;;          break;        case &quot;edit&quot;:          type_title = &quot;编辑&quot;;          //填充默认值          defaultData = &#123;            inputPlaceholder: `请输入$&#123;data.title&#125;`,            inputValue: data.name          &#125;;          break;        case &quot;delete&quot;:          type_title = &quot;删除&quot;;          //填充默认值          type_text = `确定要删除$&#123;data.name&#125;$&#123;data.title&#125;?`;          break;      &#125;      const MessageBoxType = type == &quot;delete&quot; ? &quot;$confirm&quot; : &quot;$prompt&quot;; // 判断弹窗类型      this[MessageBoxType](        type_text,        `$&#123;type_title&#125;$&#123;data.title&#125;`,        defaultData      ).then(async (&#123; value &#125;) =&gt; &#123;        // console.log(&#x27;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#x27;, value)        let d = &#123;          type: node == null ? 1 : node.level,          id: data.id,          name: value        &#125;;        // 新增        if (type == &quot;add&quot;) &#123;          if(node == null) &#123;            delete d.type;          &#125;          let res = await this.method.add(d);          let newChild = &#123; id: res.id, name: value, children: [] &#125;;          if(res.unIcon) &#123; //icon             newChild.unIcon = res.unIcon          &#125;          if(res.leaf) &#123; // 是否有子集             newChild.leaf = res.leaf          &#125;          if(res.title) &#123; // title             newChild.title = res.title          &#125;          if (!data.children) &#123;            this.$set(data, &quot;children&quot;, []);          &#125;          console.log(&#x27;&gt;&gt;&gt;&gt;&gt;&gt;11111222&#x27;, data)          if(node == null)&#123;            // console.log(&#x27;&gt;&gt;&gt;&gt;&gt;&#x27;, node)            this.setTree = this.oneTree            this.setTree.push(newChild)          &#125; else &#123;            // console.log(&#x27;&gt;&gt;&gt;&gt;&gt;&#x27;, node)            this.$refs[&#x27;tree&#x27;].append(newChild,node);          &#125;          return false;        &#125;        // 编辑        if (type == &quot;edit&quot;) &#123;          await this.method.edit(d);          data.name = value;          return false;        &#125;        // 删除        if (type == &quot;delete&quot;) &#123;          delete d.name;          await this.method.delete(d);          const parent = node.parent          this.$refs[&#x27;tree&#x27;].remove(node);        &#125;      &#125;);    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style scoped&gt;/deep/.custom-tree-node &#123;  flex: 1;  display: flex;  align-items: center;  justify-content: space-between;  font-size: 14px;  padding-right: 8px;&#125;/deep/.el-tree-node__content &#123;  display: flex;  align-items: center;  height: 26px;  cursor: pointer;  margin: 8px 0;&#125;/deep/.el-icon-add:before &#123;  content: &quot;\e783&quot;;&#125;/deep/.el-icon-edit:before &#123;  content: &quot;\e764&quot;;&#125;.label&#123;  overflow: hidden;  text-overflow: ellipsis;  white-space: nowrap;  display: inline-block;  max-width: 145px;&#125;&lt;/style&gt;</code></pre></div><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>getNode方法为自定义组件返回的点击的node事件，用于判断当前点击的某个node，及事件类型：add,edit,del, click；</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;xtAdminTree    @getNode=&quot;handleNodeClick&quot;  //返回点击的节点    :getTreeData=&quot;getTreeData&quot; //获取数据进行渲染    :method=&quot;&#123;            add: addSubjectFn, //新增方法            edit: editSubject, // 编辑方法            delete: deleteSubject, //删除方法          &#125;&quot;    ref=&quot;tree&quot;/&gt;</code></pre></div><h4 id="渲染方法"><a href="#渲染方法" class="headerlink" title="渲染方法"></a>渲染方法</h4><div class="code-wrapper"><pre><code class="hljs vue">getTreeData(data) &#123;      return new Promise((resolve, reject) =&gt; &#123;        console.log(&quot;获取层级数据&quot;, data);        this.openType = data.type ? data.type : 0;        console.log(&quot;this.openType&quot;, this.openType);        if (data.type &amp;&amp; data.type &gt; 0) &#123;          data.campus_id = data.id;          delete data.id;          delete data.type;        &#125;        console.log(&quot;获取列表参数&quot;, data);        campusList(data).then((res) =&gt; &#123;          if (res.code == 1) &#123;            this.listLoading = false;            let list = res.data;            list = res.data.map((item) =&gt; &#123;              return &#123;                id: item.id,                name: item.name,                leaf: this.openType == 1,                title: this.modelLabelList[this.openType].inputLabel,                unIcon: this.openType == 1 ? [&quot;add&quot;] : [],              &#125;;            &#125;);            resolve(list);          &#125; else &#123;            this.$message.error(&quot;获取校区数据异常&quot;);            resolve([]);          &#125;        &#125;);      &#125;);    &#125;,</code></pre></div><h4 id="点击节点事件"><a href="#点击节点事件" class="headerlink" title="点击节点事件"></a>点击节点事件</h4><div class="code-wrapper"><pre><code class="hljs vue">//点击树节点的事件 , 点击事件如果不是click,需要动态传入模态框的title，用于弹框显示不同文字类型    handleNodeClick(data) &#123;      console.log(&quot;node点击事件&quot;, data);      // console.log(&quot;checked&quot;, checked);      if (data.type == &quot;click&quot;) &#123;        if (data.node.level == 2) &#123;          this.listQuery.page = 1;          this.isTableTitle = true;          this.tableTitle = data.node.data.name;          this.tableNode = Object.assign(&#123;&#125;, data.node);          this.getTableByID(data.node);        &#125;      &#125; else if (data.type == &quot;add&quot;) &#123;        console.log(&#x27;data.node&#x27;,data.node)        if(data.node != null)&#123;          data.node.data.title = this.modelLabelList[data.node.level].inputLabel        &#125;      &#125; else if (data.type == &quot;edit&quot;) &#123;          data.node.data.title = this.modelLabelList[data.node.level-1].inputLabel      &#125;    &#125;,</code></pre></div><h4 id="method方法为新增，编辑，删除的方法，返回一个promise"><a href="#method方法为新增，编辑，删除的方法，返回一个promise" class="headerlink" title="method方法为新增，编辑，删除的方法，返回一个promise"></a>method方法为新增，编辑，删除的方法，返回一个promise</h4><div class="code-wrapper"><pre><code class="hljs vue">//新增 addSubjectFn(data) &#123;   console.log(&quot;新增data&quot;, data);   this.openType = data.type ? data.type : 0;   return new Promise((resolve, reject) =&gt; &#123;     if (!data.name || data.name == &quot;&quot;) &#123;       this.$message.error(&quot;提交名称不得为空,请输入后再次提交&quot;);       reject();     &#125; else &#123;       if (data.type &amp;&amp; data.type == 1) &#123;         data.campus_id = data.id;       &#125;       delete data.type;       delete data.id;       addCampus(data).then((res) =&gt; &#123;         // console.log(&quot;this.openType&quot;, this.openType);         if (res.code == 1) &#123;           if (this.openType == 0) &#123;             res.data.leaf = false;             res.data.title = &quot;校区名称&quot;;           &#125; else if (this.openType == 1) &#123;             res.data.unIcon = [&quot;add&quot;];             res.data.leaf = true;             res.data.title = &quot;分校区名称&quot;;           &#125;           this.$message.success(&quot;新增操作成功&quot;);           resolve(res.data);         &#125; else &#123;           this.$message.error(res.msg);           reject(res.msg);         &#125;       &#125;);     &#125;   &#125;); &#125;, //编辑 editSubject(data) &#123;   console.log(&quot;编辑data&quot;, data);   return new Promise((resolve, reject) =&gt; &#123;     if (!data.name || data.name == &quot;&quot;) &#123;       this.$message.error(&quot;提交名称不得为空,请输入后再次提交&quot;);       reject();     &#125; else &#123;       editCampus(data).then((res) =&gt; &#123;         if (res.code == 1) &#123;           this.$message.success(&quot;编辑操作成功&quot;);           if (data.type == 2) &#123;             this.initTable();           &#125;           resolve();         &#125; else &#123;           this.$message.error(res.msg);           reject(res.msg);         &#125;       &#125;);     &#125;   &#125;); &#125;, //删除 deleteSubject(data) &#123;   return new Promise((resolve, reject) =&gt; &#123;     deleteCampus(data).then((res) =&gt; &#123;       if (res.code == 1) &#123;         this.$message.success(&quot;删除校区操作成功&quot;);         if (data.type == 2) &#123;           this.initTable();         &#125;         resolve();       &#125; else &#123;         this.$message.error(&quot;删除校区操作异常&quot;);         reject(res.msg);       &#125;     &#125;);   &#125;); &#125;,</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Element UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Element-UI 级联选择器动态回显数据</title>
    <link href="/2021/01/21/Element-UI-%E7%BA%A7%E8%81%94%E9%80%89%E6%8B%A9%E5%99%A8%E5%8A%A8%E6%80%81%E5%B1%95%E7%A4%BA%E6%95%B0%E6%8D%AE/"/>
    <url>/2021/01/21/Element-UI-%E7%BA%A7%E8%81%94%E9%80%89%E6%8B%A9%E5%99%A8%E5%8A%A8%E6%80%81%E5%B1%95%E7%A4%BA%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="解决级联选择器动态获取数据后选中数据时的回显bug"><a href="#解决级联选择器动态获取数据后选中数据时的回显bug" class="headerlink" title="解决级联选择器动态获取数据后选中数据时的回显bug"></a>解决级联选择器动态获取数据后选中数据时的回显bug</h4><h3 id="组件使用"><a href="#组件使用" class="headerlink" title="组件使用"></a>组件使用</h3><div class="code-wrapper"><pre><code class="hljs vue">&lt;el-cascader    style=&quot;width: 300px&quot;    :props=&quot;cascaderPros&quot;    ref=&quot;cascaderModel&quot;    @change=&quot;cascaderChange&quot;    v-if=&quot;isShowCascader&quot;&gt;&lt;/el-cascader&gt;</code></pre></div><h3 id="定义动态方法"><a href="#定义动态方法" class="headerlink" title="定义动态方法"></a>定义动态方法</h3><div class="code-wrapper"><pre><code class="hljs vue">lazyLoad(node, resolve) &#123;  // console.log(&quot;node&quot;, node);  setTimeout(() =&gt; &#123;    if (node.level == 0) &#123;      departList(&#123;&#125;).then((res) =&gt; &#123;        let data = [];        if (res.code == 1) &#123;          data = res.data.list.map((value, i) =&gt; &#123;            return &#123;              value: value.id,              label: value.name,            &#125;;          &#125;);          resolve(data);        &#125; else &#123;          self.$message.error(&quot;获取一级部门数据异常&quot;);        &#125;      &#125;);    &#125; else if (node.level == 1) &#123;      let params = &#123;        department_id: node.data.value,      &#125;;      deplistSecondList(params).then((res) =&gt; &#123;        // console.log(&quot;二级部门列表&quot;, res);        let child = [];        if (res.code == 1) &#123;          node.data.children = [];          child = res.data.list.map((value, i) =&gt; &#123;            return &#123;              value: value.id,              label: value.name,              leaf: true,            &#125;;          &#125;);          if (child.length == 0) &#123;            self.$message(&quot;该部门下没有二级部门&quot;);            self.$refs.cascaderModel.$refs.panel.activePath = [];            self.$refs.cascaderModel.$refs.panel.syncActivePath();          &#125;          resolve(child);        &#125; else &#123;          self.$message.error(&quot;获取二级部门数据异常&quot;);        &#125;      &#125;);    &#125; else if (node.level == 2) &#123;      resolve([]);    &#125;  &#125;, 500);&#125;,</code></pre></div><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>弹框返回时需要执行下面三行，否则再次打开还会出现上次的选择</p><div class="code-wrapper"><pre><code class="hljs vue">this.$refs.cascaderModel.$refs.panel.checkedValue = []; //也可以是指定的值，默认返回值是数组，也可以返回单个值this.$refs.cascaderModel.$refs.panel.activePath = [];this.$refs.cascaderModel.$refs.panel.syncActivePath();</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Element UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webstorm 创建vue模板</title>
    <link href="/2020/11/01/webstorm-%E5%88%9B%E5%BB%BAvue%E6%A8%A1%E6%9D%BF/"/>
    <url>/2020/11/01/webstorm-%E5%88%9B%E5%BB%BAvue%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="/img/blog/webstorm/w1.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;   name: &quot;$&#123;COMPONENT_NAME&#125;&quot;,   components:&#123;&#125;,   data() &#123;     return &#123;     &#125;   &#125;,   created() &#123;      &#125;,   methods: &#123;      &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用vue-init-webpack 模板 配合route-view搭建菜单栏</title>
    <link href="/2020/09/23/%E4%BD%BF%E7%94%A8vue-init-webpack-%E6%A8%A1%E6%9D%BF-%E9%85%8D%E5%90%88route-view%E6%90%AD%E5%BB%BA%E8%8F%9C%E5%8D%95%E6%A0%8F/"/>
    <url>/2020/09/23/%E4%BD%BF%E7%94%A8vue-init-webpack-%E6%A8%A1%E6%9D%BF-%E9%85%8D%E5%90%88route-view%E6%90%AD%E5%BB%BA%E8%8F%9C%E5%8D%95%E6%A0%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p><img src="/img/blog/vueinit/v1.png"></p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p><img src="/img/blog/vueinit/v2.png"></p><p>router文件夹下的index.js</p><div class="code-wrapper"><pre><code class="hljs dts">import Vue from <span class="hljs-string">&quot;vue&quot;</span>;import Router from <span class="hljs-string">&quot;vue-router&quot;</span>;<span class="hljs-class">import </span>&#123;MenuComponent&#125; from <span class="hljs-string">&quot;@/Layout&quot;</span>;Vue.use(Router);export default new Router(&#123;<span class="hljs-symbol">    routes:</span> [        &#123;<span class="hljs-symbol">            path:</span> <span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-symbol">            component:</span> MenuComponent,<span class="hljs-symbol">            children:</span> [                &#123;<span class="hljs-symbol">                    path:</span> <span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-symbol">                    name:</span> <span class="hljs-string">&quot;HelloWorld&quot;</span>,<span class="hljs-symbol">                    component:</span> () =&gt; import(<span class="hljs-string">&quot;@/components/HelloWorld&quot;</span>)                &#125;            ]        &#125;,        &#123;<span class="hljs-symbol">            path:</span> <span class="hljs-string">&quot;/mqtt_test&quot;</span>,<span class="hljs-symbol">            component:</span> MenuComponent,<span class="hljs-symbol">            children:</span> [                &#123;<span class="hljs-symbol">                    path:</span> <span class="hljs-string">&quot;/mqtt_test&quot;</span>,<span class="hljs-symbol">                    name:</span> <span class="hljs-string">&quot;MqttTest&quot;</span>,<span class="hljs-symbol">                    component:</span> () =&gt; import(<span class="hljs-string">&quot;@/components/mqtt_test&quot;</span>)                &#125;            ]        &#125;,        &#123;<span class="hljs-symbol">            path:</span> <span class="hljs-string">&quot;/MonthComponent&quot;</span>,<span class="hljs-symbol">            component:</span> MenuComponent,<span class="hljs-symbol">            children:</span> [                &#123;<span class="hljs-symbol">                    path:</span> <span class="hljs-string">&quot;/MonthComponent&quot;</span>,<span class="hljs-symbol">                    name:</span> <span class="hljs-string">&quot;MonthComponent&quot;</span>,<span class="hljs-symbol">                    component:</span> () =&gt; import(<span class="hljs-string">&quot;@/components/month_component&quot;</span>)                &#125;            ]        &#125;        <span class="hljs-comment">// &#123;</span>        <span class="hljs-comment">//     path: &quot;/mqtt_test&quot;,</span>        <span class="hljs-comment">//     name: &quot;MqttTest&quot;,</span>        <span class="hljs-comment">//     component: MqttTest</span>        <span class="hljs-comment">// &#125;,</span>        <span class="hljs-comment">// &#123;</span>        <span class="hljs-comment">//     path: &quot;/MonthComponent&quot;,</span>        <span class="hljs-comment">//     name: &quot;MonthComponent&quot;,</span>        <span class="hljs-comment">//     component: MonthComponent</span>        <span class="hljs-comment">// &#125;</span>    ]&#125;);</code></pre></div><p>MenuComponent.vue </p><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;el-menu-demo&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-menu</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">:default-active</span>=<span class="hljs-string">&quot;activeMenu&quot;</span></span></span><span class="hljs-tag"><span class="xml">        @<span class="hljs-attr">select</span>=<span class="hljs-string">&quot;menuSelect&quot;</span></span></span><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;horizontal&quot;</span></span></span><span class="hljs-tag"><span class="xml">    &gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-menu-item</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,idx) in routerList&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;idx&quot;</span> <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;item.path&quot;</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;el-icon-menu&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span></span><span class="xml">         </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.name</span> &#125;&#125;</span><span class="xml"></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-menu-item</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-menu</span>&gt;</span></span><span class="xml"></span><span class="xml"></span><span class="xml">    <span class="hljs-comment">&lt;!--视图窗口：多用于布局，比如全局菜单栏或测导航等  --&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!--不加router-view组件,会只显示菜单而不显示菜单下的页面 以下是官方介绍：--&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!--这里的 &lt;router-view&gt; 是最顶层的出口，渲染最高级路由匹配到的组件。--&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!--同样地，一个被渲染组件同样可以包含自己的嵌套 &lt;router-view&gt;--&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml"></span><span class="xml"></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="javascript"><span class="xml">  <span class="hljs-attr">components</span>: &#123;&#125;,</span></span><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">    <span class="hljs-keyword">return</span> &#123;&#125;;</span></span><span class="javascript"><span class="xml">  &#125;,</span></span><span class="javascript"><span class="xml">  <span class="hljs-attr">computed</span>: &#123;</span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">activeMenu</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$route.path;</span></span><span class="javascript"><span class="xml">    &#125;,</span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">routerList</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$router.options.routes.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-keyword">return</span> &#123;</span></span><span class="javascript"><span class="xml">          <span class="hljs-attr">path</span>: item.path,</span></span><span class="javascript"><span class="xml">          <span class="hljs-attr">children</span>: item.children,</span></span><span class="javascript"><span class="xml">          <span class="hljs-attr">name</span>: item.children[<span class="hljs-number">0</span>].name</span></span><span class="javascript"><span class="xml">        &#125;;</span></span><span class="javascript"><span class="xml">      &#125;);</span></span><span class="javascript"><span class="xml">    &#125;</span></span><span class="javascript"><span class="xml">  &#125;,</span></span><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml"></span></span><span class="javascript"><span class="xml">  &#125;,</span></span><span class="javascript"><span class="xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">menuSelect</span>(<span class="hljs-params">v</span>)</span> &#123;</span></span><span class="javascript"><span class="xml">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$route.path !== v) &#123;</span></span><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.$router.push(v);</span></span><span class="javascript"><span class="xml">      &#125;</span></span><span class="javascript"><span class="xml">    &#125;</span></span><span class="javascript"><span class="xml">  &#125;</span></span><span class="javascript"><span class="xml">&#125;;</span></span><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"></span><span class="xml"></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css"></span></span><span class="css"><span class="xml"><span class="hljs-selector-class">.el-menu-demo</span> &#123;</span></span><span class="css"><span class="xml">  user-select: none</span></span><span class="css"><span class="xml">&#125;</span></span><span class="css"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></code></pre></div><p>layout文件夹下的index.js</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> MenuComponent&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./menu&quot;</span>;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx代理基本用法</title>
    <link href="/2020/05/21/nginx%E4%BB%A3%E7%90%86%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2020/05/21/nginx%E4%BB%A3%E7%90%86%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h3><p>修改vue项目生产环境打包配置，需要在.env.production配置生产环境访问地址为nginx代理端口</p><div class="code-wrapper"><pre><code class="hljs vue">VUE_APP_BASE_API = &#x27;http://xxx.xx.xx.xx:8080&#x27;</code></pre></div><div class="code-wrapper"><pre><code class="hljs vue">proxy: &#123;  [process.env.VUE_APP_BASE_API]: &#123;    target: &quot;http://xxx.xx.xx.xx:8080&quot;,    changeOrigin: true,    pathRewrite: &#123;      [&#x27;^&#x27; + process.env.VUE_APP_BASE_API]: &#x27;&#x27;    &#125;  &#125;,&#125;</code></pre></div><h3 id="ngixn-配置"><a href="#ngixn-配置" class="headerlink" title="ngixn 配置"></a>ngixn 配置</h3><p>8080为nginx监听端口，访问的是dist目录下的index.html前端页面，需要配置里增加api监听和代理</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">listen</span>       <span class="hljs-number">8080</span>;<span class="hljs-attribute">server_name</span>  <span class="hljs-number">122.51.128.27</span>;<span class="hljs-comment">#charset koi8-r;</span><span class="hljs-comment">#access_log  logs/host.access.log  main;</span><span class="hljs-attribute">location</span> / &#123;    <span class="hljs-attribute">root</span>   /var/opt/client/dist;    <span class="hljs-attribute">index</span>  index.html index.htm;    <span class="hljs-attribute">try_files</span> $uri $uri/ /index.html;&#125;<span class="hljs-attribute">location</span><span class="hljs-regexp"> ^~</span> /api/&#123;    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8088; <span class="hljs-comment">#代理到实际接口地址，云服务器本地端口</span>&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js 数据拷贝的几种方式</title>
    <link href="/2020/05/10/js-%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/05/10/js-%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="js-数据拷贝的几种方式"><a href="#js-数据拷贝的几种方式" class="headerlink" title="js 数据拷贝的几种方式"></a>js 数据拷贝的几种方式</h3><ul><li>JSON.parse(JSON.stringify(obj))</li><li>Object.assign({},obj)</li><li>_.cloneDeep(obj1)</li><li>{…obj }</li></ul><div class="code-wrapper"><pre><code class="hljs stylus">let obj = &#123;  <span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>,  <span class="hljs-selector-tag">b</span>:&#123;    m:<span class="hljs-number">2</span>  &#125;,  c:<span class="hljs-selector-attr">[1,1,1]</span>,  d:null,  e:()=&gt;&#123;    return <span class="hljs-number">1</span>  &#125;,  f:undefined&#125;let obj1  = JSON<span class="hljs-selector-class">.parse</span>(JSON<span class="hljs-selector-class">.stringify</span>(obj))let obj2 = Object<span class="hljs-selector-class">.assign</span>(&#123;&#125;,obj)let obj3 = _<span class="hljs-selector-class">.cloneDeep</span>(obj1)<span class="hljs-comment">//lodash.cloneDeep()</span>let obj4 = &#123;..<span class="hljs-selector-class">.obj</span> &#125;obj<span class="hljs-selector-class">.a</span> = <span class="hljs-number">0</span>obj<span class="hljs-selector-class">.b</span>.m= <span class="hljs-number">333</span>obj<span class="hljs-selector-class">.c</span> = <span class="hljs-selector-attr">[0]</span>obj<span class="hljs-selector-class">.d</span> = <span class="hljs-string">&#x27;&#x27;</span>obj<span class="hljs-selector-class">.f</span> = <span class="hljs-number">4</span>console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;obj&#x27;</span>,obj)console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;JSON.parse&#x27;</span>,obj1)console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;Object.assign&#x27;</span>,obj2)console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;_.cloneDeep&#x27;</span>,obj3)console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;...obj&#x27;</span>,obj4)</code></pre></div><h4 id="打印结果："><a href="#打印结果：" class="headerlink" title="打印结果："></a>打印结果：</h4><p><img src="/img/blog/js/copy.png"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>一般情况推荐使用：Object.assign，{…obj } 这两种方式</p><p>如果对象仅内包含嵌套对象 可以使用JSON.parse(JSON.stringify(obj))，_.cloneDeep(obj1) 这两种方式</p><p>如果对象内包含函数或其他复杂对象，使用以下方法：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">deepClone</span>(<span class="hljs-params">obj</span>)</span> &#123;  <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;    <span class="hljs-keyword">if</span> (obj[key] &amp;&amp; <span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;      result[key] = <span class="hljs-built_in">this</span>.deepClone(obj[key])    &#125; <span class="hljs-keyword">else</span> &#123;      result[key] = obj[key]    &#125;  &#125;  <span class="hljs-keyword">return</span> result&#125;,</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx常用命令</title>
    <link href="/2020/04/24/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/04/24/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>启动nginx: start nginx</p><div class="code-wrapper"><pre><code class="hljs awk">nginx -s reload  ：修改配置后重新加载生效nginx -s reopen  ：重新打开日志文件nginx -t -c <span class="hljs-regexp">/path/</span>to/nginx.conf 测试nginx配置文件是否正确</code></pre></div><p>关闭nginx：</p><div class="code-wrapper"><pre><code class="hljs vim">nginx -s <span class="hljs-keyword">stop</span>  :快速停止nginxnginx -s <span class="hljs-keyword">quit</span>  ：完整有序的停止nginx</code></pre></div><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>修改nginx配置后需要重启Nginx:<br>/usr/local/nginx/sbin/nginx  nginx默认安装地址<br>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</p><h3 id="windows"><a href="#windows" class="headerlink" title="windows:"></a>windows:</h3><p>windows系统下注意不要直接双击nginx.exe:这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程<br>需要在nginx.exe目录，打开命令行工具，用命令 启动/关闭/重启nginx</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity AssetBundle一键命名并打包</title>
    <link href="/2018/06/06/Unity-AssetBundle%E4%B8%80%E9%94%AE%E5%91%BD%E5%90%8D%E5%B9%B6%E6%89%93%E5%8C%85/"/>
    <url>/2018/06/06/Unity-AssetBundle%E4%B8%80%E9%94%AE%E5%91%BD%E5%90%8D%E5%B9%B6%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>将脚本放在项目里Editor文件夹下，设置好要打包的预制体的文件夹路径和打包出来的资源包路径，就可以一键完成预制体的命名和打包</p><div class="code-wrapper"><pre><code class="hljs c#">using UnityEngine;using System.Collections;using UnityEditor;using System.IO;/// &lt;summary&gt;/// 先指定要打包的文件夹，点击后会把整个文件夹里东西自动命名，并打包指定到另一个文件夹/// &lt;/summary&gt;public class AssetbundlePerfabs : Editor&#123;    public static string sourcePath = Application.dataPath + &quot;/_Project/Public Resource/Model&quot;;//要打包的资源目录    const string AssetBundlesOutputPath = &quot;D:/VMNEW/Trunk/Resources/Model32&quot;;//打包完的指定目录    [MenuItem(&quot;Tools/AssetBundle/Build&quot;)]    public static void BuildAssetBundle()    &#123;        ClearAssetBundlesName();        Pack(sourcePath);        string outputPath = AssetBundlesOutputPath;        if (!Directory.Exists(outputPath))        &#123;            Directory.CreateDirectory(outputPath);        &#125;        BuildPipeline.BuildAssetBundles(outputPath, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);        AssetDatabase.Refresh();           &#125;     static void ClearAssetBundlesName()    &#123;        int length = AssetDatabase.GetAllAssetBundleNames().Length;        Debug.Log(length);        string[] oldAssetBundleNames = new string[length];        for (int i = 0; i &lt; length; i++)        &#123;            oldAssetBundleNames[i] = AssetDatabase.GetAllAssetBundleNames()[i];        &#125;        for (int j = 0; j &lt; oldAssetBundleNames.Length; j++)        &#123;            AssetDatabase.RemoveAssetBundleName(oldAssetBundleNames[j], true);        &#125;        length = AssetDatabase.GetAllAssetBundleNames().Length;    &#125;    static void Pack(string source)    &#123;        DirectoryInfo folder = new DirectoryInfo(source);        FileSystemInfo[] files = folder.GetFileSystemInfos();        int length = files.Length;        for (int i = 0; i &lt; length; i++)        &#123;            if (files[i] is DirectoryInfo)            &#123;                Pack(files[i].FullName);            &#125;            else            &#123;                if (!files[i].Name.EndsWith(&quot;.meta&quot;))                &#123;                    file(files[i].FullName);                    //Debug.Log(files[i].FullName);                &#125;            &#125;        &#125;    &#125;    static void file(string source)    &#123;        string _source = Replace(source);//替换&quot;\\&quot;为&quot;/&quot;        string _assetPath = &quot;Assets&quot; + _source.Substring(Application.dataPath.Length);        string _assetPath2 = _source.Substring(Application.dataPath.Length + 1);              AssetImporter assetImporter = AssetImporter.GetAtPath(_assetPath);        string assetName = _assetPath2.Substring(_assetPath2.IndexOf(&quot;/&quot;) + 1);        string a = assetName.Substring(assetName.IndexOf(&quot;/&quot;) + 1);        string b = a.Substring(a.IndexOf(&quot;/&quot;) + 1);        b = b.Replace(Path.GetExtension(b), &quot;.assetbundle&quot;);        assetImporter.assetBundleName = b;        Debug.Log(b);    &#125;    static string Replace(string s)    &#123;        return s.Replace(&quot;\\&quot;, &quot;/&quot;);    &#125;    //public class Platform    //&#123;    //    public static string GetPlatformFolder(BuildTarget target)    //    &#123;    //        switch (target)    //        &#123;    //            case BuildTarget.Android:    //                return &quot;Android&quot;;    //            case BuildTarget.iOS:    //                return &quot;IOS&quot;;    //            case BuildTarget.StandaloneWindows64:    //                return &quot;Windows&quot;;    //            default:    //                return null;    //        &#125;    //    &#125;    //&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
      <tag>AssetBundle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xlua 打补丁流程实验记录</title>
    <link href="/2018/05/23/Xlua-%E6%89%93%E8%A1%A5%E4%B8%81%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2018/05/23/Xlua-%E6%89%93%E8%A1%A5%E4%B8%81%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>首先将xLua-master里的Assets文件夹下的四个文件夹导入到unity项目里，然后在PlayerSetting里面添加HOTFIX_ENABLE宏。<br>xlua还需要依赖unity的cecil的dll程序集，这个需要到unity的安装目录下去复制。<br>具体是在安装文件夹下的Editor\Data\Managed下，分别是：Unity.Cecil.dll，Unity.Cecil.Mdb.dll和Unity.Cecil.Pdb.dll这三个，把他们复制到XLua\Src\Editor文件夹下。<br>最后再将xLua-master下的Tools文件夹整个复制到项目根目录下面，和Assets保持同级，到这里整个xlua环境就配置好了。</p><h3 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h3><p>新建一个场景，随便建一个物体当做玩家，然后新建脚本命名为BoxPlayer，写入以下代码</p><div class="code-wrapper"><pre><code class="hljs c#">using System.Collections;using System.Collections.Generic;using UnityEngine;using XLua;[Hotfix]public class BoxPlayer : MonoBehaviour &#123;    public float moveSpeed;       void Start () &#123;           &#125;              // Update is called once per frame       void Update () &#123;        PlayerMoveTest();    &#125;    [LuaCallCSharp]    private void PlayerMoveTest()    &#123;        transform.Translate(transform.forward * moveSpeed * Time.deltaTime,Space.World);    &#125;&#125;</code></pre></div><h4 id="逻辑讲解"><a href="#逻辑讲解" class="headerlink" title="逻辑讲解"></a>逻辑讲解</h4><p>首先是using XLua,然后将这个类打上Hotfix标签，代表这个类是要打补丁的。<br>然后在需要打补丁的方法上打一个标签[LuaCallCSharp]。<br>运行场景，这个物体会向前方运动, (场景中public的moveSpeed的速度是5)<br>然后在场景里新建一个StreamingAssets的文件夹, 在这个文件夹下创建一个文本文档：Hotfix.lua.txt 一定要以.lua.txt结尾。</p><p>lua里面调用c#方法需要CS开头来引用unity里面的类和方法，如果不是静态方法，比如transform.TransLate(….);<br>在lua里不能这样直接点出来，需要冒号来引用，self.transform:Translate（…..），<br>比如transform.GetComponent<GameObject>()….在lua里也是要换成冒号，并且不能使用&lt;&gt;的方式来获取组件。需要通过transform : GameObject（“GameObject”）的方式来获取。<br>如果是静态方法，比如说Time.deltaTime,可以直接使用CS.UnityEngine的命名空间来点出来。<br>另外xlua.hotfix（a,’b’,c）这种写法，里面的内容分别代表：a，要更改的C#脚本的脚本名；b,要更改的这个里面的方法名，需要单引号括起来；c,要替换的lua方法</p><div class="code-wrapper"><pre><code class="hljs c#">print(&#x27;执行更改&#x27;)xlua.hotfix(CS.BoxPlayer,&#x27;PlayerMoveTest&#x27;,function(self)       self.transform:Translate(self.transform.right *CS.UnityEngine.Time.deltaTime *15)       self.transform:GetComponent(&quot;MeshRenderer&quot;).material.color =CS.UnityEngine. Color.blackend)</code></pre></div><p>然后新建一个脚本Hotfix脚本挂在相机上，写入以下代码：</p><div class="code-wrapper"><pre><code class="hljs c#">using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;using XLua;public class HotFixScript : MonoBehaviour &#123;    LuaEnv LuaEnv = new LuaEnv();       void Start () &#123;        LuaEnv.AddLoader(MyLoder);        LuaEnv.DoString(&quot;require&#x27;Hotfix&#x27;&quot;);       &#125;              public  byte[]MyLoder(ref string file)    &#123;        string path = Application.streamingAssetsPath + &quot;/&quot; + file + &quot;.lua.txt&quot;;        return System.Text.Encoding.UTF8.GetBytes(File.ReadAllText(path));    &#125;    private void OnDisable()    &#123;        LuaEnv.DoString(&quot;require&#x27;callback&#x27;&quot;);    &#125;    private void OnDestroy()    &#123;        LuaEnv.Dispose();    &#125;    void Update () &#123;                     &#125;&#125;</code></pre></div><h3 id="逻辑讲解-1"><a href="#逻辑讲解-1" class="headerlink" title="逻辑讲解"></a>逻辑讲解</h3><p>首先是LuaEnv,这个是Xlua的一个入口，通过实例化它来执行操作，然后执行自己的lua文本时需要自定义Loder，来让LuaEnv根据自定义的Loder里面的路径来寻找自己创建的lua文本，否则找不到。然后在销毁这个组件时，关闭luaenv的实例化。<br>在Start里面LuaEnv.DoString(“require’Hotfix’”);就是执行的刚刚创建的Hotfix.lua.txt里面的代码。<br>这个时候点击运行场景，会发现物体的颜色变成了黑色，然后运动也不是向前运动而是向右，速度也从5变成了15。</p><p>另外，在lua更改了unity里面的方法，需要在结束运行时，取消对此方法的更改，否则会报错，更改方式就是，在OnDisable里面执行另一个lua文档，里面写一句话就可以：xlua.hotfix(CS.BoxPlayer,’PlayerMoveTest’,nil) </p><h4 id="以上就完成了一个Xlua更改C-执行方法的演示示例。"><a href="#以上就完成了一个Xlua更改C-执行方法的演示示例。" class="headerlink" title="以上就完成了一个Xlua更改C#执行方法的演示示例。"></a>以上就完成了一个Xlua更改C#执行方法的演示示例。</h4><h3 id="继续学习"><a href="#继续学习" class="headerlink" title="继续学习"></a>继续学习</h3><p>如果只需要更改速度，不更改其他方法，比如速度的变量moveSpeed是私有的并且在c#脚本里赋值为5 了，在lua里面可以这样写：</p><div class="code-wrapper"><pre><code class="hljs lua">xlua.private_accessible(CS.BoxPlayer)xlua.hotfix(CS.BoxPlayer,<span class="hljs-string">&#x27;Start&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>       <span class="hljs-built_in">self</span>.moveSpeed = <span class="hljs-number">15</span>;<span class="hljs-keyword">end</span>)</code></pre></div><p>xlua.private_accessible(CS.BoxPlayer)就是获取指定类里的私有变量的方式，但是执行LuaEnv.DoString(“require’Hotfix’”);的方法必须放到游戏一开始的Awake里执行，因为修改的是Start，所以有这个先后顺序需要注意。<br>但是如果Start里面不止这一个变量，但是只需要更改某个变量时，其他不变时，岂不是要写很多代码，xlua考虑到这一点，也做了一个方式，就是引用一个lua库：uitl.lua.txt。<br>具体位置是在XLua\Resources\xlua文件夹下，把它复制到和自己写的lua文本一个目录下就可以了。</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> util=<span class="hljs-built_in">require</span> <span class="hljs-string">&#x27;util&#x27;</span>xlua.private_accessible(CS.BoxPlayer)util.hotfix_ex(CS.BoxPlayer,<span class="hljs-string">&#x27;Start&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>       <span class="hljs-built_in">self</span>.Start(<span class="hljs-built_in">self</span>)       <span class="hljs-built_in">self</span>.moveSpeed=<span class="hljs-number">15</span><span class="hljs-keyword">end</span>)</code></pre></div><p>这样是和上面一样的效果，重点就是local util=require ‘util’有了它才可以更改C#方法里的部分逻辑和变量。</p>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Xlua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xlua学习记录</title>
    <link href="/2018/05/04/Xlua%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2018/05/04/Xlua%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="下载Xlua"><a href="#下载Xlua" class="headerlink" title="下载Xlua"></a>下载Xlua</h3><p>在github上下载xlua之后，将 xlua-master/Assets下的内容拷贝到我们的工程里，如图所示：<br><img src="/img/blog/xlua/a1.png"></p><h3 id="执行字符串："><a href="#执行字符串：" class="headerlink" title="执行字符串："></a>执行字符串：</h3><p>执行时直接使用luaEnv.DoString方法来执行lua的操作</p><div class="code-wrapper"><pre><code class="hljs c#">using System.Collections;using System.Collections.Generic;using UnityEngine;using XLua;public class XluaTest : MonoBehaviour &#123;    LuaEnv luaEnv;    void Start () &#123;        luaEnv = new LuaEnv();        luaEnv.DoString(&quot;print(&#x27;运行xlua&#x27;)&quot;);        luaEnv.Dispose();       &#125;  &#125;</code></pre></div><p>运行后显示以下内容:<br><img src="/img/blog/xlua/a2.png"></p><h3 id="执行加载Lua文件"><a href="#执行加载Lua文件" class="headerlink" title="执行加载Lua文件"></a>执行加载Lua文件</h3><p>在Resources文件夹下创建一个文本文档命名为luaTest，后缀名以.lua.txt结束。打开文档编写简单lua代码：<br><img src="/img/blog/xlua/a7.png"></p><p> 回到代码中,直接使用下面的方式加载Resources文件下的lua文档，luaEnv.Dostring方法会直接进行编译:</p><div class="code-wrapper"><pre><code class="hljs c#">TextAsset t = Resources.Load&lt;TextAsset&gt;(&quot;luaTest.lua&quot;)luaEnc.DoString(t.text)</code></pre></div><p>运行后如下图所示：<br><img src="/img/blog/xlua/a4.png"></p><p>或者不使用上面的这个方式可以直接使用lua里的方法来加载lua文件：</p><div class="code-wrapper"><pre><code class="hljs vbscript">luaEnv.<span class="hljs-keyword">Do</span><span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;require &#x27;luaTest&#x27;&quot;</span>);</code></pre></div><h3 id="自定义loder"><a href="#自定义loder" class="headerlink" title="自定义loder"></a>自定义loder</h3><p><img src="/img/blog/xlua/a8.png"></p><p>官方文档介绍loder的用法，下面演示一下自定义loder，方便之处在于可以自定义执行lua时想要的一些操作：<br>新建一个文件夹StreamingAssets，再新建一个lua文件lua007.lua.txt编辑内容为print(“I am 007”)<br>在脚本中更改以下代码：</p><div class="code-wrapper"><pre><code class="hljs c#">using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;using XLua;public class CreatLoder : MonoBehaviour &#123;    void Start ()     &#123;        LuaEnv luaEnv = new LuaEnv();        luaEnv.AddLoader(Myloder);        luaEnv.DoString(&quot;require&#x27;test007&#x27;&quot;);        luaEnv.Dispose();    &#125;           public byte[]Myloder(ref string feilPath)    &#123;        string absPayh = Application.streamingAssetsPath + &quot;/&quot; + feilPath+&quot;.lua.txt&quot;;        return System.Text.Encoding.UTF8.GetBytes(File.ReadAllText(absPayh));    &#125;&#125;</code></pre></div><p>运行后：</p><p><img src="/img/blog/xlua/a5.png"></p><h3 id="通过C-访问lua中的全局变量"><a href="#通过C-访问lua中的全局变量" class="headerlink" title="通过C#访问lua中的全局变量"></a>通过C#访问lua中的全局变量</h3><p>在新场景中新建一个Resources文件夹，新建一个lua文件，编辑为：<br> a=100<br> name=”Andy”<br> IsRoot=false<br>打开脚本进行编辑</p><div class="code-wrapper"><pre><code class="hljs c#">using System.Collections;using System.Collections.Generic;using UnityEngine;using XLua;public class CSharpCalllua : MonoBehaviour &#123;       void Start () &#123;        LuaEnv luaEnv = new LuaEnv();        luaEnv.DoString(&quot;require&#x27;CSharpCalllua&#x27;&quot;);//先打开lua文件，再获取lua中的全局变量        int a = luaEnv.Global.Get&lt;int&gt;(&quot;a&quot;);s        string name = luaEnv.Global.Get&lt;string&gt;(&quot;name&quot;);        bool isroot = luaEnv.Global.Get&lt;bool&gt;(&quot;IsRoot&quot;);        Debug.Log(a);        Debug.Log(name);        Debug.Log(isroot);    &#125;              void Update () &#123;                     &#125;&#125;</code></pre></div><p>点击运行后显示：<br><img src="/img/blog/xlua/a6.png"></p>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Xlua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity中解析xml文档的简单用法</title>
    <link href="/2018/05/02/Unity%E4%B8%AD%E8%A7%A3%E6%9E%90xml%E6%96%87%E6%A1%A3%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"/>
    <url>/2018/05/02/Unity%E4%B8%AD%E8%A7%A3%E6%9E%90xml%E6%96%87%E6%A1%A3%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="创建Xml文件"><a href="#创建Xml文件" class="headerlink" title="创建Xml文件"></a>创建Xml文件</h3><p>首先，在unity项目中的根目录中创建一个xml文档，例如起名叫item.xml。再创建一个脚本，起名为XmlTest。如图所示：</p><p><img src="/img/blog/xml/x1.png"></p><p>在item.xml文档中写入以下内容：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>china<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2016<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">item1</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">item2</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>usa<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2017<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">item2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></code></pre></div><h3 id="写入代码"><a href="#写入代码" class="headerlink" title="写入代码"></a>写入代码</h3><p>在脚本里添加以下代码：</p><div class="code-wrapper"><pre><code class="hljs c#">using System.Collections;using System.Collections.Generic;using UnityEngine;using System.Xml;using System.IO;public class XmlTest : MonoBehaviour &#123;              void Start () &#123;        string path = Application.dataPath + &quot;/item.xml&quot;;        XmlDocument document=new XmlDocument();//XmlDocument是专门用来解析xml文档的        document.Load(path);//将指定路径的xml文件给document来解析        XmlNode node = document.FirstChild;//FirstChild用来获取xml中的第一个节点，也就是根节点        Debug.Log(node.Name);        XmlNodeList xmlNodeList = node.ChildNodes;//获取根节点下的所有子节点        foreach (XmlNode item in xmlNodeList) //遍历这些子节点的集合，进行判断        &#123;            if (item.Name == &quot;item1&quot;)            &#123;                foreach (XmlNode n in item.ChildNodes)                &#123;                    if (n.Name == &quot;id&quot;)                    &#123;                        Debug.Log(n.InnerText);//InnerText可以获取节点中的文本                    &#125;                    if(n.Name== &quot;name&quot;)                    &#123;                        Debug.Log(n.InnerText);                    &#125;                    if(n.Name== &quot;year&quot;)                    &#123;                        Debug.Log(n.InnerText);                    &#125;                &#125;            &#125;            else if(item.Name == &quot;item2&quot;)            &#123;                foreach (XmlNode n in item.ChildNodes)                &#123;                    if (n.Name == &quot;id&quot;)                    &#123;                        Debug.Log(n.InnerText);                    &#125;                    if (n.Name == &quot;name&quot;)                    &#123;                        Debug.Log(n.InnerText);                    &#125;                    if (n.Name == &quot;year&quot;)                    &#123;                        Debug.Log(n.InnerText);                    &#125;                &#125;            &#125;        &#125;       &#125;                     void Update () &#123;                     &#125;&#125;</code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>将脚本挂在相机下，运行后会打印以下内容：<br>（第一个打印的是根节点item的名字，后面分别打印的是item下的每个子节点(也就是item1和item2)下面的子节点的文本内容）</p><p><img src="/img/blog/xml/x2.png"></p>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NHbiernate映射工具连接MySQL的基本配置及使用</title>
    <link href="/2018/04/12/NHbiernate%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7%E8%BF%9E%E6%8E%A5MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>/2018/04/12/NHbiernate%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7%E8%BF%9E%E6%8E%A5MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="NHbiernate介绍"><a href="#NHbiernate介绍" class="headerlink" title="NHbiernate介绍"></a>NHbiernate介绍</h2><p>NHibernate是一个面向.NET环境的对象/关系数据库映射工具。对象/关系数据库映射（object/relational mapping，ORM）这个术语表示一种技术，用来把对象模型表示的对象映射到基于SQL的关系模型数据结构中去。</p><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>NHbiernate基本配置</p><ol><li>新建一个项目取名为NHibernateTest，项目中添加MySQL.Data和NHbiernate的引用。</li></ol><ol start="2"><li>在项目下创建一个XML文件，必须叫hibernate.cfg.xml ，因为NHbiernate会在根目录下找这个名字的xml文件，如果不叫这个名字会报错。并把该文件的属性设置 为始终复制。<br>在官网上找到以下代码，打开这个xml文件进行编辑：<br>官网是连的SQL Server, 这里连得是MySQL, 所以更改一下, 这里主要设置了第二行的MySQL5Dialect，和第三行的MySQLDataDriver，第四行的Server=localhost;Database=sikidb;User ID=root;Password=zzzzz;  注意一定把要访问的数据库名和用户名密码写正确。</li></ol><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-configuration</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;urn:nhibernate-configuration-2.2&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">session-factory</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connection.provider&quot;</span>&gt;</span>NHibernate.Connection.DriverConnectionProvider<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dialect&quot;</span>&gt;</span>NHibernate.Dialect.MySQL5Dialect<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connection.driver_class&quot;</span>&gt;</span>NHibernate.Driver.MySqlDataDriver<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connection.connection_string&quot;</span>&gt;</span>Server=localhost;Database=sikidb;User ID=root;Password=zzzzz;<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;show_sql&quot;</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">session-factory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-configuration</span>&gt;</span></code></pre></div><ol start="3"><li>再新建一个Model文件夹，在这个文件夹下新建一个User类,把数据库中对应的表中的每行的数据名创建成每个变量，如下:<br>user表里有四列数据就写四个对应的变量，一定要是virtual 类型的，这是NHbiernate要求写法。</li></ol><p><img src="/img/blog/nhbinate/n1.png"></p><p><img src="/img/blog/nhbinate/n2.png"></p><ol start="4"><li>在项目下在创建一个Mappings文件夹，在这个文件夹下创建一个User.hbm.xml命名的xml文件，并把它的属性里的生成操作改为嵌入的资源。打开编辑一下代码:</li></ol><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hibernate-mapping</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;urn:nhibernate-mapping-2.2&quot;</span></span><span class="hljs-tag">                   <span class="hljs-attr">assembly</span>=<span class="hljs-string">&quot;NHibernateTest&quot;</span></span><span class="hljs-tag">                   <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;NHibernateTest.Model&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">class</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">table</span> =<span class="hljs-string">&quot;users&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Int32&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">generator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;native&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">generator</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;String&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;String&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Registerdate&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;registerdate&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Date&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hibernate-mapping</span>&gt;</span></code></pre></div><p>这里主要是配置NHbiernate的映射，数据库里的表的每行数据名和类型都要正确填写，主键要多设置一行自动增长    <generator class="native"></generator>，以下是数据库每行数据名和类型:</p><p><img src="/img/blog/nhbinate/n3.png"></p><p>到这里就基本配置完成了，下图是各个文件目录:</p><p><img src="/img/blog/nhbinate/n4.png"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在主函数里写下以下代码，测试一下NHbiernate连接MySql增加数据的功能</p><div class="code-wrapper"><pre><code class="hljs c#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using NHibernate;using NHibernate.Cfg;using NHibernateTest.Model;//引入自己创建的目录下的类namespace NHibernateTest&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            var config = new Configuration();            config.Configure();//开始解析文件hibernate.cfg.xml            config.AddAssembly(&quot;NHibernateTest&quot;);            ISessionFactory sessionFactory = null;            ISession session = null;            try            &#123;                sessionFactory = config.BuildSessionFactory();                session = sessionFactory.OpenSession();//打开一个跟数据库的会话                User user = new User() &#123; Username = &quot;vvvv&quot;, Password = &quot;121212&quot; &#125;;                session.Save(user);//NHibernate里面的增加数据的方式,Session实例由ISessionFactory构建                //Session是Hibernate持久化操作的基础，提供了众多持久化方法，如save、update、delete等。通过这些方法，透明地完成对象的增加、删除、修改、查找等操作。            &#125;            catch (Exception e)            &#123;                Console.WriteLine(e);            &#125;            finally            &#123;                if (session != null)                &#123;                    session.Close();                &#125;                if (sessionFactory != null)                &#123;                    sessionFactory.Close();                &#125;            &#125;            Console.ReadKey();        &#125;    &#125;&#125;</code></pre></div><h4 id="运行前后对比"><a href="#运行前后对比" class="headerlink" title="运行前后对比"></a>运行前后对比</h4><p>这张图是以上代码没有运行前数据库中的user表里的数据：</p><p><img src="/img/blog/nhbinate/n5.png"></p><p>这个是运行后，数据库的数据，可以看到在最后增加了一条Username = “vvvv”, Password = “121212”，的数据：</p><p><img src="/img/blog/nhbinate/n6.png"></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>删除的不能直接使用session.Delete(user) ，百度了一下这段话: delete()方法用于从数据库中删除与Java对象对应的记录。如果传入的参数是持久化对象，Session就计划执行一个delete语句。如果传入的参数是游离对象，先使游离对象被Session关联，使它变为持久化对象，然后计划执行一个delete语句。值得注意的是，Session只有在清理缓存的时候的才执行delete语句。此外，只有当调用Session的close()方法时，才会从Session的缓存中删除该对象。需要先清理缓存，才可以执行删除：</p><div class="code-wrapper"><pre><code class="hljs c#">try&#123;    sessionFactory = config.BuildSessionFactory();    session = sessionFactory.OpenSession();//打开一个跟数据库的会话    ITransaction transaction = session.BeginTransaction();//开启事务。删除的话需要写上这一句话，在提交事务时才可以删掉，不写的话，控制台不报任何错误，但是也没有删掉数据    User user = new User() &#123;Id=18&#125;;    session.Delete(user);    transaction.Commit();// 提交事务,清理缓存，执行delete语句 &#125;catch (Exception e)&#123;    Console.WriteLine(e);&#125;finally&#123;    if (session != null)    &#123;        session.Close();    &#125;    if (sessionFactory != null)    &#123;        sessionFactory.Close();    &#125;&#125;</code></pre></div><p>siki视频中的利用NHbiernate事务机制来增加和删除：<br>关于关闭这些需要注意，先开启的后关闭，后开启的先关闭</p><div class="code-wrapper"><pre><code class="hljs c#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using NHibernate;using NHibernate.Cfg;using NHibernateTest.Model;//引入自己创建的目录下的类namespace NHibernateTest&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            var config = new Configuration();            config.Configure();//开始解析文件hibernate.cfg.xml            config.AddAssembly(&quot;NHibernateTest&quot;);            ISessionFactory sessionFactory = null;            ISession session = null;            ITransaction transaction = null;            try            &#123;                sessionFactory = config.BuildSessionFactory();                session = sessionFactory.OpenSession();//打开一个跟数据库的会话                transaction = session.BeginTransaction();//注册事务                User user = new User() &#123; Username = &quot;qwrrtu&quot;, Password = &quot;131313&quot; &#125;;                User user1 = new User() &#123; Id = 26 &#125;; //删除操作，只给主键值就可以了                session.Save(user);                session.Delete(user1);                transaction.Commit();//开启事务            &#125;            catch (Exception e)            &#123;                Console.WriteLine(e);            &#125;            finally //关于关闭这些需要注意，先开启的后关闭，后开启的先关闭            &#123;                if (transaction != null)                &#123;                    transaction.Dispose();                &#125;                if (session != null)                &#123;                    session.Close();                &#125;                if (sessionFactory != null)                &#123;                    sessionFactory.Close();                &#125;            &#125;            Console.ReadKey();        &#125;    &#125;&#125;</code></pre></div><hr><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>以上就是基本写法，但是由于执行增删改查时频繁的使用ISessionFactory来创建会话，所以封装一个类来创建会话，需要执行这些操作的时候直接引用这个管理类里面的方法就可以了: </p><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>首先添加一个类,命名为NHibernateHelper ,添加以下代码：(在这里进行创建会话，不用每次使用时都新开一个会话)</p><div class="code-wrapper"><pre><code class="hljs c#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using NHibernate;using NHibernate.Cfg;using NHibernate.Criterion;namespace NHibernateTest&#123;    public class NHibernateHelper    &#123;        private static ISessionFactory _sessionFactory;        public static ISessionFactory SessionFactory        &#123;            get            &#123;                if (_sessionFactory == null)                &#123;                    var config = new Configuration();                    config.Configure();//开始解析文件hibernate.cfg.xml                    config.AddAssembly(&quot;NHibernateTest&quot;);                    _sessionFactory = config.BuildSessionFactory();                &#125;                return _sessionFactory;            &#125;        &#125;        public static ISession OpenSession()        &#123;            return SessionFactory.OpenSession();        &#125;    &#125;&#125;</code></pre></div><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>在目录下创建一个叫Manager的文件夹，添加一个接口，命名为IUsermanager ，写入以下代码：<br>(这里定义了一些增删改查的方法，和通过ID查询用户数据的复杂查询方法，和验证用户名密码是否存在的方法)</p><div class="code-wrapper"><pre><code class="hljs c#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using NHibernateTest.Model;namespace NHibernateTest.Manager&#123;    public interface IUserManager    &#123;        /// &lt;summary&gt;        /// 添加数据        /// &lt;/summary&gt;        /// &lt;param name=&quot;user&quot;&gt;User表中的数据&lt;/param&gt;        void Add(User user);        /// &lt;summary&gt;        /// 更新数据        /// &lt;/summary&gt;        /// &lt;param name=&quot;user&quot;&gt;User表中的数据&lt;/param&gt;        void Updata(User user);        /// &lt;summary&gt;        /// 删除某条指定数据        /// &lt;/summary&gt;        /// &lt;param name=&quot;user&quot;&gt;User表中的数据&lt;/param&gt;        void Delete(User user);        /// &lt;summary&gt;        /// 通过用户ID查询数据        /// &lt;/summary&gt;        /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        User GetUserById(int id);        /// &lt;summary&gt;        /// 通过用户名查询数据        /// &lt;/summary&gt;        /// &lt;param name=&quot;username&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        User GetUserByUsername(string username);        /// &lt;summary&gt;        /// 查询表中所有数据        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        ICollection&lt;User&gt; GetAllUsers();        /// &lt;summary&gt;        /// 验证用户名密码是否存在        /// &lt;/summary&gt;        /// &lt;param name=&quot;username&quot;&gt;用户名&lt;/param&gt;        /// &lt;param name=&quot;password&quot;&gt;密码&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        bool VerifyUser(string username, string password);    &#125;&#125;</code></pre></div><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>在这个文件夹下，再添加一个叫Usermanager的类，继承自IUsermanager这个接口，写入以下代码</p><div class="code-wrapper"><pre><code class="hljs c#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using NHibernateTest.Model;using NHibernate;using NHibernate.Criterion;namespace NHibernateTest.Manager&#123;    public class UserManager : IUserManager    &#123;        public void Add(User user)        &#123;            //第一种写法：            //ISession session = NHibernateHelper.OpenSession();            //session.Save(user);            //session.Close();            //第二种写法：            //Using语句意思是在大括号里的代码执行完以后释放小括号里面的资源            //使用using，定义范围，在该范围结束时回收资源。功能等同于try&#123; &#125;Finally&#123; &#125;。            using (ISession session = NHibernateHelper.OpenSession()) //下面的代码执行完会在这路关闭session            &#123;                using(ITransaction transaction = session.BeginTransaction())                &#123;                    session.Save(user);                          transaction.Commit();//开启事务,执行完以后才会在using里关闭                &#125;                           &#125;        &#125;        public void Delete(User user)        &#123;            using (ISession session = NHibernateHelper.OpenSession())            &#123;                using (ITransaction transaction = session.BeginTransaction())                &#123;                    session.Delete(user);                          transaction.Commit();                &#125;            &#125;        &#125;        public void Updata(User user)        &#123;            using (ISession session = NHibernateHelper.OpenSession())            &#123;                using (ITransaction transaction = session.BeginTransaction())                &#123;                    session.Update(user);                          transaction.Commit();                &#125;            &#125;        &#125;        public User GetUserById(int id)        &#123;            using (ISession session = NHibernateHelper.OpenSession())            &#123;                using (ITransaction transaction = session.BeginTransaction())                &#123;                    User user = session.Get&lt;User&gt;(id);                          transaction.Commit();                    return user;//获取到user里的id后返回                &#125;            &#125;        &#125;               public ICollection&lt;User&gt; GetAllUsers()        &#123;            using (ISession session = NHibernateHelper.OpenSession())            &#123;                IList&lt;User&gt; users = session.CreateCriteria(typeof(User)).List&lt;User&gt;();//返回User里的多个值，就不能用UniqueResult了                return users;            &#125;        &#125;        public User GetUserByUsername(string username)        &#123;            using(ISession session = NHibernateHelper.OpenSession())            &#123;                //第一种写法：                //CreateCriteria方法是指定要查询哪个表格，接收类型参数,把user这个类型传给他就可以了                //ICriteria criteria = session.CreateCriteria(typeof(User));                //criteria.Add(Restrictions.Eq(&quot;Username&quot;, username));//Restrictions.Eq 等于的意思                //User user = criteria.UniqueResult&lt;User&gt;();//UniqueResult 这里只返回一个值                //第一种的简写方式:                User user = session.CreateCriteria(typeof(User)).Add(Restrictions.Eq(&quot;Username&quot;, username)).UniqueResult&lt;User&gt;();                return user;            &#125;        &#125;        public bool VerifyUser(string username, string password)        &#123;            using (ISession session = NHibernateHelper.OpenSession())            &#123;                //和通过用户名查询数据类似，这里多加一个密码条件就可以了                User user = session.CreateCriteria(typeof(User)) .Add(Restrictions.Eq(&quot;Username&quot;, username)) .Add(Restrictions.Eq(&quot;Password&quot;, password)) .UniqueResult&lt;User&gt;();                if (user == null)                &#123;                    return false;                &#125;                return true;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>最后在主函数里进行测试这些封装的方法</p><div class="code-wrapper"><pre><code class="hljs c#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using NHibernate;using NHibernate.Cfg;using NHibernateTest.Model;using NHibernateTest.Manager;namespace NHibernateTest&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //添加数据            //UserManager userManager = new UserManager();            //User user = new User &#123; Username = &quot;mmmm&quot;, Password = &quot;00000&quot; &#125;;            //userManager.Add(user);            //更新数据            //UserManager userManager = new UserManager();            //User user = new User &#123; Id=29 , Username=&quot;哈哈&quot;,Password=&quot;0000123&quot; &#125;;            //userManager.Updata(user);            //删除数据            //UserManager userManager = new UserManager();            //User user = new User &#123; Id = 29&#125;;            //userManager.Delete(user);            //根据用户ID查询数据            //UserManager userManager = new UserManager();            //User user = userManager.GetUserById(11);            //Console.WriteLine(user.Username+&quot; &quot;+user.Password);            //根据用户名查询数据            //UserManager userManager = new UserManager();            //User user = userManager.GetUserByUsername(&quot;wer23&quot;);            //Console.WriteLine(user.Id + &quot; &quot; + user.Password);            //查询表里的所有数据            //UserManager userManager = new UserManager();            //ICollection&lt;User&gt; users = userManager.GetAllUsers();            //foreach (var item in users)            //&#123;            //    Console.WriteLine(item.Id+&quot; &quot;+item.Username+&quot; &quot;+item.Password);            //&#125;            //验证用户名密码是否存在            UserManager userManager = new UserManager();            Console.WriteLine(userManager.VerifyUser(&quot;wer&quot;,&quot;123&quot;));//如果存在返回true,不存在返回fasle            Console.ReadKey();        &#125;    &#125;&#125;</code></pre></div><hr><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>关于Restrictions的各种用法：</p><p><img src="/img/blog/nhbinate/n7.png"></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>MySql</tag>
      
      <tag>NHbiernate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#连接数据库初学笔记</title>
    <link href="/2018/04/12/C-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2018/04/12/C-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>打开解决方案，首先添加MySQL文件目录下的Mysql.data的引用，写入以下代码：<br>此脚本最后会打印出要查询的表里的所有数据，要保证数据库名，和用户名密码都正确才可以，不然会报错</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><div class="code-wrapper"><pre><code class="hljs c#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using MySql.Data.MySqlClient;namespace test&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //服务器地址，端口号，数据库名，用户名，密码            string connect = &quot;server=127.0.0.1;port=3306;database=sikidb;user=root;password=zzzzz;&quot;;            MySqlConnection con = new MySqlConnection(connect); //开始跟数据库建立连接                      try            &#123;                con.Open();//首先打开链接                string sqlCmd = &quot;select * from users&quot;;//查询整个表（SQL命令语句,不能写错，否则执行不了）                //select id,username,registerdate from users 查询这个表里指定的列                              MySqlCommand cmd = new MySqlCommand(sqlCmd, con); //1：执行命令的语句，2：打开的通道连接                //cmd.ExecuteNonQuery();//执行插入、删除操作                //cmd.ExecuteScalar();//读取数据，和cmd.ExecuteReader()的区别是，这个返回单个的值                //cmd.ExecuteReader();//读取数据，返回MySqlDataReader类型                MySqlDataReader dataReader = cmd.ExecuteReader();                //dataReader.Read();//读取表里的下一行数据，读取到返回true，没有下一行数据返回false                int a = 0;                while (dataReader.Read())                &#123;                    a++;                    Console.WriteLine(dataReader[0].ToString()+&quot; &quot; + dataReader[1].ToString()+ &quot; &quot; + dataReader[2].ToString());                    if (dataReader[1].ToString() == &quot;wer&quot;) //测试，找到这个叫wer的人在第几行数据                    &#123;                        Console.WriteLine($&quot;找到这个人了,在第&#123;a&#125;行数据&quot;);                    &#125;                &#125;            &#125;            catch (Exception e)            &#123;                Console.WriteLine(e.ToString());            &#125;            finally            &#123;                con.Close();            &#125;                       Console.ReadKey();        &#125;    &#125;&#125;</code></pre></div><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><div class="code-wrapper"><pre><code class="hljs c#">static void InsertShuJu()    &#123;        //服务器地址，端口号，数据库名，用户名，密码        string connect = &quot;server=127.0.0.1;port=3306;database=sikidb;user=root;password=zzzzz;&quot;;        MySqlConnection con = new MySqlConnection(connect); //开始跟数据库建立连接        try        &#123;            con.Open();//首先打开链接            string name = &quot;aaa&quot;;            string sqlCmd = &quot;insert into users(username,password,registerdate) values(&#x27;&quot;+name+&quot;&#x27;,&#x27;000&#x27;,&#x27;&quot;+DateTime.Now+&quot;&#x27;)&quot;;//插入自定义用户名，密码，和当前时间            MySqlCommand cmd = new MySqlCommand(sqlCmd, con); //1：执行命令的语句，2：打开的通道连接            //cmd.ExecuteNonQuery();//执行插入、删除操作                     int result = cmd.ExecuteNonQuery();//返回值是数据库中受影响的数据行数，现在是插入一行，所以返回值会是1        &#125;        catch (Exception e)        &#123;            Console.WriteLine(e.ToString());        &#125;        finally        &#123;            con.Close();        &#125;    &#125;</code></pre></div><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>把命令改掉就可以了，undate指令可以更新数据，下面的命令意思是把id为11的用户名密码替换为kkkk，666</p><div class="code-wrapper"><pre><code class="hljs c#">string sqlCmd = &quot;update users set username=&#x27;kkkk&#x27;,password=&#x27;666&#x27; where id=&#x27;11&#x27;&quot;;</code></pre></div><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>把命令改掉就可以了,此命令意思是删除id=10的那条数据</p><div class="code-wrapper"><pre><code class="hljs c#">string sqlCmd = &quot;delete from users where id=&#x27;10&#x27;&quot;;</code></pre></div><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>另一种读取数据的方式：<br>指定读取的列的名字就可以了</p> <div class="code-wrapper"><pre><code class="hljs c#">Console.WriteLine(dataReader.GetInt32(&quot;id&quot;) + &quot; &quot; + dataReader.GetString(&quot;username&quot;) + &quot; &quot; + dataReader.GetString(&quot;password&quot;));</code></pre></div><h3 id="实验-验证用户名密码是否存在"><a href="#实验-验证用户名密码是否存在" class="headerlink" title="实验 验证用户名密码是否存在"></a>实验 验证用户名密码是否存在</h3> <div class="code-wrapper"><pre><code class="hljs c#">//验证用户名密码是否存在static bool Verification(string username,string password)&#123;    //服务器地址，端口号，数据库名，用户名，密码    string connect = &quot;server=127.0.0.1;port=3306;database=sikidb;user=root;password=zzzzz;&quot;;    MySqlConnection con = new MySqlConnection(connect); //开始跟数据库建立连接    try    &#123;        con.Open();//首先打开链接        string sqlCmd = &quot;select * from users where username = @data1 and password = @data2&quot;;        MySqlCommand cmd = new MySqlCommand(sqlCmd, con);        cmd.Parameters.AddWithValue(&quot;data1&quot;, username);        cmd.Parameters.AddWithValue(&quot;data2&quot;, password);               MySqlDataReader dataReader = cmd.ExecuteReader();        if (dataReader.Read())        &#123;            return true;                  &#125;          &#125;    catch (Exception e)    &#123;        Console.WriteLine(e.ToString());    &#125;    finally    &#123;        con.Close();    &#125;    return false;&#125;</code></pre></div><p>然后再主函数里做测试</p><div class="code-wrapper"><pre><code class="hljs C#">static void Main(string[] args)&#123;    //Reader();    //InsertShuJu();    //Update();    //deleteShuJu();    bool user = Verification(&quot;wer&quot;, &quot;000&quot;); //检测这个账号密码    if (user)    &#123;        Console.WriteLine(&quot;用户存在，允许登录&quot;);    &#125;    else    &#123;        Console.WriteLine(&quot;用户不存在，请重新输入账号密码&quot;);    &#125;    Console.ReadKey();&#125;</code></pre></div><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>以下是整个 代码连接MySQL数据库的增删改查，检测用户账号密码是否存在的脚本</p><div class="code-wrapper"><pre><code class="hljs c#">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using MySql.Data.MySqlClient;namespace test&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //Reader();            //InsertShuJu();            //Update();            //deleteShuJu();            bool user = Verification(&quot;wer&quot;, &quot;000&quot;);            if (user)            &#123;                Console.WriteLine(&quot;用户存在，允许登录&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;用户不存在，请重新输入账号密码&quot;);            &#125;            Console.ReadKey();        &#125;        //验证用户名密码是否存在        static bool Verification(string username,string password)        &#123;            //服务器地址，端口号，数据库名，用户名，密码            string connect = &quot;server=127.0.0.1;port=3306;database=sikidb;user=root;password=zzzzz;&quot;;            MySqlConnection con = new MySqlConnection(connect); //开始跟数据库建立连接            try            &#123;                con.Open();//首先打开链接                string sqlCmd = &quot;select * from users where username = @data1 and password = @data2&quot;;                MySqlCommand cmd = new MySqlCommand(sqlCmd, con);                cmd.Parameters.AddWithValue(&quot;data1&quot;, username);                cmd.Parameters.AddWithValue(&quot;data2&quot;, password);                               MySqlDataReader dataReader = cmd.ExecuteReader();                if (dataReader.Read())                &#123;                    return true;                                  &#125;                          &#125;            catch (Exception e)            &#123;                Console.WriteLine(e.ToString());            &#125;            finally            &#123;                con.Close();            &#125;            return false;        &#125;        static void Reader() //查询数据        &#123;            //服务器地址，端口号，数据库名，用户名，密码            string connect = &quot;server=127.0.0.1;port=3306;database=sikidb;user=root;password=zzzzz;&quot;;            MySqlConnection con = new MySqlConnection(connect); //开始跟数据库建立连接            try            &#123;                con.Open();//首先打开链接                string sqlCmd = &quot;select * from users&quot;;//查询整个表（SQL命令语句,不能写错，否则执行不了）                //select id,username,registerdate from users 查询这个表里指定的列                             MySqlCommand cmd = new MySqlCommand(sqlCmd, con); //1：执行命令的语句，2：打开的通道连接                //cmd.ExecuteNonQuery();//执行插入、删除操作                //cmd.ExecuteScalar();//读取数据，和cmd.ExecuteReader()的区别是，这个返回单个的值                //cmd.ExecuteReader();//读取数据，返回MySqlDataReader类型                MySqlDataReader dataReader = cmd.ExecuteReader();                //dataReader.Read();//读取表里的下一行数据，读取到返回true，没有下一行数据返回false                int a = 0;                while (dataReader.Read())                &#123;                    a++;                    Console.WriteLine(dataReader.GetInt32(&quot;id&quot;) + &quot; &quot; + dataReader.GetString(&quot;username&quot;) + &quot; &quot; + dataReader.GetString(&quot;password&quot;));                    if (dataReader[1].ToString() == &quot;wer&quot;) //测试，找到这个叫wer的人在第几行数据                    &#123;                        Console.WriteLine($&quot;找到这个人了,在第&#123;a&#125;行数据&quot;);                    &#125;                &#125;            &#125;            catch (Exception e)            &#123;                Console.WriteLine(e.ToString());            &#125;            finally            &#123;                con.Close();            &#125;        &#125;        static void InsertShuJu() //增加数据        &#123;            //服务器地址，端口号，数据库名，用户名，密码            string connect = &quot;server=127.0.0.1;port=3306;database=sikidb;user=root;password=zzzzz;&quot;;            MySqlConnection con = new MySqlConnection(connect); //开始跟数据库建立连接            try            &#123;                con.Open();//首先打开链接                string name = &quot;aaa&quot;;                //插入自定义用户名，密码，和当前时间                string sqlCmd = &quot;insert into users(username,password,registerdate) values(&#x27;&quot;+name+&quot;&#x27;,&#x27;000&#x27;,&#x27;&quot;+DateTime.Now+&quot;&#x27;)&quot;;                MySqlCommand cmd = new MySqlCommand(sqlCmd, con); //1：执行命令的语句，2：打开的通道连接                //cmd.ExecuteNonQuery();//执行插入、删除操作                             int result = cmd.ExecuteNonQuery();//返回值是数据库中受影响的数据行数，现在是插入一行，所以返回值会是1            &#125;            catch (Exception e)            &#123;                Console.WriteLine(e.ToString());            &#125;            finally            &#123;                con.Close();            &#125;        &#125;        static void Update() //更新某一条指定数据        &#123;            //服务器地址，端口号，数据库名，用户名，密码            string connect = &quot;server=127.0.0.1;port=3306;database=sikidb;user=root;password=zzzzz;&quot;;            MySqlConnection con = new MySqlConnection(connect); //开始跟数据库建立连接            try            &#123;                con.Open();//首先打开链接                              string sqlCmd = &quot;update users set username=&#x27;kkkk&#x27;,password=&#x27;666&#x27; where id=&#x27;11&#x27;&quot;;                MySqlCommand cmd = new MySqlCommand(sqlCmd, con); //1：执行命令的语句，2：打开的通道连接                //cmd.ExecuteNonQuery();//执行插入、删除操作                int result = cmd.ExecuteNonQuery();//返回值是数据库中受影响的数据行数，现在是插入一行，所以返回值会是1            &#125;            catch (Exception e)            &#123;                Console.WriteLine(e.ToString());            &#125;            finally            &#123;                con.Close();            &#125;        &#125;        static void deleteShuJu() //删除某一条指定数据        &#123;            //服务器地址，端口号，数据库名，用户名，密码            string connect = &quot;server=127.0.0.1;port=3306;database=sikidb;user=root;password=zzzzz;&quot;;            MySqlConnection con = new MySqlConnection(connect); //开始跟数据库建立连接            try            &#123;                con.Open();//首先打开链接                string sqlCmd = &quot;delete from users where id=&#x27;10&#x27;&quot;;                MySqlCommand cmd = new MySqlCommand(sqlCmd, con); //1：执行命令的语句，2：打开的通道连接                //cmd.ExecuteNonQuery();//执行插入、删除操作                int result = cmd.ExecuteNonQuery();//返回值是数据库中受影响的数据行数，现在是插入一行，所以返回值会是1            &#125;            catch (Exception e)            &#123;                Console.WriteLine(e.ToString());            &#125;            finally            &#123;                con.Close();            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>MySql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity展示鼠标滚动效果</title>
    <link href="/2018/04/10/Unity%E5%B1%95%E7%A4%BA%E9%BC%A0%E6%A0%87%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C/"/>
    <url>/2018/04/10/Unity%E5%B1%95%E7%A4%BA%E9%BC%A0%E6%A0%87%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h5 id="鼠标操作物体旋转做3D展示，以及滚轮滑动远近距离观察功能"><a href="#鼠标操作物体旋转做3D展示，以及滚轮滑动远近距离观察功能" class="headerlink" title="鼠标操作物体旋转做3D展示，以及滚轮滑动远近距离观察功能"></a>鼠标操作物体旋转做3D展示，以及滚轮滑动远近距离观察功能</h5><p>以下脚本挂在物体上，把场景中相机给到变量中</p><div class="code-wrapper"><pre><code class="hljs c#">using UnityEngine;using System.Collections;using System.Collections.Generic;public class test : MonoBehaviour&#123;    public Camera cam;    public float speed;    void Update()    &#123;        transform.Rotate(Vector3.up, Space.World);//物体自身一直旋转        Vector3 fwd = cam.transform.forward;        fwd.Normalize();         //利用叉乘得到的向量来旋转        if (Input.GetMouseButton(0))        &#123;            Vector3 vaxis = Vector3.Cross(fwd, Vector3.right);            transform.Rotate(vaxis, -Input.GetAxis(&quot;Mouse X&quot;)* speed, Space.World);            Vector3 haxis = Vector3.Cross(fwd, Vector3.up);            transform.Rotate(haxis, -Input.GetAxis(&quot;Mouse Y&quot;)* speed, Space.World);        &#125;                if (Input.GetAxis(&quot;Mouse ScrollWheel&quot;) &lt; 0)        &#123;            Debug.Log(&quot;向后滑动&quot;);            if (cam.fieldOfView &lt;= 80) //限制滑动范围                cam.fieldOfView += 2;        &#125;               if (Input.GetAxis(&quot;Mouse ScrollWheel&quot;) &gt; 0)        &#123;            Debug.Log(&quot;向前滑动&quot;);            if (cam.fieldOfView &gt; 25) //限制滑动范围                cam.fieldOfView -= 2;        &#125;    &#125; &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOTween插件学习</title>
    <link href="/2018/04/08/DOTween%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2018/04/08/DOTween%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="脚本1"><a href="#脚本1" class="headerlink" title="脚本1"></a>脚本1</h3><p>挂在场景物体上,使物体移动的方法</p><div class="code-wrapper"><pre><code class="hljs c#">using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;//using DoTween的命名空间public class test_one : MonoBehaviour &#123;    public Vector3 tweenV3 = new Vector3(0, 0, 0);          void Start ()    &#123;        tweenV3= transform.position;        //DOTween里的To方法：        //对变量进行移动，固定写法，前两个参数是固定的,指向变量，第三个参数是要移到的位置，第四个是移动所用的时间        DOTween.To(() =&gt; tweenV3, x =&gt; tweenV3 = x, new Vector3(0, 0, 0), 5);       &#125;                     void Update () &#123;               transform.position = tweenV3;//给物体位置赋值，进行移动    &#125;&#125;</code></pre></div><h3 id="脚本2"><a href="#脚本2" class="headerlink" title="脚本2"></a>脚本2</h3><p>挂在UI上，使UI移动的方法</p><div class="code-wrapper"><pre><code class="hljs c#">public RectTransform rectTransform;private void Start()&#123;   rectTransform.DOLocalMove(new Vector3(0, 0, 0), 1);//使用此方法可以使UI图片在一秒内从外面移动到画布中心点(DOLocalMove是自身坐标，DOMove是世界坐标)&#125;</code></pre></div><h3 id="脚本3"><a href="#脚本3" class="headerlink" title="脚本3"></a>脚本3</h3><p>点击button，使图片在屏幕外面移动到屏幕中间, 再点击的话再从屏幕内移出去 (此脚本挂在要移动的图片上,并给button添加事件)。</p><div class="code-wrapper"><pre><code class="hljs c#">using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;//using DoTween的命名空间public class test_one : MonoBehaviour &#123;     public RectTransform rectTransform;//图片    bool IsInScreen = false;//判断图片是否在屏幕内    void Start()    &#123;        //使用此方法可以使UI图片在一秒内从外面移动到画布中心点(DOLocalMove是自身坐标，DOMove是世界坐标)        //Tweener对象保存每个创建出来的动画信息，每次调用do方法都会创建一个tweener对象，所以为了不消耗内存，在start里创建一次，后面就不用创建了        Tweener tweener = rectTransform.DOLocalMove(new Vector3(0, 0, 0), 0.3f);        tweener.SetAutoKill(false);//动画每次播放完会自动销毁，所以在start里创建的话不需要销毁，就把它设置为false        tweener.Pause();//在没有调用前先让它暂停    &#125;       public void Onclick()    &#123;        if (IsInScreen == false)        &#123;            rectTransform.DOPlayForward();//动画前放。点击按钮时，开始播放动画，注意这里不能使用DOPlay，因为DOPlay只调用一次            IsInScreen = true;        &#125;        else        &#123;            rectTransform.DOPlayBackwards();//动画倒放,如果在屏幕里就让它出去            IsInScreen = false;        &#125;    &#125;&#125;</code></pre></div><h3 id="其他相关用法"><a href="#其他相关用法" class="headerlink" title="其他相关用法"></a>其他相关用法</h3><ol><li></li></ol><div class="code-wrapper"><pre><code class="hljs c#">//默认是从自身位置移动到目标X位置，后面加上From()后就成了从目标位置移动到自身位置transform.DOLocalMoveX5, 1).From();</code></pre></div><ol start="2"><li></li></ol><div class="code-wrapper"><pre><code class="hljs c#">void Start () &#123;    Tweener tw= transform.DOLocalMoveX(5, 1);从自身位置移动到目标X位置    tw.SetEase(Ease.OutBounce);设置移动曲线方式，Ease是DOTween自带的枚举，里面有各种各样的曲线，可以自行挑选合适的来使用    tw.OnComplete(OnTween);DOTween自带动画事件函数，会在动画播放完以后调用（官方文档还有其他几种生命周期函数）&#125;void OnTween()&#123;    Debug.Log(&quot;动画播放完成了&quot;);&#125;</code></pre></div><p>3.<br>文字的动画效果，使用以下方法会有逐字显示的效果(可以做一些对话的显示，或者关卡名的显示)</p><div class="code-wrapper"><pre><code class="hljs c#">Text text;      void Start () &#123;  text.DOText(&quot;xxxxxxxxxxx&quot;, 2);//第一个参数是要显示的字符串，第二个参数是所用时间&#125;</code></pre></div><p>4.</p><p>屏幕震动效果</p><div class="code-wrapper"><pre><code class="hljs c#">transform.DOShakePosition(1);//DOTween自带的使相机自身随机抖动的方法，只写1的话就是抖动1秒，后面可以加new Vector3()参数，分别控制相机的X,Y,Z轴的抖动距离,例如： transform.DOShakePosition(1,new Vector3(1,1,0));</code></pre></div><ol start="5"><li></li></ol><p>颜色渐变效果(主要用在UI上，物体不行):</p><div class="code-wrapper"><pre><code class="hljs c#">image.DOColor(Color.blue, 2);//第一个是颜色，第二个是过度的时间，Text文字也是一样的方式透明度渐变效果：image.DOFade(1, 3);//第一个参数是透明度值（测试时可以在场景中把图片透明度设置为0），第二个参数是所用时间</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity AssetBundle加载资源包的四种方式</title>
    <link href="/2018/04/04/AssetBundle%E8%B5%84%E6%BA%90%E5%8C%85%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2018/04/04/AssetBundle%E8%B5%84%E6%BA%90%E5%8C%85%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="方式1-AssetBundle-LoadFromMemoryAsync-从内存异步加载"><a href="#方式1-AssetBundle-LoadFromMemoryAsync-从内存异步加载" class="headerlink" title="方式1 AssetBundle.LoadFromMemoryAsync 从内存异步加载"></a>方式1 AssetBundle.LoadFromMemoryAsync 从内存异步加载</h3><p>先通过File转化成byte数组，再从字节数组里读取转化成Assetbundle</p><div class="code-wrapper"><pre><code class="hljs c#">IEnumerator aaa() &#123;      string ziyuan = &quot;/Perfabs/xxx.assetbundle&quot;;//项目路径下的某个包      AssetBundleCreateRequest request =  AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(ziyuan));//创建一个请求,异步的方式       yield return request;//等待load完成      AssetBundle ab = request.assetBundle;//加载完后取到request里面的assetBundle对象       //加载方式相同      GameObject obj = ab.LoadAsset&lt;GameObject&gt;(&quot;xxx&quot;); &#125;</code></pre></div><h3 id="方式2-AssetBundle-LoadFromFile-从文件加载"><a href="#方式2-AssetBundle-LoadFromFile-从文件加载" class="headerlink" title="方式2  AssetBundle.LoadFromFile  从文件加载"></a>方式2  AssetBundle.LoadFromFile  从文件加载</h3><div class="code-wrapper"><pre><code class="hljs c#">void bbb()&#123;    string path = &quot;C:/Users/zhengwenke/Documents/unity/new/and/xxx.assetbundle&quot;;//完整路径     AssetBundle ab = AssetBundle.LoadFromFile(path);     GameObject obj = ab.LoadAsset&lt;GameObject&gt;(&quot;xxx&quot;);&#125;</code></pre></div><h3 id="方式3-服务器加载或者本地加载"><a href="#方式3-服务器加载或者本地加载" class="headerlink" title="方式3 服务器加载或者本地加载"></a>方式3 服务器加载或者本地加载</h3><p> 这种方式将要被UnityWebRequest代替，unity2017之后尽量使用第二种和第四种</p><div class="code-wrapper"><pre><code class="hljs c#"> IEnumerator ccc()&#123;                    //这是从本地路径加载，如果从服务器加载直接把http的地址换一下就可以了                string path = @&quot;file://D:\VMNEW\Trunk\Resources\Model32\77426_box.assetbundle&quot;; //路径斜杠不能写错，不然会报未知错误                while (Caching.ready == false)                &#123;                   yield return null;                &#125;                WWW www = WWW.LoadFromCacheOrDownload(path, 1);                yield return www;                //www有错误不会终止运行，所以要判断是否有错误信息                if (string.IsNullOrEmpty(www.error)==false)                &#123;                    Debug.Log(www.error);                    yield break;                &#125;                AssetBundle ab = www.assetBundle;                //加载方式相同                GameObject obj = ab.LoadAsset&lt;GameObject&gt;(&quot;xxx&quot;);&#125;</code></pre></div><h3 id="方式4-服务器加载或者本地加载"><a href="#方式4-服务器加载或者本地加载" class="headerlink" title="方式4 服务器加载或者本地加载"></a>方式4 服务器加载或者本地加载</h3><div class="code-wrapper"><pre><code class="hljs c#">IEnumerator ddd()            &#123;                //这是从本地路径加载，如果从服务器加载直接把http的地址换一下就可以了                string uri = @&quot;file:///C:/Users/zhengwenke/Documents/unity/new/and/xxx.assetbundle&quot;;                UnityWebRequest request = UnityWebRequest.GetAssetBundle(uri);                yield return request.SendWebRequest();                     //第一种方式                 AssetBundle ab = DownloadHandlerAssetBundle.GetContent(request);                     //第二种方式                 //AssetBundle ab = (request.downloadHandler as DownloadHandlerAssetBundle).assetBundle;                                      //加载方式相同                GameObject obj = ab.LoadAsset&lt;GameObject&gt;(&quot;xxx&quot;);            &#125;</code></pre></div><p>WWW的加载方式，在运行的时候会自动生成该包里的缓存在C盘里，如果下次再解压这个包，它会先去这个缓存里找，没有的话才会加载，所以不想让它有缓存的话，就用本地路径加载的方式，下图是目录位置<br><img src="/img/blog/assetbunle/a1.png"></p>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
      <tag>AssetBundle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity AssetBundle初体验</title>
    <link href="/2018/03/22/Unity-AssetBundle/"/>
    <url>/2018/03/22/Unity-AssetBundle/</url>
    
    <content type="html"><![CDATA[<h3 id="加载资源脚本"><a href="#加载资源脚本" class="headerlink" title="加载资源脚本"></a>加载资源脚本</h3><div class="code-wrapper"><pre><code class="hljs c#">using System.Collections;using System.Collections.Generic;using UnityEngine;public class JIAZAI : MonoBehaviour&#123;    void Start()    &#123;       //从本地加载包里的object        AssetBundle ab = AssetBundle.LoadFromFile(&quot;AssetBundles/ca.assets&quot;);        Object[] objs = ab.LoadAllAssets();        //加载材质        AssetBundle m = AssetBundle.LoadFromFile(&quot;AssetBundles/cy.assets&quot;);        var material = m.LoadAllAssets();        foreach (Object item in objs)        &#123;            Instantiate(item);        &#125;    &#125;&#125;</code></pre></div><h3 id="打包资源脚本（挂在相机或任何物体上）"><a href="#打包资源脚本（挂在相机或任何物体上）" class="headerlink" title="打包资源脚本（挂在相机或任何物体上）"></a>打包资源脚本（挂在相机或任何物体上）</h3><div class="code-wrapper"><pre><code class="hljs c#">using System.Collections;using System.Collections.Generic;using System.IO;using UnityEditor;using UnityEngine;public class NewBehaviourScript : Editor &#123;    public class CreateAssetBundles    &#123;        [MenuItem(&quot;Assets/Build AssetBundles&quot;)]        static void BuildAllAssetBundles()        &#123;            //定义文件夹名字            string dir = &quot;AssetBundles&quot;;            //文件夹不存在，则创建            if (!Directory.Exists(dir))            &#123;                Directory.CreateDirectory(dir);            &#125;            BuildPipeline.BuildAssetBundles(dir, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
      <tag>AssetBundle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity坐标系</title>
    <link href="/2018/03/07/Unity%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
    <url>/2018/03/07/Unity%E5%9D%90%E6%A0%87%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="关于Unity的一些坐标系的知识："><a href="#关于Unity的一些坐标系的知识：" class="headerlink" title="关于Unity的一些坐标系的知识："></a>关于Unity的一些坐标系的知识：</h3><h4 id="Unity是左手坐标系"><a href="#Unity是左手坐标系" class="headerlink" title="Unity是左手坐标系"></a>Unity是左手坐标系</h4><p>世界坐标系：我们在场景中添加物体（如：Cube），他们都是以世界坐标显示在场景中的。transform.position可以获得该位置坐标。</p><p>屏幕坐标系：以像素来定义的，以屏幕的左下角为（0，0）点，右上角为（Screen.width，Screen.height），Z的位置是以相机的世界单位来衡量的。注：鼠标位置坐标属于屏幕坐标，Input.mousePosition可以获得该位置坐标，手指触摸屏幕也为屏幕坐标，Input.GetTouch(0).position可以获得单个手指触摸屏幕坐标。</p><p>绘制GUI界面的坐标系：这个坐标系与屏幕坐标系相似，不同的是该坐标系以屏幕的左上角为（0，0）点，右下角为（Screen.width，Screen.height）。</p><p>视口坐标系：视口坐标是标准的 相对于相机的。相机的左下角为（0，0）点，右上角为（1，1）点，Z的位置是以相机的世界单位来衡量的。</p><p>世界坐标→屏幕坐标：camera.WorldToScreenPoint(transform.position);这样可以将世界坐标转换为屏幕坐标。其中camera为场景中的camera对象。</p><p>屏幕坐标→视口坐标：camera.ScreenToViewportPoint(Input.GetTouch(0).position);这样可以将屏幕坐标转换为视口坐标。其中camera为场景中的camera对象。</p><p>视口坐标→屏幕坐标：camera.ViewportToScreenPoint();</p><p>视口坐标→世界坐标：camera.ViewportToWorldPoint();</p>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#接口和类的区别</title>
    <link href="/2018/03/06/C-%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2018/03/06/C-%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="接口-amp-类"><a href="#接口-amp-类" class="headerlink" title="接口&amp;类"></a>接口&amp;类</h2><p>(1) 接口不能被实例化<br>(2) 接口只能包含方法声明<br>(3) 接口的成员包括方法、属性、索引器、事件<br>(4) 接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员<br>(5) 接口中的所有成员默认为public，因此接口中不能有private修饰符<br>(6) 派生类必须实现接口的所有成员<br>(7) 一个类可以直接实现多个接口，接口之间用逗号隔开<br>(8) 一个接口可以有多个父接口，实现该接口的类必须实现所有父接口中的所有成员</p><h2 id="接口和抽象类的区别："><a href="#接口和抽象类的区别：" class="headerlink" title="接口和抽象类的区别："></a>接口和抽象类的区别：</h2><p>相同点：<br>(1) 都可以被继承<br>(2) 都不能被实例化<br>(3) 都可以包含方法声明<br>(4) 派生类必须实现未实现的方法</p><p>区 别：<br>(1) 抽象基类可以定义字段、属性、方法实现。接口只能定义属性、索引器、事件、和方法声明，不能包含字段。<br>(2) 抽象类是一个不完整的类，需要进一步细化，而接口是一个行为规范。微软的自定义接口总是后带able字段，证明其是表述一类“我能做。。。”<br>(3) 接口可以被多重实现，抽象类只能被单一继承<br>(4) 抽象类更多的是定义在一系列紧密相关的类间，而接口大多数是关系疏松但都实现某一功能的类中<br>(5) 抽象类是从一系列相关对象中抽象出来的概念， 因此反映的是事物的内部共性；接口是为了满足外部调用而定义的一个功能约定， 因此反映的是事物的外部特性<br>(6) 接口基本上不具备继承的任何具体特点,它仅仅承诺了能够调用的方法<br>(7) 接口可以用于支持回调,而继承并不具备这个特点<br>(8) 抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的<br>(9) 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">using</span> System;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> System.Linq;<span class="hljs-keyword">using</span> System.Text;<span class="hljs-keyword">namespace</span> InterfaceApplication&#123;    <span class="hljs-keyword">public</span> interface ITransactions    &#123;                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showTransaction</span><span class="hljs-params">()</span></span>;        <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getAmount</span><span class="hljs-params">()</span></span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Transaction</span> :</span> ITransactions    &#123;        <span class="hljs-keyword">private</span> string tCode;        <span class="hljs-keyword">private</span> string date;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> amount;                       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Transaction</span><span class="hljs-params">(string c, string d, <span class="hljs-keyword">double</span> a)</span></span><span class="hljs-function">        </span>&#123;            tCode = c;            date = d;            amount = a;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getAmount</span><span class="hljs-params">()</span></span><span class="hljs-function">        </span>&#123;            <span class="hljs-keyword">return</span> amount;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showTransaction</span><span class="hljs-params">()</span></span><span class="hljs-function">        </span>&#123;            <span class="hljs-built_in">Console</span>.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">&quot;Transaction: &#123;0&#125;&quot;</span>, tCode);            <span class="hljs-built_in">Console</span>.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">&quot;Date: &#123;0&#125;&quot;</span>, date);            <span class="hljs-built_in">Console</span>.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">&quot;Amount: &#123;0&#125;&quot;</span>, <span class="hljs-built_in">getAmount</span>());        &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tester</span></span><span class="hljs-class">    &#123;</span>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">(string[] args)</span></span><span class="hljs-function">        </span>&#123;            Transaction t1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Transaction</span>(<span class="hljs-string">&quot;001&quot;</span>, <span class="hljs-string">&quot;8/10/2012&quot;</span>, <span class="hljs-number">78900.00</span>);            Transaction t2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Transaction</span>(<span class="hljs-string">&quot;002&quot;</span>, <span class="hljs-string">&quot;9/10/2012&quot;</span>, <span class="hljs-number">451900.00</span>);            t1.<span class="hljs-built_in">showTransaction</span>();            t2.<span class="hljs-built_in">showTransaction</span>();            <span class="hljs-built_in">Console</span>.<span class="hljs-built_in">ReadKey</span>();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#匿名方法的使用</title>
    <link href="/2018/03/06/C-%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2018/03/06/C-%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="code-wrapper"><pre><code class="hljs c#">using System;delegate void NumberChanger(int n);namespace DelegateAppl&#123;    class TestDelegate    &#123;        static int num = 10;        public static void AddNum(int p)        &#123;            num += p;            Console.WriteLine(&quot;Named Method: &#123;0&#125;&quot;, num);        &#125;        public static void MultNum(int q)        &#123;            num *= q;            Console.WriteLine(&quot;Named Method: &#123;0&#125;&quot;, num);        &#125;               static void Main(string[] args)        &#123;            // 使用匿名方法创建委托实例            NumberChanger nc = delegate (int x)            &#123;                Console.WriteLine(&quot;Anonymous Method: &#123;0&#125;&quot;, x);            &#125;;            // 使用匿名方法调用委托            nc(10);            // 使用命名方法实例化委托            nc = new NumberChanger(AddNum);            // 使用命名方法调用委托            nc(5);            // 使用另一个命名方法实例化委托            nc = new NumberChanger(MultNum);            // 使用命名方法调用委托            nc(2);            Console.ReadKey();        &#125;    &#125;&#125;</code></pre></div><p>当上面的代码被编译和执行时，它会产生下列结果：</p><p>Anonymous Method: 10<br>Named Method: 15<br>Named Method: 30</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#网络聊天室</title>
    <link href="/2018/02/24/C-%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <url>/2018/02/24/C-%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>使用VS控制台应用，开发C#网络通信代码。模拟聊天室。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h4 id="首先创建一个ServerController的解决方案，使用一下脚本：服务器端脚本，ServerTest"><a href="#首先创建一个ServerController的解决方案，使用一下脚本：服务器端脚本，ServerTest" class="headerlink" title="首先创建一个ServerController的解决方案，使用一下脚本：服务器端脚本，ServerTest"></a>首先创建一个ServerController的解决方案，使用一下脚本：服务器端脚本，ServerTest</h4><div class="code-wrapper"><pre><code class="hljs c#">using System;using System.Collections.Generic;using System.Net;using System.Net.Sockets;using System.Text;using System.Threading;namespace ServerControler&#123;    public class ServerTest    &#123;        List&lt;Socket&gt; clientList;//客户端集合        Socket socket;        string ip = &quot;127.0.0.1&quot;;        int port = 12345;        /// &lt;summary&gt;        /// 构造函数        /// &lt;/summary&gt;        public ServerTest()        &#123;            socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);            clientList = new List&lt;Socket&gt;();//在构造函数中初始化客户端的集合        &#125;        public void StartServer()        &#123;            IPEndPoint endPoint = new IPEndPoint(IPAddress.Parse(ip), port);//把IP和端口组合成IPEndPoint的结构            socket.Bind(endPoint);//绑定IP和端口            socket.Listen(10);//设置监听            Thread therd = new Thread(Accept);//开启新线程            therd.IsBackground = true;            therd.Start();            Console.WriteLine(&quot;服务器启动成功&quot;);        &#125;        /// &lt;summary&gt;        /// 接收客户端的方法，会挂起当前线程        /// &lt;/summary&gt;        void Accept()        &#123;            Socket client = socket.Accept();//设置连接            IPEndPoint point = client.RemoteEndPoint as IPEndPoint;            Console.WriteLine(point.Address + &quot;[&quot; + point.Port + &quot;]连接成功&quot;);            clientList.Add(client);//连接进来一个客户端就添加到集合里,然后在下面遍历哪个客户端发的消息，再把消息分别发到其他客户端            //会挂起当前线程，所以新开一个线程            Thread thread = new Thread(Receive);            thread.IsBackground = true;            thread.Start(client);            Accept();//尾递归        &#125;        /// &lt;summary&gt;        /// 服务器接收客户端的消息        /// &lt;/summary&gt;        /// &lt;param name=&quot;obj&quot;&gt;线程的参数类型只能是Object类型&lt;/param&gt;        void Receive(object obj)//线程的参数类型只能是Object类型        &#123;            Socket client = obj as Socket;//把Object强制转换成Socket            IPEndPoint point = client.RemoteEndPoint as IPEndPoint;            try            &#123;                byte[] msg = new byte[1024];                int msgLenth = client.Receive(msg);                string clientMsg = point.Address + &quot;[&quot; + point.Port + &quot;] 说: &quot; + Encoding.UTF8.GetString(msg, 0, msgLenth);//获得哪个客户端发过来的消息，进行输出                Console.WriteLine(clientMsg);                GuangBo(client, clientMsg);//调用广播这个方法，分发给其他客户端，有人说话了                //client.Send(Encoding.UTF8.GetBytes(Encoding.UTF8.GetString(msg, 0, msgLenth)+&quot; (这是服务器返回的消息)&quot;));//服务器往客户端发送消息                Receive(client);//尾递归进行等待下一个消息            &#125;            catch            &#123;                Console.WriteLine(point.Address + &quot;[&quot; + point.Port + &quot;] : &quot; + &quot;断开连接&quot;);                clientList.Remove(client);//如果某个客户端退出链接，就从集合里移除            &#125;        &#125;        /// &lt;summary&gt;        /// 遍历哪个客户端发的消息，然后把消息向其他客户端广播出去，形成聊天室        /// &lt;/summary&gt;        /// &lt;param name=&quot;client&quot;&gt;发消息进来的客户端&lt;/param&gt;        /// &lt;param name=&quot;msg&quot;&gt;某个客户端发过来的消息&lt;/param&gt;        private void GuangBo(Socket clientOther, string msg)        &#123;            foreach (var client in clientList)            &#123;                if (client == clientOther)                &#123;                    //消息是由这个客户端发过来的，不需要有任何响应                &#125;                else                &#123;                    client.Send(Encoding.UTF8.GetBytes(msg));//执行Send方法，把消息分发给其他客户端                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h4 id="服务器端主函数脚本，Program"><a href="#服务器端主函数脚本，Program" class="headerlink" title="服务器端主函数脚本，Program"></a>服务器端主函数脚本，Program</h4><div class="code-wrapper"><pre><code class="hljs c#">using System;namespace ServerControler&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            ServerTest server = new ServerTest();            server.StartServer();//执行StartServer方法，开启服务器            Console.ReadKey();        &#125;    &#125;&#125;</code></pre></div><h4 id="再创建一个ClientController的解决方案，使用一下脚本："><a href="#再创建一个ClientController的解决方案，使用一下脚本：" class="headerlink" title="再创建一个ClientController的解决方案，使用一下脚本："></a>再创建一个ClientController的解决方案，使用一下脚本：</h4><p>客户端脚本，Client</p><div class="code-wrapper"><pre><code class="hljs c#">using System;using System.Collections.Generic;usingSystem.Net.Sockets;using System.Text;using System.Threading;namespace ClientController&#123;    public class Client    &#123;        private Socket ClientSocket;        public Client()        &#123;            ClientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);        &#125;        public void Connect(string ip, int port)        &#123;            ClientSocket.Connect(ip, port);            Console.WriteLine(&quot;连接上服务器&quot;);            Thread thread = new Thread(Receive);            thread.IsBackground = true;            thread.Start();        &#125;        void Receive()        &#123;            while (true)            &#123;                try                &#123;                    byte[] msg = new byte[1024];                    int msgLenth = ClientSocket.Receive(msg);//ClientSocket.Receive接收消息，返回接受到得长度                    Console.WriteLine(Encoding.UTF8.GetString(msg, 0, msgLenth));                &#125;                catch                &#123;                    Console.WriteLine(&quot;服务器拒绝连接，请重新尝试&quot;);                    break;                &#125;            &#125;        &#125;        public void Send()        &#123;            Thread thread = new Thread(ReadAndSend);            //thread.IsBackground = true;//此处教程视频里注掉了，说是因为在主函数里写了Console.ReadKey()，主线程会把这个线程给关掉，注掉之后就不会影响这个线程,个人测试下来，不发布还是没问题的，但是发布这个程序之后，会发送不了消息，直接退出，所以还是注掉            thread.Start();//开启线程        &#125;        void ReadAndSend()        &#123;            Console.WriteLine(&quot;请输入要发送的内容，不输入直接按下Enter则退出&quot;);            string msg = Console.ReadLine();//获取输入的内容            while (msg != &quot;&quot;)            &#123;                ClientSocket.Send(Encoding.UTF8.GetBytes(msg));//向服务器发送消息                msg = Console.ReadLine();            &#125;        &#125;    &#125;&#125;</code></pre></div><p>客户端端主函数脚本，Program</p><div class="code-wrapper"><pre><code class="hljs c#">using System;namespace ClientController&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Client client = new Client();            client.Connect(&quot;127.0.0.1&quot;, 12345);            client.Send();//执行Send方法，启动线程发送消息            Console.ReadKey();        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#结构体和类的区别</title>
    <link href="/2017/11/08/C-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2017/11/08/C-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="笔记1"><a href="#笔记1" class="headerlink" title="笔记1"></a>笔记1</h3><p>1，结构是实值类型（Value Types），而类则是引用类型（Reference Types）。</p><p>2，结构使用栈存储（Stack Allocation），而类使用堆存储（Heap Allocation）。</p><p>3，所有结构成员默认都是Public，而类的变量和常量数则默认位Private，不过其他类成员默认都是Public。</p><p>4，结构成员不能被声明位Protected，而类成员可以。</p><p>5，结构变量声明不能指定初始值、使用New关键字货对数组进行初始化，但是类变量声明可以。</p><p>6，结构不能声明默认的构造函数，也就是不拥有参数的非共享构造函数，但是类则无此限制。</p><p>7，二者都可以拥有共享构造函数，结构的共享构造函数不能带有参数，但是类的共享构造函数则可以带或者不带参数。</p><p>8，结构不允许声明析构函数（Destructor），类则无此限制。</p><p>9，结构的实例（Instance）声明，不允许对包含的变量进行初始化设定，类则可以在声明类的实例时，同时进行变量初始化。</p><p>10，结构是隐式继承自ValueType类，而且不能继承任何其他类型，类则可以继续自ValueType以外的任何类。</p><p>11，结构是无法被继承的，类则可以。</p><p>12，结构永远不会终止，因此CLR不会在任何结构上调用Finalize方法。类则是由内存回收进程加以终止，当内存回收进程检测到没有任何作用的类时，它就会调用类的Finalize方法。</p><p>13，结构不需要构造函数，类则需要构造函数。</p><p>14，结构只能在一种情况下使用非共享构造函数，那就是非共享构造函数会接受参数。但是类则无此限制，它可以使用带参数或不带参数的非共享构造函数。</p><p>14，每一个结构都具有无参数的隐含公共构造函数，此构造函数会将结构的所有成员初始化为其默认值。不需要重新定义这个行为。</p><p>在“实例和变量”层面上，由于结构是数值类型的，因此每一个结构变量会永远的绑定到结构实例上。然而类是引用类型的，而且对象变量可引用不同的类实例，在此方面的区别，会对使用将结构和类造成如下的影响：</p><p>15，结构变量会隐式的使用结构的无参数构造函数来初始化成员，这就意味语句 Struct S = new Struct（）。</p><p>16，当您将一个结构变量赋值给另一个，或者将结构实例传递到程序变量时，所有变量成员的值会复制到新的结构中。当您将一个对象变量赋值给另一个，或者将对象变量传递给程序时，则只是复制指针。</p><p>17，您可以将Null值赋值给结构变量，但是该实例会一直与该变量保持关联。虽然变量成员会因此赋值而重新初始化，但是您还是可以调用变量的方法并访问其数据成员。相反的，如果您将对象变量设定为Null，您就会中断它与任何类型实例的关联，而且除非您再将另一个实例赋值给它，否则无法通过变量访问任何成员。</p><p>18，您可以在不同时间将不同的类的实例赋值给同一个对象变量，而且在同一时间可有好几个对象变量引用相同的类实例，如果您对类成员值做了改变，则其他指向相同实例的对象变量也会发生改变。然而，结构成员则会封装在他们自己的实例中，变更结构成员值并不会对其他任何结构变量的成员造成影响，甚至也不会影响相同结构声明的其他实例。</p><p>19，两个结构必须以成员对成员的比较方式来执行相等比较。两个对象变量可以使用Equals方法来加以比较。Equals会判断两个变量是否指向相同的实例。</p><h3 id="笔记2"><a href="#笔记2" class="headerlink" title="笔记2"></a>笔记2</h3><p>1，结构体是一种值类型，而类是引用类型。值类型用于存储数据的值，引用类型用于存储对实际数据的引用。那么结构体就是当成值来使用的，类则通过引用来对实际数据操作。<br>2，结构体的定义是：有些数据既是相互关联的，又共同描述一个完整事物，如：一个学生的整体信息，学号、姓名、性别等。而类则使用在需要比较有层次的数据上面。<br>3，类是反映现实事物的一种抽象，而结构体的作用只是一种包含了具体不同类别数据的一种包装，结构体不具备类的继承多态特性<br>4，构造函数是为了初始化类的字段而存在的，而结构体并不需要初始化就能使用，因此，结构体中并不存在默认的构造函数。</p><p>结构：</p><div class="code-wrapper"><pre><code class="hljs csharp">没有默认的构造函数，但是可以添加构造函数没有析构函数没有 <span class="hljs-keyword">abstract</span> 和 <span class="hljs-keyword">sealed</span>(因为不能继承)不能有<span class="hljs-keyword">protected</span> 修饰符可以不使用<span class="hljs-keyword">new</span> 初始化在结构中初始化实例字段是错误的</code></pre></div><p>类： </p><div class="code-wrapper"><pre><code class="hljs csharp">有默认的构造函数有析构函数可以使用 <span class="hljs-keyword">abstract</span> 和 <span class="hljs-keyword">sealed</span> 有<span class="hljs-keyword">protected</span> 修饰符必须使用<span class="hljs-keyword">new</span> 初始化</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity技能冷却功能</title>
    <link href="/2017/11/05/Unity%E6%8A%80%E8%83%BD%E5%86%B7%E5%8D%B4%E5%8A%9F%E8%83%BD/"/>
    <url>/2017/11/05/Unity%E6%8A%80%E8%83%BD%E5%86%B7%E5%8D%B4%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><div class="code-wrapper"><pre><code class="hljs c#">// 技能的图标  public Image icon;  //通过Text显示时间  public Text txt;  float aTxt;  bool Dtime = false;  // 技能的冷却时间  public float coolDown;  // 技能名称，用于区分使用了哪个技能的  //public string skillName;  // 保存当前技能的冷却时间  private float currentCoolDown;  // 技能的按钮  private Button skillButton;   void Start()  &#123;      // 获得技能按钮，然后绑定点击事件      this.skillButton = this.GetComponent&lt;Button&gt;();      skillButton.onClick.AddListener(UseSkill);      // 一开始冷却时满的，可以立即使用技能      // 如果不想让玩家一开始能立即使用技能，这里设置成别的小于技能冷却的值      currentCoolDown = coolDown;  &#125;  void Update()  &#123;      if (currentCoolDown &lt; coolDown )      &#123;          //更新冷却         currentCoolDown += Time.deltaTime;                  //显示冷却过程          this.icon.fillAmount = currentCoolDown / coolDown;                  Dtime = true;      &#125;      if (Dtime )      &#123;          //显示技能时间          aTxt -= Time.deltaTime;          txt.text = Math.Round(aTxt , 2).ToString();//float型保留最后两位数字          if (aTxt &lt;= 0)          &#123;              txt.text = &quot;&quot;;              Dtime = false;          &#125;      &#125;  &#125;  public void UseSkill()  &#123;      if (currentCoolDown &gt;= coolDown)      &#123;                   // 重置冷却时间          currentCoolDown = 0;      &#125;      aTxt = coolDown;  &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity屏幕滑杆</title>
    <link href="/2017/10/30/Unity%E5%B1%8F%E5%B9%95%E6%BB%91%E6%9D%86/"/>
    <url>/2017/10/30/Unity%E5%B1%8F%E5%B9%95%E6%BB%91%E6%9D%86/</url>
    
    <content type="html"><![CDATA[<h3 id="滑杆代码"><a href="#滑杆代码" class="headerlink" title="滑杆代码"></a>滑杆代码</h3><div class="code-wrapper"><pre><code class="hljs c#">using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using UnityEngine.EventSystems;public class TuoUI : MonoBehaviour,IDragHandler,IEndDragHandler&#123;              public Vector3 dir;       Vector3 yuandian;       RectTransform recttras;       RectTransform rects;       public float a;       public float b;       public  Animator ani;       // Use this for initialization       void Start ()       &#123;              recttras = transform as RectTransform;              yuandian = transform.position;              rects=transform.parent as RectTransform;       &#125;              // Update is called once per frame       public Vector3 worldpos;       public void OnDrag (PointerEventData eventData)       &#123;              ani.SetFloat (&quot;runs&quot;, 1);              RectTransformUtility.ScreenPointToWorldPointInRectangle (recttras, Input.mousePosition, eventData.pressEventCamera, out worldpos);              transform.position = worldpos;              dir = transform.localPosition-Vector3.zero;              if(Vector2.Distance(Input.mousePosition,yuandian)&gt;rects.rect.width/2)              &#123;                     transform.localPosition = Vector3.zero + dir.normalized * rects.rect.width / 2;              &#125;                            &#125;       public void OnEndDrag (PointerEventData eventData)       &#123;              transform.localPosition = Vector3.zero;               dir = transform.localPosition-Vector3.zero;              ani.SetFloat (&quot;runs&quot;, 0);       &#125;       void Update ()       &#123;              a = dir.x / rects.rect.width / 2;              b = dir.z / rects.rect.height / 2;                     &#125;</code></pre></div><h3 id="角色脚本："><a href="#角色脚本：" class="headerlink" title="角色脚本："></a>角色脚本：</h3><div class="code-wrapper"><pre><code class="hljs c#">public class NinjaMove : MonoBehaviour &#123;    float h;    float v;    public float movespeed;    //public float rotspeed;       public TuoUI yaogan;       Vector3 a;       void Start ()    &#123;    &#125;              void Update ()    &#123;              a = new  Vector3 (yaogan.dir.normalized.x, 0, yaogan.dir.normalized.y);              if(a.x != 0 || a.z != 0)              &#123;                     transform.rotation = Quaternion.LookRotation (a);                     transform.Translate(Vector3.forward* movespeed * Time.deltaTime);              &#125;       &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity中抛物线实现精准打击</title>
    <link href="/2017/10/30/unity%E6%8A%9B%E7%89%A9%E7%BA%BF/"/>
    <url>/2017/10/30/unity%E6%8A%9B%E7%89%A9%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h4 id="unity中抛物线实现精准打击"><a href="#unity中抛物线实现精准打击" class="headerlink" title="unity中抛物线实现精准打击"></a>unity中抛物线实现精准打击</h4><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Collections;<span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> BulletControl : MonoBehaviour &#123;    <span class="hljs-built_in">public</span> <span class="hljs-keyword">Transform</span> _Target;       <span class="hljs-built_in">public</span> <span class="hljs-type">float</span> _VerticalSpeed;    const <span class="hljs-type">float</span> _Grivaty = <span class="hljs-number">-9.81</span>f;    <span class="hljs-type">float</span> _HorizontalSpeed;       <span class="hljs-type">float</span> _TimeCount;    Vector3 _HorizontalDir;       <span class="hljs-type">void</span> <span class="hljs-keyword">Start</span> () &#123;        <span class="hljs-type">float</span> t1 = -_VerticalSpeed / _Grivaty;        //<span class="hljs-type">float</span> s1 = -_Grivaty * t1 * t1 / <span class="hljs-number">2</span>;        <span class="hljs-type">float</span> s1 = _VerticalSpeed * _VerticalSpeed / (<span class="hljs-number">2</span> * -_Grivaty);        <span class="hljs-type">float</span> top = <span class="hljs-keyword">transform</span>.position.y + s1;        <span class="hljs-type">float</span> s2 = top - _Target.position.y;        _HorizontalDir = _Target.position - <span class="hljs-keyword">transform</span>.position;        _HorizontalDir.y = <span class="hljs-number">0</span>;        <span class="hljs-type">float</span> sh = Vector3.Magnitude(_HorizontalDir);        <span class="hljs-type">float</span> t2 = Mathf.Sqrt(<span class="hljs-number">2</span> * s2 / -_Grivaty);        _HorizontalSpeed = sh / (t1 + t2);       &#125;              <span class="hljs-type">void</span> <span class="hljs-keyword">Update</span> () &#123;        _TimeCount += <span class="hljs-type">Time</span>.deltaTime;        <span class="hljs-keyword">transform</span>.Translate(_HorizontalDir.normalized * _HorizontalSpeed * <span class="hljs-type">Time</span>.deltaTime);        <span class="hljs-keyword">transform</span>.Translate(Vector3.up * (_VerticalSpeed + _Grivaty * _TimeCount) * <span class="hljs-type">Time</span>.deltaTime);        <span class="hljs-keyword">Debug</span>.DrawLine(<span class="hljs-keyword">transform</span>.position, <span class="hljs-keyword">transform</span>.position+Vector3.up, Color.red, <span class="hljs-number">1000</span>);       &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity面试题整理</title>
    <link href="/2017/10/28/Unity%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2017/10/28/Unity%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>一：什么是协同程序？</p><p>在主线程运行的同时开启另一段逻辑处理，来协助当前程序的执行，协程很像多线程，但是不是多线程，Unity的协程实在每帧结束之后去检测yield的条件是否满足。</p><p>二：Unity3d中的碰撞器和触发器的区别？</p><p>碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性。当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。如果既要检测到物体的接触又不想让碰撞检测影响物体移动或要检测一个物件是否经过空间中的某个区域这时就可以用到触发器</p><p>三：物体发生碰撞的必要条件？</p><p>两个物体都必须带有碰撞器（Collider），其中一个物体还必须带有Rigidbody刚体，而且必须是运动的物体带有Rigidbody脚本才能检测到碰撞。</p><p>四：请简述ArrayList和List的主要区别？</p><p>ArrayList存在不安全类型（ArrayList会把所有插入其中的数据都当做Object来处理），装箱拆箱的操作（费时），List是泛型类，功能跟ArrayList相似，但不存在ArrayList所说的问题。</p><p>五：如何安全的在不同工程间安全地迁移asset数据？三种方法</p><p>1.将Assets目录和Library目录一起迁移</p><p>2.导出包，export Package</p><p>3.用unity自带的assets Server功能</p><p>六：OnEnable、Awake、Start运行时的发生顺序？哪些可能在同一个对象周期中反复的发生</p><p>Awake –&gt;OnEnable-&gt;Start，OnEnable在同一周期中可以反复地发生。</p><p>七：MeshRender中material和sharedmaterial的区别？</p><p>修改sharedMaterial将改变所有物体使用这个材质的外观，并且也改变储存在工程里的材质设置。不推荐修改由sharedMaterial返回的材质。如果你想修改渲染器的材质，使用material替代。</p><p>八：Unity提供了几种光源，分别是什么</p><p>四种。</p><p>平行光：Directional Light</p><p>点光源：Point Light</p><p>聚光灯：Spot Light</p><p>区域光源：Area Light</p><p>九：简述一下对象池，你觉得在FPS里哪些东西适合使用对象池</p><p>对象池就存放需要被反复调用资源的一个空间，当一个对象回大量生成的时候如果每次都销毁创建会很费时间，通过对象池把暂时不用的对象放到一个池中（也就是一个集合），当下次要重新生成这个对象的时候先去池中查找一下是否有可用的对象，如果有的话就直接拿出来使用，不需要再创建，如果池中没有可用的对象，才需要重新创建，利用空间换时间来达到游戏的高速运行效果，在FPS游戏中要常被大量复制的对象包括子弹，敌人，粒子等</p><p>十：CharacterController和Rigidbody的区别</p><p>Rigidbody具有完全真实物理的特性，Unity中物理系统最基本的一个组件，包含了常用的物理特性，而CharacterController可以说是受限的的Rigidbody，具有一定的物理效果但不是完全真实的，是Unity为了使开发者能方便的开发第一人称视角的游戏而封装的一个组件</p><p>十一：简述prefab的用处</p><p>在游戏运行时实例化，prefab相当于一个模板，对你已经有的素材、脚本、参数做一个默认的配置，以便于以后的修改，同时prefab打包的内容简化了导出的操作，便于团队的交流。</p><p>十二：请简述sealed关键字用在类声明时与函数声明时的作用</p><p>sealed修饰的类为密封类，类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。</p><p>十三：请简述private，public，protected，internal的区别</p><p>public：对任何类和成员都公开，无限制访问</p><p>private：仅对该类公开</p><p>protected：对该类和其派生类公开</p><p>internal：只能在包含该类的程序集中访问该类</p><p>十四：使用Unity3d实现2d游戏，有几种方式？</p><p>使用本身的GUI，在Unity4.6以后出现的UGUI<br>2.把摄像机的Projection(投影)值调为Orthographic(正交投影)，不考虑z轴；</p><p>3.使用2d插件，如：2DToolKit，和NGUI</p><p>十五：在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数</p><p>三个阶段，1.OnCollisionEnter 2.OnCollisionStay 3.OnCollisionExit</p><p>十六：Unity3d的物理引擎中，有几种施加力的方式，分别描述出来</p><p>rigidbody.AddForce/AddForceAtPosition，都在rigidbody系列函数中。大家可以自己去查看一下rigidbody的API</p><p>十七：什么叫做链条关节？</p><p>Hinge Joint，可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在一个固定距离内部相互移动而不产生作用力，但是达到固定距离后就会产生拉力。</p><p>十八：物体自身旋转使用的函数？</p><p>Transform.Rotate()</p><p>十九：Unity3d提供了一个用于保存和读取数据的类(PlayerPrefs)，请列出保存和读取整形数据的函数</p><p>PlayerPrefs.SetInt() PlayerPrefs.GetInt()</p><p>二十：Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，请列出系统自带的几个重要的方法。</p><p>Awake——&gt;OnEnable–&gt;Start——&gt;Update——&gt;FixedUpdate——&gt;LateUpdate——&gt;OnGUI——&gt;OnDisable——&gt;OnDestroy</p><p>二十一：物理更新一般放在哪个系统函数里？</p><p>FixedUpdate，固定时间间隔执行 可以在edit-&gt;project setting-&gt;time设置 update 是在渲染帧执行，和Update不同的是FixedUpdate是渲染帧执行，如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降。FixedUpdate比较适用于物理引擎的计算，因为是跟每帧渲染有关。Update就比较适合做控制。</p><p>二十二：在场景中放置多个Camera并同时处于活动状态会发生什么？</p><p>游戏界面可以看到很多摄像机的混合。</p><p>二十三：如何销毁一个UnityEngine.Object及其子类？</p><p>使用Destroy()方法;</p><p>二十四：请描述为什么Unity3d中会发生在组件上出现数据丢失的情况</p><p>一般是组件上绑定的物体对象被删除了</p><p>二十五：LOD是什么，优缺点是什么？</p><p>LOD(Level of detail)多层次细节，是最常用的游戏优化技术。它按照模型的位置和重要程度决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。缺点是增加了内存。</p><p>二十六：MipMap是什么，作用？</p><p>MipMapping：在三维计算机图形的贴图渲染中有常用的技术，为加快渲染进度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为MipMap。</p><p>二十七：请描述Interface与抽象类之间的不同</p><p>抽象类表示该类中可能已经有一些方法的具体定义，但接口就是公公只能定义各个方法的界面 ，不能具体的实现代码在成员方法中。类是子类用来继承的，当父类已经有实际功能的方法时该方法在子类中可以不必实现，直接引用父类的方法，子类也可以重写该父类的方法。实现接口的时候必须要实现接口中所有的方法，不能遗漏任何一个。</p><p>二十八：.Net与Mono的关系？</p><p>mono是.net的一个开源跨平台工具，就类似java虚拟机，java本身不是跨平台语言，但运行在虚拟机上就能够实现了跨平台。.net只能在windows下运行，mono可以实现跨平台跑，可以运行于linux，Unix，Mac OS等。</p><p>二十九：简述Unity3D支持的作为脚本的语言的名称</p><p>Unity的脚本语言基于Mono的.Net平台上运行，可以使用.NET库，这也为XML、数据库、正则表达式等问题提供了很好的解决方案。Unity里的脚本都会经过编译，他们的运行速度也很快。这三种语言实际上的功能和运行速度是一样的，区别主要体现在语言特性上。JavaScript、 C#、Boo</p><p>三十：U3D中用于记录节点空间几何信息的组件名称，及其父类名称</p><p>Transform 父类是 Component</p><p>三十一：向量的点乘、叉乘以及归一化的意义？</p><p>1.点乘描述了两个向量的相似程度，结果越大两向量越相似，还可表示投影</p><p>2.叉乘得到的向量垂直于原来的两个向量</p><p>3.标准化向量：用在只关系方向，不关心大小的时候</p><p>三十二：为何大家都在移动设备上寻求U3D原生GUI的替代方案</p><p>不美观，OnGUI很耗费时间，效率不高，使用不方便</p><p>三十三：请简述如何在不同分辨率下保持UI的一致性</p><p>NGUI很好的解决了这一点，屏幕分辨率的自适应性，原理就是计算出屏幕的宽高比跟原来的预设的屏幕分辨率求出一个对比值，然后修改摄像机的size。UGUI通过锚点和中心点和分辨率也解决这个问题</p><p>三十四：什么是LightMap？</p><p>LightMap:就是指在三维软件里实现打好光，然后渲染把场景各表面的光照输出到贴图上，最后又通过引擎贴到场景上，这样就使物体有了光照的感觉。</p><p>三十五：Unity和cocos2d的区别</p><p>Unity3D支持C#、javascript等，cocos2d-x 支持c++、Html5、Lua等。</p><p>cocos2d 开源 并且免费</p><p>Unity3D支持iOS、Android、Flash、Windows、Mac、Wii等平台的游戏开发，cocos2d-x支持iOS、Android、WP等。</p><p>三十六：C#和C++的区别？</p><p>简单的说：C# 与C++ 比较的话，最重要的特性就是C# 是一种完全面向对象的语言，而C++ 不是，另外C# 是基于IL 中间语言和.NET Framework CLR 的，在可移植性，可维护性和强壮性都比C++ 有很大的改进。C# 的设计目标是用来开发快速稳定可扩展的应用程序，当然也可以通过Interop 和Pinvoke 完成一些底层操作。更详细的区别大家可以参考这里</p><p>三十七：结构体和类有何区别？</p><p>结构体是一种值类型，而类是引用类型。（值类型、引用类型是根据数据存储的角度来分的）就是值类型用于存储数据的值，引用类型用于存储对实际数据的引用。那么结构体就是当成值来使用的，类则通过引用来对实际数据操作</p><p>三十八：ref参数和out参数是什么？有什么区别？</p><p>ref和out参数的效果一样，都是通过关键字找到定义在主函数里面的变量的内存地址，并通过方法体内的语法改变它的大小。不同点就是输出参数必须对参数进行初始化。ref必须初始化，out 参数必须在函数里赋值。ref参数是引用，out参数为输出参数。</p><p>三十九：C#的委托是什么？有何用处？</p><p>委托类似于一种安全的指针引用，在使用它时是当做类来看待而不是一个方法，相当于对一组方法的列表的引用。用处：使用委托使程序员可以将方法引用封装在委托对象内。然后可以将该委托对象传递给可调用所引用方法的代码，而不必在编译时知道将调用哪个方法。与C或C++中的函数指针不同，委托是面向对象，而且是类型安全的。</p><p>四十：C#中的排序方式有哪些？</p><p>选择排序，冒泡排序，快速排序，插入排序，希尔排序，归并排序</p><p>四十一：射线检测碰撞物的原理是？</p><p>射线是3D世界中一个点向一个方向发射的一条无终点的线，在发射轨迹中与其他物体发生碰撞时，它将停止发射 。</p><p>四十二：Unity中，照相机的Clipping Planes的作用是什么？调整Near、Fare两个值时，应该注意什么？</p><p>剪裁平面 。从相机到开始渲染和停止渲染之间的距离。</p><p>四十三：如何让已经存在的GameObject在LoadLevel后不被卸载掉？</p><p>void Awake() { DontDestroyOnLoad(transform.gameObject); }<br>四十四：请简述GC（垃圾回收）产生的原因，并描述如何避免？</p><p>GC回收堆上的内存</p><p>避免：1.减少new产生对象的次数</p><p>2.使用公用的对象（静态成员）</p><p>3.将String换为StringBuilder</p><p>四十五：反射的实现原理？</p><p>审查元数据并收集关于它的类型信息的能力。实现原理：在运行时根据程序集及其中的类型得到元数据。下面是实现步骤：</p><p>导入using System.Reflection;</p><p>Assembly.Load(“程序集”)加载程序集,返回类型是一个Assembly</p><p>得到程序集中所有类的名称</p><p>foreach (Type type in assembly.GetTypes()) { string t = type.Name; }<br>4. Type type = assembly.GetType(“程序集.类名”);获取当前类的类型</p><p>Activator.CreateInstance(type); 创建此类型实例</p><p>MethodInfo mInfo = type.GetMethod(“方法名”);获取当前方法</p><p>m.Info.Invoke(null,方法参数);</p><p>四十六：简述四元数的作用，四元数对欧拉角的优点？</p><p>四元数用于表示旋转</p><p>相对欧拉角的优点：</p><p>1.能进行增量旋转</p><p>2.避免万向锁</p><p>3.给定方位的表达方式有两种，互为负（欧拉角有无数种表达方式）</p><p>四十七：移动相机动作在哪个函数里，为什么在这个函数里？</p><p>LateUpdate，是在所有的update结束后才调用，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是所有的update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。</p><p>四十八：GPU的工作原理</p><p>简而言之，GPU的图形（处理）流水线完成如下的工作：（并不一定是按照如下顺序） 顶点处理：这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建立起3D图形的骨架。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Vertex Shader（定点着色器）完成。 光栅化计算：显示器实际显示的图像是由像素组成的，我们需要将上面生成的图形上的点和线通过一定的算法转换到相应的像素点。把一个矢量图形转换为一系列像素点的过程就称为光栅化。例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。 纹理帖图：顶点单元生成的多边形只构成了3D物体的轮廓，而纹理映射（texture mapping）工作完成对多变形表面的帖图，通俗的说，就是将多边形的表面贴上相应的图片，从而生成“真实”的图形。TMU（Texture mapping unit）即是用来完成此项工作。 像素处理：这阶段（在对每个像素进行光栅化处理期间）GPU完成对像素的计算和处理，从而确定每个像素的最终属性。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Pixel Shader（像素着色器）完成。 最终输出：由ROP（光栅化引擎）最终完成像素的输出，1帧渲染完毕后，被送到显存帧缓冲区。</p><p>总结：GPU的工作通俗的来说就是完成3D图形的生成，将图形映射到相应的像素点上，对每个像素进行计算确定最终颜色并完成输出。</p><p>四十九：什么是渲染管道？</p><p>是指在显示器上为了显示出图像而经过的一系列必要操作。 渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。主要步骤有：</p><p>本地坐标-&gt;视图坐标-&gt;背面裁剪-&gt;光照-&gt;裁剪-&gt;投影-&gt;视图变换-&gt;光栅化</p><p>五十：如何优化内存？</p><p>有很多种方式，例如</p><p>1.压缩自带类库；</p><p>2.将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉；</p><p>3.释放AssetBundle占用的资源；</p><p>4.降低模型的片面数，降低模型的骨骼数量，降低贴图的大小；</p><p>5.使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)。</p><p>6.代码中少产生临时变量</p><p>五十一：动态加载资源的方式？他们之间的区别</p><p>1.Resources.Load();</p><p>2.AssetBundle</p><p>区别参考</p><p>五十二：请描述游戏动画有哪几种，以及其原理？</p><p>主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。</p><p>关节动画：把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活，Quake2中使用这种动画；</p><p>骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，有关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观；</p><p>单一网格模型动画由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。</p><p>五十三：alpha blend工作原理</p><p>Alpha Blend 实现透明效果，不过只能针对某块区域进行alpha操作，透明度可设。</p><p>五十四：写出光照计算中的diffuse的计算公式</p><p>diffuse = Kd x colorLight x max(N*L,0)；Kd 漫反射系数、colorLight 光的颜色、N 单位法线向量、L 由点指向光源的单位向量、其中N与L点乘，如果结果小于等于0，则漫反射为0。</p><p>五十五：两种阴影判断的方法、工作原理。</p><p>本影和半影：参考本影和半影</p><p>本影：景物表面上那些没有被光源直接照射的区域（全黑的轮廓分明的区域）。</p><p>半影：景物表面上那些被某些特定光源直接照射但并非被所有特定光源直接照射的区域（半明半暗区域）</p><p>工作原理：从光源处向物体的所有可见面投射光线，将这些面投影到场景中得到投影面，再将这些投影面与场景中的其他平面求交得出阴影多边形，保存这些阴影多边形信息，然后再按视点位置对场景进行相应处理得到所要求的视图（利用空间换时间，每次只需依据视点位置进行一次阴影计算即可，省去了一次消隐过程）</p><p>五十六：Vertex Shader是什么，怎么计算？</p><p>顶点着色器是一段执行在GPU上的程序，用来取代fixed pipeline中的transformation和lighting，Vertex Shader主要操作顶点。</p><p>Vertex Shader对输入顶点完成了从local space到homogeneous space（齐次空间）的变换过程，homogeneous space即projection space的下一个space。在这其间共有world transformation, view transformation和projection transformation及lighting几个过程。</p><p>五十七：下列代码在运行中会产生几个临时对象？</p><p>string a = new string(“abc”); a = (a.ToUpper() + “123”).Substring(0, 2);<br>在C#中第一行是会报错的（Java中倒是可行）。</p><p>应该这样初始化：</p><p>string b = new string(new char[]{‘a’,’b’,’c’});<br>答案为：5个临时对象</p><p>五十八：下列代码在运行中会发生什么问题？如何避免？</p><p>List ls = new List(new int[] { 1, 2, 3, 4, 5 }); foreach (int item in ls) { Console.WriteLine(item * item); ls.Remove(item); }<br>产生运行时错误，在 ls.Remove(item)这行，因为foreach是只读的。不能一边遍历一边修改。</p><p>五十九：Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？</p><p>仅能从主线程中访问Unity3D的组件，对象和Unity3D系统调用</p><p>支持：如果同时你要处理很多事情或者与Unity的对象互动小可以用thread,否则使用coroutine。</p><p>注意：C#中有lock这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象</p><p>六十：Unity3D的协程和C#线程之间的区别是什么？</p><p>多线程程序同时运行多个线程 ，而在任一指定时刻只有一个协程在运行，并且这个正在运行的协同程序只在必要时才被挂起。除主线程之外的线程无法访问Unity3D的对象、组件、方法。</p><p>Unity3d没有多线程的概念，不过unity也给我们提供了StartCoroutine（协同程序）和LoadLevelAsync（异步加载关卡）后台加载场景的方法。 StartCoroutine为什么叫协同程序呢，所谓协同，就是当你在StartCoroutine的函数体里处理一段代码时，利用yield语句等待执行结果，这期间不影响主程序的继续执行，可以协同工作。</p><p>六十一：矩阵相乘的意义及注意点</p><p>用于表示线性变换：旋转、缩放、投影、平移、仿射</p><p>注意矩阵的蠕变：误差的积累</p><p>六十二：为什么dynamic font在unicode环境下优于static font</p><p>Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。</p><p>使用动态字体时，Unity将不会预先生成一个与所有字体的字符纹理。当需要支持亚洲语言或者较大的字体的时候，若使用正常纹理，则字体的纹理将非常大。</p><p>六十三：当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？</p><p>穿透（碰撞检测失败）</p><p>六十四：请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？</p><p>当物体是否可见切换之时。可以用于只需要在物体可见时才进行的计算。</p><p>六十五：什么叫动态合批？跟静态合批有什么区别？</p><p>如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的，并不需要你进行额外的操作。</p><p>区别：动态批处理一切都是自动的，不需要做任何操作，而且物体是可以移动的，但是限制很多。静态批处理：自由度很高，限制很少，缺点可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了。</p><p>参考</p><p>六十六：简述StringBuilder和String的区别？</p><p>String是字符串常量。</p><p>StringBuffer是字符串变量 ，线程安全。</p><p>StringBuilder是字符串变量，线程不安全。</p><p>String类型是个不可变的对象，当每次对String进行改变时都需要生成一个新的String对象，然后将指针指向一个新的对象，如果在一个循环里面，不断的改变一个对象，就要不断的生成新的对象，所以效率很低，建议在不断更改String对象的地方不要使用String类型。</p><p>StringBuilder对象在做字符串连接操作时是在原来的字符串上进行修改，改善了性能。这一点我们平时使用中也许都知道，连接操作频繁的时候，使用StringBuilder对象。</p><p>六十七：Unity3D Shader分哪几种，有什么区别？</p><p>表面着色器的抽象层次比较高，它可以轻松地以简洁方式实现复杂着色。表面着色器可同时在前向渲染及延迟渲染模式下正常工作。</p><p>顶点片段着色器可以非常灵活地实现需要的效果，但是需要编写更多的代码，并且很难与Unity的渲染管线完美集成。</p><p>固定功能管线着色器可以作为前两种着色器的备用选择，当硬件无法运行那些酷炫Shader的时，还可以通过固定功能管线着色器来绘制出一些基本的内容。</p><p>六十八：已知strcpy函数的原型是：char * strcpy(char * strDest,const char * strSrc); 1.不调用库函数，实现strcpy函数。2.解释为什么要返回char *</p><p>char * strcpy(char * strDest,const char * strSrc)<br>{<br>if ((strDest==NULL)||(strSrc==NULL))<br>throw “Invalid argument(s)”;<br>char * strDestCopy=strDest;<br>while ((*strDest++=*strSrc++)!=’\0’);<br>return strDestCopy;<br>}<br>六十九：C#中四种访问修饰符是哪些？各有什么区别？</p><p>1.属性修饰符 2.存取修饰符 3.类修饰符 4.成员修饰符。</p><p>属性修饰符：</p><p>Serializable：按值将对象封送到远程服务器。</p><p>STATread：是单线程套间的意思，是一种线程模型。</p><p>MATAThread：是多线程套间的意思，也是一种线程模型。</p><p>存取修饰符：</p><p>public：存取不受限制。</p><p>private：只有包含该成员的类可以存取。</p><p>internal：只有当前工程可以存取。</p><p>protected：只有包含该成员的类以及派生类可以存取。</p><p>类修饰符：</p><p>abstract：抽象类。指示一个类只能作为其它类的基类。</p><p>sealed：密封类。指示一个类不能被继承。理所当然，密封类不能同时又是抽象类，因为抽象总是希望被继承的。</p><p>成员修饰符：</p><p>abstract：指示该方法或属性没有实现。</p><p>sealed：密封方法。可以防止在派生类中对该方法的override（重载）。不是类的每个成员方法都可以作为密封方法密封方法，必须对基类的虚方法进行重载，提供具体的实现方法。所以，在方法的声明中，sealed修饰符总是和override修饰符同时使用。</p><p>delegate：委托。用来定义一个函数指针。C#中的事件驱动是基于delegate + event的。</p><p>const：指定该成员的值只读不允许修改。</p><p>event：声明一个事件。</p><p>extern：指示方法在外部实现。</p><p>override：重写。对由基类继承成员的新实现。</p><p>readonly：指示一个域只能在声明时以及相同类的内部被赋值。</p><p>static：指示一个成员属于类型本身，而不是属于特定的对象。即在定义后可不经实例化，就可使用。</p><p>virtual：指示一个方法或存取器的实现可以在继承类中被覆盖。</p><p>new：在派生类中隐藏指定的基类成员，从而实现重写的功能。 若要隐藏继承类的成员，请使用相同名称在派生类中声明该成员，并用 new 修饰符修饰它。</p><p>七十：Heap与Stack有何区别？</p><p>1.heap是堆，stack是栈。</p><p>2.stack的空间由操作系统自动分配和释放，heap的空间是手动申请和释放的，heap常用new关键字来分配。</p><p>3.stack空间有限，heap的空间是很大的自由区。</p><p>七十一：值类型和引用类型有何区别？</p><p>1.值类型的数据存储在内存的栈中；引用类型的数据存储在内存的堆中，而内存单元中只存放堆中对象的地址。</p><p>2.值类型存取速度快，引用类型存取速度慢。</p><p>3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针或引用</p><p>4.值类型继承自System.ValueType，引用类型继承自System.Object</p><p>5.栈的内存分配是自动释放；而堆在.NET中会有GC来释放</p><p>6.值类型的变量直接存放实际的数据，而引用类型的变量存放的则是数据的地址，即对象的引用。</p><p>七十二：请写出求斐波那契数列任意一位的值得算法</p><p>递归实现：</p><p>int Fib1(int index)<br>{<br>if(index&lt;1)<br>{<br>return -1;<br>}<br>if(index==1|| index==2)<br>{<br>return 1;<br>}<br>return Fib1(index-1)+Fib1(index-2);<br>}<br>迭代实现：</p><p>int Fib5(int index)<br>{<br>if(index&lt;1)<br>{<br>return -1;<br>}<br>int a1 - 1, a2 = 1, a3 = 1;<br>for(int i = 0; i &lt; index - 2; i++)<br>{<br>a3=a1+a2;<br>a1=a2;<br>a2=a3;<br>}<br>return a3;<br>}<br>参看更多实现方法</p><p>七十三：协同程序的执行代码是什么？有何用处，有何缺点？</p><p>function Start() {<br>// 协同程序WaitAndPrint在Start函数内执行,可以视同于它与Start函数同步执行.<br>StartCoroutine(WaitAndPrint(2.0));<br>print (“Before WaitAndPrint Finishes ” + Time.time );<br>}<br>function WaitAndPrint (waitTime : float) {<br>// 暂停执行waitTime秒<br>yield WaitForSeconds (waitTime);<br>print (“WaitAndPrint “+ Time.time );<br>}</p><p>作用：一个协同程序在执行过程中,可以在任意位置使用yield语句。yield的返回值控制何时恢复协同程序向下执行。协同程序在对象自有帧执行过程中堪称优秀。协同程序在性能上没有更多的开销。</p><p>缺点：协同程序并非真线程，可能会发生堵塞。</p><p>七十四：什么是里氏代换元则？</p><p>里氏替换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。通俗点：就是子类对象可以赋值给基类对象，基类对象不能赋值给子类对象</p><p>参考</p><p>七十五：Mock和Stub有何区别？</p><p>Mock与Stub的区别：Mock:关注行为验证。细粒度的测试，即代码的逻辑，多数情况下用于单元测试。Stub：关注状态验证。粗粒度的测试，在某个依赖系统不存在或者还没实现或者难以测试的情况下使用，例如访问文件系统，数据库连接，远程协议等。</p><p>七十六：概述序列化：</p><p>序列化简单理解成把对象转换为容易传输的格式的过程。比如，可以序列化一个对象，然后使用HTTP通过Internet在客户端和服务器端之间传输该对象</p><p>七十七：堆和栈的区别？</p><p>栈通常保存着我们代码执行的步骤，如在代码段1中 AddFive()方法，int pValue变量，int result变量等等。而堆上存放的则多是对象，数据等。我们可以把栈想象成一个接着一个叠放在一起的盒子。当我们使用的时候，每次从最顶部取走一个盒子。栈也是如此，当一个方法（或类型）被调用完成的时候，就从栈顶取走，接着下一个。堆则不然，像是一个仓库，储存着我们使用的各种对象等信息，跟栈不同的是他们被调用完毕不会立即被清理掉。</p><p>七十八：概述c#中代理和事件？</p><p>代理就是用来定义指向方法的引用。</p><p>C＃事件本质就是对消息的封装，用作对象之间的通信；发送方叫事件发送器，接收方叫事件接收器</p><p>七十九：客户端与服务器交互方式有几种？</p><p>socket通常也称作”套接字”,实现服务器和客户端之间的物理连接，并进行数据传输，主要有UDP和TCP两个协议。Socket处于网络协议的传输层。</p><p>http协议传输的主要有http协议 和基于http协议的Soap协议（web service）,常见的方式是 http 的post 和get 请求，web 服务。</p><p>八十：Unity和Android与iOS如何交互？</p><p>Unity可以到处Android和iOS的工程，然后通过安卓或者iOS的类去给Unity发消息，调用Unity中的方法</p><p>八十一：如何在Unity3D中查看场景的面试，顶点数和Draw Call数？如何降低Draw Call数？</p><p>在Game视图右上角点击Stats。降低Draw Call 的技术是Draw Call Batching</p><p>这个在5.0以后在window-》Profiler下面，快捷键是cmd + 7（ctl + 7</p><p>八十二：请问alpha test在何时使用？能达到什么效果？</p><p>Alpha Test ,中文就是透明度测试。简而言之就是V&amp;F shader中最后fragment函数输出的该点颜色值（即上一讲frag的输出half4）的alpha值与固定值进行比较。AlphaTest语句通常于Pass{}中的起始位置。Alpha Test产生的效果也很极端，要么完全透明，即看不到，要么完全不透明。</p><p>八十三：UNITY3d在移动设备上的一些优化资源的方法</p><p>1.使用assetbundle，实现资源分离和共享，将内存控制到200m之内，同时也可以实现资源的在线更新</p><p>2.顶点数对渲染无论是cpu还是gpu都是压力最大的贡献者，降低顶点数到8万以下，fps稳定到了30帧左右</p><p>3.只使用一盏动态光，不是用阴影，不使用光照探头</p><p>粒子系统是cpu上的大头</p><p>4.剪裁粒子系统</p><p>5.合并同时出现的粒子系统</p><p>6.自己实现轻量级的粒子系统</p><p>animator也是一个效率奇差的地方</p><p>7.把不需要跟骨骼动画和动作过渡的地方全部使用animation，控制骨骼数量在30根以下</p><p>8.animator出视野不更新</p><p>9.删除无意义的animator</p><p>10.animator的初始化很耗时（粒子上能不能尽量不用animator）</p><p>11.除主角外都不要跟骨骼运动apply root motion</p><p>12.绝对禁止掉那些不带刚体带包围盒的物体（static collider ）运动</p><p>NUGI的代码效率很差，基本上runtime的时候对cpu的贡献和render不相上下</p><p>13每帧递归的计算finalalpha改为只有初始化和变动时计算</p><p>14去掉法线计算</p><p>15不要每帧计算viewsize 和windowsize</p><p>16filldrawcall时构建顶点缓存使用array.copy</p><p>17.代码剪裁：使用strip level ，使用.net2.0 subset</p><p>18.尽量减少smooth group</p><p>19.给美术定一个严格的经过科学验证的美术标准，并在U3D里面配以相应的检查工具</p><p>八十四：四元数有什么作用？</p><p>对旋转角度进行计算时用到四元数</p><p>八十五：将Camera组件的ClearFlags选项选成Depth only是什么意思？有何用处？</p><p>如果把摄像机的ClearFlags勾选为Deapth Only,那么摄像机就会只渲染看得见的对象，把背景会完全透明，这种情况一般用在两个摄像机以上的场景中</p><p>八十六：在编辑场景时将GameObject设置为Static有何作用？</p><p>设置游戏对象为Static时，这些部分被静态物体挡住而不可见时，将会剔除（或禁用）网格对象。因此，在你的场景中的所有不会动的物体都应该标记为Static。</p><p>八十七：有A和B两组物体，有什么办法能够保证A组物体永远比B组物体先渲染？</p><p>把A组物体的渲染对列大于B物体的渲染队列，通过shader里面的渲染队列来渲染</p><p>八十八：将图片的TextureType选项分别选为““Texture”和“Sprite”有什么区别</p><p>Sprite作为UI精灵使用，Texture作用模型贴图使用。Sprite需要2的整次幂，打包图片省资源</p><p>八十九：问一个Terrain，分别贴3张，4张，5张地表贴图，渲染速度有什么区别？为什么？</p><p>没有区别，因为不管几张贴图只渲染一次。</p><p>九十：什么是DrawCall？DrawCall高了又什么影响？如何降低DrawCall？</p><p>Unity中，每次引擎准备数据并通知GPU的过程称为一次Draw Call。DrawCall越高对显卡的消耗就越大。降低DrawCall的方法：</p><p>Dynamic Batching</p><p>Static Batching</p><p>高级特性Shader降级为统一的低级特性的Shader。</p><p>九十一：实时点光源的优缺点是什么？</p><p>可以有cookies – 带有 alpha通道的立方图(Cubemap )纹理。点光源是最耗费资源的。</p><p>九十二：Unity的Shader中，Blend SrcAlpha OneMinusSrcAlpha这句话是什么意思？</p><p>作用就是Alpha混合。公式：最终颜色 = 源颜色 x 源透明值 + 目标颜色 x（1 - 源透明值）</p><p>九十三：简述水面倒影的渲染原理</p><p>原理就是对水面的贴图纹理进行扰动，以产生波光玲玲的效果。用shader可以通过GPU在像素级别作扰动，效果细腻，需要的顶点少，速度快</p><p>九十四：简述NGUI中Grid和Table的作用？</p><p>对Grid和Table下的子物体进行排序和定位</p><p>九十五：请简述NGUI中Panel和Anchor的作用</p><p>只要提供一个half-pixel偏移量，它可以让一个控件的位置在Windows系统上精确的显示出来（只有这个Anchor的子控件会受到影响）</p><p>如果挂载到一个对象上，那么他可以将这个对象依附到屏幕的角落或者边缘</p><p>3.UIPanel用来收集和管理它下面所有widget的组件。通过widget的geometry创建实际的draw call。没有panel所有东西都不能够被渲染出来,你可以把UIPanel当做Renderer</p><p>九十六：能用foreach遍历访问的对象需要实现接口或声明___方法的类型</p><p>IEnumerable；GetEnumerator</p>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#快速排序</title>
    <link href="/2017/10/22/C-%E5%BF%AB%E6%8E%92/"/>
    <url>/2017/10/22/C-%E5%BF%AB%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><div class="code-wrapper"><pre><code class="hljs c#">namespace 快速排序&#123;    class Program    &#123;        static void Main(string[] args)        &#123;                       int[] nums = &#123; 1, 9, 6, 4, 2, 5, 7, 10, 3, 8 &#125;;                      Quicksort(0, nums.Length-1 , nums);            for (int i = 0; i &lt; nums.Length; i++)            &#123;                Console.WriteLine(nums [i]);            &#125;            Console.ReadKey();        &#125;        static void Quicksort(int left,int right, int[] a)        &#123;            int i, j, t, temp;//定义四个变量            if(left &gt;right)            &#123;                return;            &#125;            i = left; //左            j = right; //右            temp = a[left]; //数组最左边的元素，也是基准数            while (i != j)            &#123;                while (a[j] &gt;= temp &amp;&amp; i &lt; j) j--;//从右往左找                while (a[i] &lt;= temp &amp;&amp; i &lt; j) i++;//从左往右找                if (i &lt; j)//左右两边没有碰头的情况下，左右交换                &#123;                    t = a[i];                    a[i] = a[j];                    a[j] = t;                &#125;            &#125;            a[left] = a[i]; //            a[i] = temp;            Quicksort(left, i - 1, a);            Quicksort(i + 1, right, a);            return;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#冒泡排序</title>
    <link href="/2017/10/22/C-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2017/10/22/C-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="控制台运行以下代码"><a href="#控制台运行以下代码" class="headerlink" title="控制台运行以下代码"></a>控制台运行以下代码</h3><div class="code-wrapper"><pre><code class="hljs C#">int[] nums = &#123; 0, 5, 8, 3, 4, 1, 6, 7, 2, 9 &#125;;for (int i = 0; i &lt; nums.Length - 1; i++)&#123;    for (int j = 0; j &lt; nums.Length - 1 - i; j++)    &#123;        if (nums[j] &gt; nums[j + 1])        &#123;            int temp = nums[j];            nums[j] = nums[j + 1];            nums[j + 1] = temp;        &#125;    &#125;&#125;for (int i = 0; i &lt; nums.Length; i++)&#123;    Console.WriteLine(nums[i]);&#125;Console.ReadKey();</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shader语义</title>
    <link href="/2017/10/22/Shader%E8%AF%AD%E4%B9%89/"/>
    <url>/2017/10/22/Shader%E8%AF%AD%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><div class="code-wrapper"><pre><code class="hljs mipsasm">概念：顾名思义，就是语句的含义，通俗的说：就是告诉<span class="hljs-keyword">Shader从哪里得到这些参数，并且又把这些参数输出到哪里。</span><span class="hljs-keyword"></span>其实语义是HLSL中的语法，但是Unity中的<span class="hljs-keyword">ShaderLab并不支持全部语义</span><span class="hljs-keyword"></span><span class="hljs-keyword">DirectX10之后，有了一种新的语义，叫做系统数值语义，这些语义是以SV开头的。</span><span class="hljs-keyword"></span>这些语义有特殊的含义，不能随便赋值，比如SV_POSITION，在系统中表示齐次空间下的坐标。再比如SV_Target，就代表从片段着色器中输出的即将要存储到渲染目标上的颜色值。比如索尼的PS4上就不能使用COLOR来代替SV_Target所以为了良好的跨平台型，特殊的地方要使用特殊语义。 Unity中所支持的语义：从应用阶段传输参数到顶点着色器阶段的时候有一些特殊的语义：<span class="hljs-number">1</span>：POSITION：通常代表模型坐标系下的顶点坐标，通常是float4<span class="hljs-number">2</span>：<span class="hljs-keyword">NORMAL </span>:  顶点法线，通常是float3类型<span class="hljs-number">3</span>：TANGENT : 顶点切线，通常是float4类型<span class="hljs-number">4</span>：TEXCOORDn ： 从第<span class="hljs-number">1</span>套到第七套<span class="hljs-number">5</span>：COLOR ： 顶点颜色，通常是fixed4或者float4类型 从顶点着色器传输参数到片段着色器阶段的时候一些特殊语义：SV_POSITION ：代表齐次裁剪坐标系中的坐标位置，是必须要有的COLOR0 ：通常用于输出第一组顶点颜色，但是不是必须的COLOR1 ： 通常用于输出第二组顶点颜色，但是不是必须的TEXCOORD0 ~ TEXCOORD7 : 通常用于输出纹理坐标，从第一套到第八套。 片段着色器输出的时候Unity支持的语义：SV_Target : 输出的值会存储到渲染目标中, 等同于 <span class="hljs-keyword">Direct9 </span>中的COLOR, 但是大家必须要在这里使用SV_Target； </code></pre></div><h3 id="Unity内置变换矩阵："><a href="#Unity内置变换矩阵：" class="headerlink" title="Unity内置变换矩阵："></a>Unity内置变换矩阵：</h3><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>UNITY_MATRIX_MVP</td><td>模型（M）观察（V）投影（P）矩阵，从模型空间到裁剪空间</td></tr><tr><td>UNITY_MATRIX_MV</td><td>模型（M）观察（V）矩阵，从模型空间到观察空间</td></tr><tr><td>UNITY_MATRIX_V</td><td>观察（V）矩阵，从世界空间到观察空间</td></tr><tr><td>UNITY_MATRIX_P</td><td>投影（P）矩阵，从观察空间到裁剪空间</td></tr><tr><td>UNITY_MATRIX_VP</td><td>观察（V）投影（P）矩阵，从世界空间到裁剪空间</td></tr><tr><td>UNITY_MATRIX_T_MV</td><td>UNITY_MATRIX_MV的转置矩阵</td></tr><tr><td>UNITY_MATRIX_IT_MV</td><td>UNITY_MATRIX_MV的逆转置矩阵，用于将法线从模型空间转换到观察空间</td></tr><tr><td>_Object2World</td><td>模型矩阵，从模型空间到世界空间</td></tr><tr><td>_World2Object</td><td>_Object2World的逆矩阵，从世界空间到模型空间</td></tr></tbody></table><h3 id="Untiy摄像机和屏幕参数："><a href="#Untiy摄像机和屏幕参数：" class="headerlink" title="Untiy摄像机和屏幕参数："></a>Untiy摄像机和屏幕参数：</h3><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>_WorldSpaceCameraPos(float3)</td><td>摄像机的世界坐标</td></tr><tr><td>_ProjectionParams(float4)</td><td>投影参数: x=±1.0（-1.0表示使用翻转投影矩阵进行渲染）y=Near近裁剪平面与摄像机的距离z=Far远裁剪平面与摄像机的 距离w=1.0+1.0/Far</td></tr><tr><td>_ScreenParams(float4)</td><td>屏幕参数: x=width渲染目标的像素宽度,y=height渲染目标的像素高度,z=1.0+1.0/width,w=1.0+1.0/height</td></tr><tr><td>_ZBufferParams(float4)</td><td>线性化Z（深度）缓冲参数,x=1-Far/Near,y=Far/Near,z=x/Far,w=y/Far</td></tr><tr><td>unity_OrthoParams(float4)</td><td>正交投影摄像机参数,x=width,y=height,z未使用,w=1.0（正交投影摄像机）或0.0（透视摄像机）</td></tr><tr><td>unity_CameraProjection(float4x4)</td><td>摄像机投影矩阵</td></tr><tr><td>unity_CameraInvProjection(float4x4)</td><td>unity_CameraProjection的逆矩阵</td></tr><tr><td>unity_CameraWorldClipPlanes(float4[6])</td><td>摄像机6个裁剪平面在世界空间下的方程式。顺序：左、右、下、上、近、远</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shader光照公式</title>
    <link href="/2017/10/22/Shader%E5%85%89%E7%85%A7%E5%85%AC%E5%BC%8F/"/>
    <url>/2017/10/22/Shader%E5%85%89%E7%85%A7%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="计算机图形学第一定律：如果看起来是对的，那么就是对的。"><a href="#计算机图形学第一定律：如果看起来是对的，那么就是对的。" class="headerlink" title="计算机图形学第一定律：如果看起来是对的，那么就是对的。"></a>计算机图形学第一定律：如果看起来是对的，那么就是对的。</h3><h4 id="计算机图形学中的基本光照模型："><a href="#计算机图形学中的基本光照模型：" class="headerlink" title="计算机图形学中的基本光照模型："></a>计算机图形学中的基本光照模型：</h4><p>光照模型：用数学的方法模拟现实世界中的光照效果。<br>漫反射光照(Diffuse)：<br>当我们的平行光照射到物体表面的时候，会出现散射，散射出两种方向：<br>1：反射：经过顶点的法线，反射出去 ： 高光反射<br>2：折射：进入到物体内部，在物体内部也经过很多反射，最后再射出物体表面：漫反射</p><h4 id="在标准光照模型下：只关心直接光照。"><a href="#在标准光照模型下：只关心直接光照。" class="headerlink" title="在标准光照模型下：只关心直接光照。"></a>在标准光照模型下：只关心直接光照。</h4><p>把射入摄像机的光线分为4部分：<br>1：自发光，在Unity中如果不开启全局光照，自发光的物体就不会照亮周围环境<br>2：高光反射：镜面反射<br>3：漫反射：在物体表面每一个方向反射出多少辐射量<br>4：环境光：用于描述其他所有间接光照。</p><h5 id="漫反射光照模型的公式：-兰伯特光照"><a href="#漫反射光照模型的公式：-兰伯特光照" class="headerlink" title="漫反射光照模型的公式：(兰伯特光照)"></a>漫反射光照模型的公式：(兰伯特光照)</h5><div class="code-wrapper"><pre><code class="hljs lisp">c(<span class="hljs-name">diffuse</span>) = c(<span class="hljs-name">light</span>) * m(<span class="hljs-name">diffuse</span>) * max(<span class="hljs-number">0</span>, dot(<span class="hljs-name">N</span>,I))<span class="hljs-comment">;</span></code></pre></div><h5 id="半兰伯特光照："><a href="#半兰伯特光照：" class="headerlink" title="半兰伯特光照："></a>半兰伯特光照：</h5><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">c</span>(diffuse) = c(light) * m(diffuse) * (dot(N,I) * <span class="hljs-number">0</span>.<span class="hljs-number">5</span> + <span class="hljs-number">0</span>.<span class="hljs-number">5</span>);</code></pre></div><p>半兰伯特光照有效的解决了背向光源的时候纯色的效果。</p><h5 id="高光反射："><a href="#高光反射：" class="headerlink" title="高光反射："></a>高光反射：</h5><div class="code-wrapper"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">c</span><span class="hljs-params">(specular)</span> = <span class="hljs-title">c</span><span class="hljs-params">(light)</span> * <span class="hljs-title">m</span><span class="hljs-params">(specular)</span> * <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-number">0</span>, dot(v, r))</span> ^ <span class="hljs-title">m</span><span class="hljs-params">(gloss)</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UnityUI加载进度条</title>
    <link href="/2017/10/22/UnityUI%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <url>/2017/10/22/UnityUI%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="初学者的写法："><a href="#初学者的写法：" class="headerlink" title="初学者的写法："></a>初学者的写法：</h4><div class="code-wrapper"><pre><code class="hljs arduino">System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">using</span> UnityEngine.SceneManagement;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewBehaviourScript</span> :</span> MonoBehaviour &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> UI_Wight;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> UI_Height;    <span class="hljs-keyword">float</span> process;    <span class="hljs-keyword">float</span> _process;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;                  &#125;     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span></span><span class="hljs-function">     </span>&#123;                   &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        GUI.color = Color.red;        <span class="hljs-keyword">if</span>(GUI.<span class="hljs-built_in">Button</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Rect</span>(Screen.width / <span class="hljs-number">2</span> - UI_Wight / <span class="hljs-number">2</span>, Screen.height / <span class="hljs-number">2</span> - UI_Height / <span class="hljs-number">2</span>, UI_Wight, UI_Height),<span class="hljs-string">&quot;开始游戏&quot;</span>))        &#123;            <span class="hljs-built_in">StartCoroutine</span>(<span class="hljs-string">&quot;LoadSceneFromBtn&quot;</span>);        &#125;        GUILayout.<span class="hljs-built_in">Label</span>(<span class="hljs-string">&quot;场景加载进度&quot;</span> + _process *<span class="hljs-number">100</span> +<span class="hljs-string">&quot;%&quot;</span>);    &#125;    <span class="hljs-function">IEnumerator <span class="hljs-title">LoadSceneFromBtn</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;         AsyncOperation ao= SceneManager.<span class="hljs-built_in">LoadSceneAsync</span>(<span class="hljs-number">1</span>);        ao.allowSceneActivation = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">while</span> (_process&lt;<span class="hljs-number">1.0f</span>)        &#123;            process =ao.progress;            <span class="hljs-keyword">if</span> (_process &gt;= <span class="hljs-number">0.9f</span>)            &#123;               _process= Mathf.<span class="hljs-built_in">MoveTowards</span>(_process, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.01f</span>);            &#125;            <span class="hljs-keyword">else</span>            &#123;               _process= Mathf.<span class="hljs-built_in">MoveTowards</span>(_process, process, <span class="hljs-number">0.01f</span>);            &#125;            yield <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        ao.allowSceneActivation = <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shader渲染管线流程</title>
    <link href="/2017/10/22/shader%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    <url>/2017/10/22/shader%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="渲染管线流程："><a href="#渲染管线流程：" class="headerlink" title="渲染管线流程："></a>渲染管线流程：</h3><ol><li>应用程序阶段：主要是计算机CPU和内存通信，将模型身上的顶点信息，包括顶点坐标、纹理坐标、法线等，组装成一个图元，将图元信息发送给GPU</li><li>几何阶段：用来处理几何上的事情，这些操作通常在GPU上执行，这一阶段最重要的任务就是将图元信息中的顶点坐标变换到屏幕坐标系中，交给光栅化阶段处理。</li><li>光栅化阶段：对上一阶段传入的参数进行顶点处理，将顶点数据进行插值运算，然后再进行逐像素操作，最后将每一个像素点的颜色计算出来，写入到帧缓存中。</li></ol><h3 id="我们将几何阶段和光栅化阶段进行细分："><a href="#我们将几何阶段和光栅化阶段进行细分：" class="headerlink" title="我们将几何阶段和光栅化阶段进行细分："></a>我们将几何阶段和光栅化阶段进行细分：</h3><ol><li>顶点着色器：将模型的模型坐标转换到齐次裁剪坐标系中，方便于投射到屏幕上。</li><li>裁剪：是将不在摄像机范围内的游戏对象剪掉</li><li>屏幕映射：将裁剪好了的顶点投射到2维屏幕坐标系下</li><li>三角形设置：将每一个顶点都通过三角形索引组合起来，产生联系，产生面</li><li>三角形遍历：这一步是通过检查每一个像素是否被一个三角形大面积覆盖</li><li>片元/片段着色器：可以从顶点着色器中取到对应的插值，片元着色器输出的是一个或多个颜色值，在这一阶段我们可以进行纹理采样</li><li>逐像素操作：通过模板测试和深度测试，来确定每一个像素是否可以被显示。如果当前颜色通过了所有的测试，就可以存储到颜色缓冲区中，下一帧屏幕刷新的时候，就把颜色缓冲区中的颜色取出来打到屏幕的像素点上。</li></ol><p>ShaderLab中我们常常需要使用一些参数，但是这些参数是应用程序阶段传给我们的，我们需要的参数类型怎么让应用程序阶段知道？需要针对我们的形参声明说明语义</p>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#协同知识点</title>
    <link href="/2017/10/22/C-%E5%8D%8F%E5%90%8C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2017/10/22/C-%E5%8D%8F%E5%90%8C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="启动协同方法"><a href="#启动协同方法" class="headerlink" title="启动协同方法"></a>启动协同方法</h4><div class="code-wrapper"><pre><code class="hljs awk">方法<span class="hljs-number">1</span>：StartCouroutine(“Fun”);   <span class="hljs-regexp">//</span> 只能调用对象自身的协同方法方法<span class="hljs-number">2</span>：StartCouroutine(Fun());   <span class="hljs-regexp">//</span> 可以调用其他对象的协同方法</code></pre></div><h4 id="定义协同方法-协同方法中必须要有yield语句"><a href="#定义协同方法-协同方法中必须要有yield语句" class="headerlink" title="定义协同方法: 协同方法中必须要有yield语句"></a>定义协同方法: 协同方法中必须要有yield语句</h4><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function">IEnumerator <span class="hljs-title">Fun</span>(<span class="hljs-params"></span>)</span>   &#123;       <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForFixedUpdate</span>(<span class="hljs-params"></span>)</span>;    <span class="hljs-comment">// 当前帧返回，在FixedUpdate执行之后返回。</span>       <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSecond</span>(<span class="hljs-params"><span class="hljs-number">3</span></span>)</span>;  <span class="hljs-comment">// 等待3秒，等待的每一帧在当前帧Update执行之后返回。</span>       <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 等待一帧（当前帧Update执行之后返回，下一帧继续执行后面的代码）。</span>       <span class="hljs-keyword">if</span>(条件)           <span class="hljs-keyword">yield</span> <span class="hljs-keyword">break</span>;    <span class="hljs-comment">// 终止协同方法。</span>       <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">OtherFun(</span>))</span>;    <span class="hljs-comment">// 在OtherFun全部执行完以后，继续执行后面的代码。</span>       <span class="hljs-comment">//StartCoroutine(OtherFun());</span>       <span class="hljs-comment">// yield语句之间，都是当前帧执行的代码。</span>       <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForEndOfFrame</span>(<span class="hljs-params"></span>)</span>;    <span class="hljs-comment">// 在执行渲染之后返回。</span>   &#125;   <span class="hljs-function">IEnumerator <span class="hljs-title">OtherFun</span>(<span class="hljs-params"></span>)</span>   &#123;       <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)       &#123;           Instance&lt;GameObject&gt;(GameObject.CreatePrimitive(PrimitiveType.Cube));           <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSecond</span>(<span class="hljs-params"><span class="hljs-number">0.5f</span></span>)</span>;       &#125;   &#125;</code></pre></div><h4 id="终止协同-终止对象自身调用的协同"><a href="#终止协同-终止对象自身调用的协同" class="headerlink" title="终止协同 (终止对象自身调用的协同)"></a>终止协同 (终止对象自身调用的协同)</h4><div class="code-wrapper"><pre><code class="hljs awk">StopCoroutine(“Fun”);    <span class="hljs-regexp">//</span> 只能终止以字符串开启的协同。StopAllCoroutine();     <span class="hljs-regexp">//</span> 终止以上两种形式开启的协同。</code></pre></div><h4 id="更多概念"><a href="#更多概念" class="headerlink" title="更多概念"></a>更多概念</h4><ol><li>协同必须在 MonoBehaviour 继承类中启动。</li><li>协同定义随便，只要在 Unity 引擎内的什么类中都可以定义。</li><li>协同一旦启动它会立即执行协同函数的第一段，所以你尽量不要把荷很大的代码写在第一段里。</li><li>协同除了第一次启动会立即执行外，其他时候都是在 Update 函之后。</li><li>协同是假的多线程，所以它可以无条件访问成员级变量和函数，无线程互斥。</li><li>协同函数中定义变量是协同函数全局的。</li><li>协同函数中的代码都是过程化的，没有面向对象的概念。</li><li>不要在循环中调用协同方法。</li><li>事件函数也可以改写成协同方法。</li><li>哪个对象开启的协同，就只能由哪个对象终止。</li><li>组件对象失活，则该对象开启的协同也会终止。</li><li>游戏物体失活，也会使组件对象失活，所以也会终止协同程序</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
