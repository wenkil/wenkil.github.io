

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/titleIcon.png">
  <link rel="icon" href="/img/titleIcon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="在前面的Langgraph学习文章中，简单搭了一个Langgraph的基础流程和如何让LLM调用工具。本篇继续深入，将结合基本chatbot流程，搭建一个能够进行Web搜索的AI助手。 1. 集成搜索API首先我们需要一个搜索工具。可以直接使用Langchain提供的Tavily搜索API，它是一个针对AI优化的搜索引擎，不过它的官方个人免费账户每个月只能调用1000次，这里我们先选择免费的的Du">
<meta property="og:type" content="article">
<meta property="og:title" content="Langgraph学习4：搭一个web搜索agent">
<meta property="og:url" content="http://example.com/2025/04/11/Langgraph%E5%AD%A6%E4%B9%A04%EF%BC%9A%E6%90%AD%E4%B8%80%E4%B8%AAweb%E6%90%9C%E7%B4%A2agent/index.html">
<meta property="og:site_name" content="Wenkil的开发笔记">
<meta property="og:description" content="在前面的Langgraph学习文章中，简单搭了一个Langgraph的基础流程和如何让LLM调用工具。本篇继续深入，将结合基本chatbot流程，搭建一个能够进行Web搜索的AI助手。 1. 集成搜索API首先我们需要一个搜索工具。可以直接使用Langchain提供的Tavily搜索API，它是一个针对AI优化的搜索引擎，不过它的官方个人免费账户每个月只能调用1000次，这里我们先选择免费的的Du">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/blog/AI/langgraph/workflow_graph-2025-04-11_15-32-50.png">
<meta property="article:published_time" content="2025-04-11T09:23:00.000Z">
<meta property="article:modified_time" content="2025-04-11T09:29:04.966Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Langgraph">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/blog/AI/langgraph/workflow_graph-2025-04-11_15-32-50.png">
  
  <title>Langgraph学习4：搭一个web搜索agent - Wenkil的开发笔记</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wenkil的开发笔记</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/blog.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Langgraph学习4：搭一个web搜索agent">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-04-11 17:23" pubdate>
        2025年4月11日 17:23:00
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Langgraph学习4：搭一个web搜索agent</h1>
            
            <div class="markdown-body">
              <p>在前面的Langgraph学习文章中，简单搭了一个Langgraph的基础流程和如何让LLM调用工具。本篇继续深入，将结合基本chatbot流程，搭建一个能够进行Web搜索的AI助手。</p>
<h2 id="1-集成搜索API"><a href="#1-集成搜索API" class="headerlink" title="1. 集成搜索API"></a>1. 集成搜索API</h2><p>首先我们需要一个搜索工具。可以直接使用Langchain提供的Tavily搜索API，它是一个针对AI优化的搜索引擎，不过它的官方个人免费账户每个月只能调用1000次，这里我们先选择免费的的DuckDuckGo搜索：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_community.tools.ddg_search.tool <span class="hljs-keyword">import</span> DuckDuckGoSearchResults
<span class="hljs-keyword">from</span> langchain_core.tools <span class="hljs-keyword">import</span> tool

<span class="hljs-meta">@tool</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">query: <span class="hljs-built_in">str</span></span>):</span>
    <span class="hljs-string">&quot;&quot;&quot;用于浏览网络进行搜索。&quot;&quot;&quot;</span>
    <span class="hljs-comment"># 可选的搜索工具: TavilySearchResults(max_results=3)</span>
    search_tool = DuckDuckGoSearchResults(max_results=<span class="hljs-number">3</span>) <span class="hljs-comment">#这个配置根据需求来设置 output_format=&quot;list&quot;</span>
    <span class="hljs-keyword">return</span> search_tool.invoke(query)</code></pre></div>

<p>这里我们使用<code>DuckDuckGoSearchResults</code>作为搜索引擎，并设置最大返回结果数为3，输出格式为列表。</p>
<h2 id="2-自定义搜索工具节点"><a href="#2-自定义搜索工具节点" class="headerlink" title="2. 自定义搜索工具节点"></a>2. 自定义搜索工具节点</h2><p>与第二篇文章不同，这次不使用Langgraph的ToolNode，而是自定义一个更灵活的搜索节点：</p>
<div class="code-wrapper"><pre><code class="hljs python">tools_by_name = &#123;tool.name: tool <span class="hljs-keyword">for</span> tool <span class="hljs-keyword">in</span> tools&#125;

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_tool_node</span>(<span class="hljs-params">state: <span class="hljs-built_in">dict</span></span>):</span>
    result = []
    <span class="hljs-keyword">for</span> tool_call <span class="hljs-keyword">in</span> state[<span class="hljs-string">&quot;messages&quot;</span>][-<span class="hljs-number">1</span>].tool_calls:
        tool = tools_by_name[tool_call[<span class="hljs-string">&quot;name&quot;</span>]]
        observation = tool.invoke(tool_call[<span class="hljs-string">&quot;args&quot;</span>])
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;工具搜索结果的完整输出------&gt;&#x27;</span>,observation,<span class="hljs-string">&#x27;\n&#x27;</span>)
        <span class="hljs-comment"># 直接转为字符串</span>
        search_result = <span class="hljs-built_in">str</span>(observation)
        result.append(ToolMessage(content=search_result, tool_call_id=tool_call[<span class="hljs-string">&quot;id&quot;</span>]))
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;messages&quot;</span>: result&#125;</code></pre></div>

<p>这个节点做了几件事：</p>
<ol>
<li>从状态中获取最后一条消息的工具调用信息</li>
<li>根据工具名称找到对应的工具函数</li>
<li>执行工具调用并获取结果</li>
<li><strong>将结果转换为字符串</strong>（这一步比较关键！）</li>
<li>将结果封装为ToolMessage并返回</li>
</ol>
<p>自定义节点比使用预设的ToolNode更灵活，方便我们添加更多处理逻辑。特别是第4步，将搜索结果转换为字符串是解决与LLM兼容性问题的关键。</p>
<h3 id="处理搜索结果格式问题"><a href="#处理搜索结果格式问题" class="headerlink" title="处理搜索结果格式问题"></a>处理搜索结果格式问题</h3><p>在实际测试中，如果直接将搜索工具返回的原始对象传递给LLM，会遇到以下错误：</p>
<div class="code-wrapper"><pre><code class="hljs routeros">graph.astream_events执行出错: <span class="hljs-builtin-name">Error</span> code: 400 - &#123;<span class="hljs-string">&#x27;code&#x27;</span>: 20029, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;Only text and image_url are supported.&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: None&#125;</code></pre></div>

<p>这是因为大多数LLM API只支持文本和图片URL作为输入，而TavilySearchResults搜索工具返回的是一个复杂的Python对象（通常是列表或字典），而DuckDuckGoSearchResults如果不加output_format=”list”的配置天然返回的就是个字符串。所以通过简单地使用<code>str(observation)</code>将结果转换为字符串，可以解决这个问题，确保了与LLM API的兼容性。如果是需要手动处理好格式，比如对list做一个处理，就在这里直接把处理完的结构再改为字符串输出给LLM。</p>
<h2 id="3-条件路由函数"><a href="#3-条件路由函数" class="headerlink" title="3. 条件路由函数"></a>3. 条件路由函数</h2><p>条件路由函数决定了工作流的执行路径：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">route_tools</span>(<span class="hljs-params">state: MessagesState</span>):</span>
    <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    在条件边中使用,如果最后一条消息包含工具调用,则路由到工具节点,否则路由到结束节点。</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>
    messages = state[<span class="hljs-string">&#x27;messages&#x27;</span>]
    last_message = messages[-<span class="hljs-number">1</span>]
    <span class="hljs-comment"># 检查是否是AI消息且有工具调用</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(last_message, <span class="hljs-string">&#x27;tool_calls&#x27;</span>) <span class="hljs-keyword">and</span> last_message.tool_calls:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;search_tool&quot;</span>  <span class="hljs-comment"># 如果有工具调用，路由到工具节点</span>
    
    <span class="hljs-keyword">return</span> END</code></pre></div>

<h2 id="4-构建工作流"><a href="#4-构建工作流" class="headerlink" title="4. 构建工作流"></a>4. 构建工作流</h2><p>接下来完成工作流的构建：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 创建图构建器</span>
graph_builder = StateGraph(MessagesState)

<span class="hljs-comment"># 添加节点</span>
graph_builder.add_node(<span class="hljs-string">&quot;chatbot&quot;</span>, chatbot_stream)
graph_builder.add_node(<span class="hljs-string">&quot;search_tool&quot;</span>, search_tool_node)

<span class="hljs-comment"># 设置入口点</span>
graph_builder.set_entry_point(<span class="hljs-string">&quot;chatbot&quot;</span>)

<span class="hljs-comment"># 添加条件边</span>
graph_builder.add_conditional_edges(
    <span class="hljs-string">&quot;chatbot&quot;</span>,
    route_tools
)

<span class="hljs-comment"># 添加从搜索工具节点返回到聊天节点</span>
graph_builder.add_edge(<span class="hljs-string">&quot;search_tool&quot;</span>, <span class="hljs-string">&quot;chatbot&quot;</span>)

<span class="hljs-comment"># 编译图</span>
graph = graph_builder.<span class="hljs-built_in">compile</span>()</code></pre></div>

<p>这个工作流的执行路径有两种可能：</p>
<ol>
<li>chatbot → END （如果LLM直接回答，不需要搜索）</li>
<li>chatbot → search_tool → chatbot → END （如果需要搜索信息）</li>
</ol>
<p>第二种路径中，search_tool执行完后会回到chatbot，让LLM基于搜索结果生成最终回复。这是一个循环结构，允许LLM在必要时多次调用搜索工具。</p>
<h2 id="5-定义LLM处理节点"><a href="#5-定义LLM处理节点" class="headerlink" title="5. 定义LLM处理节点"></a>5. 定义LLM处理节点</h2><p>我们需要一个节点来处理用户输入并生成LLM响应：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chatbot_stream</span>(<span class="hljs-params">state: MessagesState</span>):</span>
    <span class="hljs-string">&quot;&quot;&quot;生成流式回复的节点函数&quot;&quot;&quot;</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;chatbot_stream收到的完整输入------&gt;&#x27;</span>,state,<span class="hljs-string">&#x27;\n&#x27;</span>)
    messages = state[<span class="hljs-string">&quot;messages&quot;</span>]
    
    <span class="hljs-comment"># 使用非流式方式接收完整返回</span>
    response = llm_with_tools.invoke(
        messages,
        functions=functions,
        function_call=<span class="hljs-string">&quot;auto&quot;</span>
    )
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;messages&quot;</span>: [response]&#125;</code></pre></div>

<p>这个函数接收当前的消息历史作为输入，使用LLM生成回复。我们设置<code>function_call=&quot;auto&quot;</code>，让LLM自行决定是否需要调用工具。</p>
<h2 id="6-准备System-Prompt和测试"><a href="#6-准备System-Prompt和测试" class="headerlink" title="6. 准备System Prompt和测试"></a>6. 准备System Prompt和测试</h2><p>为了引导LLM正确使用搜索工具，这里设计了一个详细的System Prompt：</p>
<div class="code-wrapper"><pre><code class="hljs python">today = datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%d&quot;</span>)
system_message = SystemMessage(content=<span class="hljs-string">f&quot;&quot;&quot;</span>
<span class="hljs-string">    # 你是一个善于分析的AI助手。</span>
<span class="hljs-string">    ## 对于用户的所有问题，先分析是否需要调用搜索工具，再进行回复，比如查询东西，需要调用搜索工具，如果只是问问题，则不需要调用搜索工具。</span>
<span class="hljs-string">    ## 请牢记今天的日期是<span class="hljs-subst">&#123;today&#125;</span>,调用工具时，直接使用<span class="hljs-subst">&#123;today&#125;</span>的日期。</span>
<span class="hljs-string">    - 分析示例:比如用户询问日历,黄历,新闻等实时查询相关的需要调用工具;比如询问今天的新闻或今天的日历。直接把<span class="hljs-subst">&#123;today&#125;</span>的日期作为参数传给搜索工具去做搜索。</span>
<span class="hljs-string">    - 每个搜索结果都需要按照以下格式返回：</span>
<span class="hljs-string">        - 标题：</span>
<span class="hljs-string">        - 摘要：</span>
<span class="hljs-string">        - 链接：</span>
<span class="hljs-string">&quot;&quot;&quot;</span>)</code></pre></div>

<p>System Prompt的设计包含了几个关键要素：</p>
<ol>
<li>明确角色定位：一个善于分析的AI助手</li>
<li>决策指导：什么情况下应该调用搜索工具</li>
<li>时间意识：使用当前日期进行搜索</li>
<li>输出格式：要求以特定格式呈现搜索结果</li>
</ol>
<p>测试问题则是关于室内适合种植的花卉：</p>
<div class="code-wrapper"><pre><code class="hljs python">first_message = HumanMessage(content=<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    请帮我搜索下室内适合种植什么花?</span>
<span class="hljs-string">&quot;&quot;&quot;</span>)</code></pre></div>

<h2 id="7-执行流程与事件监听"><a href="#7-执行流程与事件监听" class="headerlink" title="7. 执行流程与事件监听"></a>7. 执行流程与事件监听</h2><p>在执行过程中，我们使用<code>astream_events</code>方法捕获工作流中的各种事件：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> graph.astream_events(initial_state, config=&#123;<span class="hljs-string">&quot;configurable&quot;</span>: &#123;<span class="hljs-string">&quot;thread_id&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;&#125;, version=<span class="hljs-string">&quot;v2&quot;</span>):
    event_type = event[<span class="hljs-string">&#x27;event&#x27;</span>]
    <span class="hljs-keyword">if</span> event_type == <span class="hljs-string">&#x27;on_tool_start&#x27;</span> <span class="hljs-keyword">and</span> event[<span class="hljs-string">&#x27;data&#x27;</span>]:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;开始调用工具查询&#x27;</span>, event[<span class="hljs-string">&#x27;data&#x27;</span>],<span class="hljs-string">&#x27;\n\n&#x27;</span>)
    <span class="hljs-keyword">elif</span> event_type == <span class="hljs-string">&#x27;on_tool_end&#x27;</span> <span class="hljs-keyword">and</span> event[<span class="hljs-string">&#x27;data&#x27;</span>]:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;工具查询结束&#x27;</span>,event[<span class="hljs-string">&#x27;data&#x27;</span>],<span class="hljs-string">&#x27;\n\n&#x27;</span>)
    <span class="hljs-keyword">elif</span> event_type == <span class="hljs-string">&#x27;on_chat_model_stream&#x27;</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;on_chat_model_stream事件------&gt;&#x27;</span>,event[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;chunk&quot;</span>].content,<span class="hljs-string">&#x27;\n\n&#x27;</span>)
        on_chat_model_stream_list.append(event[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;chunk&quot;</span>].content)</code></pre></div>

<p>通过监听这些事件，我们可以跟踪整个工作流的执行过程：</p>
<ul>
<li><code>on_tool_start</code>：工具开始执行时触发</li>
<li><code>on_tool_end</code>：工具执行完成时触发</li>
<li><code>on_chat_model_stream</code>：LLM生成输出时触发</li>
</ul>
<p>这样我们可以实时观察到整个交互的流程。</p>
<h2 id="8-测试结果示例"><a href="#8-测试结果示例" class="headerlink" title="8. 测试结果示例"></a>8. 测试结果示例</h2><h3 id="问题：请帮我搜索下室内适合种植什么花"><a href="#问题：请帮我搜索下室内适合种植什么花" class="headerlink" title="问题：请帮我搜索下室内适合种植什么花?"></a>问题：请帮我搜索下室内适合种植什么花?</h3><p>以下是示例输出：</p>
<div class="code-wrapper"><pre><code class="hljs log">生成完成！ 为了给您提供合适的建议，我将搜索一些适合室内种植的花卉。


根据搜索结果，这里有一些适合室内种植的花卉推荐：

1. **长寿花**
   - 摘要：这是小美最喜欢的室内盆栽花卉，适合室内种植。
   - 链接：[可以放室内养的花有哪些（100种常见室内盆栽花卉图鉴）](https://www.huaguozhijia.com/yanghua/13493.html)

2. **水仙花**
   - 摘要：水仙花是一种时兴的室内水养植物，球茎运用简易，适合放在桌面或阳台上。
   - 链接：[适合室内养绿植推荐：花卉绿植盆栽、高级感、大型绿植、水培、旺宅、养不死的室内绿植 - 知乎](https://zhuanlan.zhihu.com/p/21133659555)

3. **十大室内花卉排名**
   - 摘要：在忙碌的都市生活中，越来越多的人喜欢在室内种植花卉，以增添生活情趣，净化空气。本文介绍了十大室内花卉排名，以及怎样挑选和养护这些美丽的室内花卉。
   - 链接：[十大室内花卉排名；哪些花卉最适合室内种植；怎样挑选和养护花卉](https://baijiahao.baidu.com/s?id=1812440518891264633)

4. **10种适合在室内养护的花卉**
   - 摘要：经过十年的养花经验，作者向大家介绍10种非常适合室内种植的花卉。
   - 链接：[10种适合在室内养护的花卉 - 月季网](https://www.yuejiw.com/post/29176.html)

您可以根据自己的喜好和养护条件选择合适的花卉进行种植。</code></pre></div>

<h3 id="问题：最近AI领域有什么新闻"><a href="#问题：最近AI领域有什么新闻" class="headerlink" title="问题：最近AI领域有什么新闻?"></a>问题：最近AI领域有什么新闻?</h3><p>以下是示例输出：</p>
<div class="code-wrapper"><pre><code class="hljs awk">根据搜索结果，以下是最近AI领域的几条新闻：

<span class="hljs-number">1</span>. 标题：科技资讯ai速递：昨夜今晨科技热点一览 丨<span class="hljs-number">2025</span>年<span class="hljs-number">4</span>月<span class="hljs-number">11</span>日
   摘要：<span class="hljs-number">2025</span>年<span class="hljs-number">04</span>月<span class="hljs-number">11</span>日 <span class="hljs-number">06</span>:<span class="hljs-number">24</span> 新浪ai. 缩小 ... 板 成为全网最火热的ai硬件 <span class="hljs-number">2025</span>年爆火的<span class="hljs-string">&quot;小智ai&quot;</span>开源项目，凭借其拟人化语音交互和低门槛特性，两个月内接入 ...
   链接：[科技资讯ai速递：昨夜今晨科技热点一览 丨<span class="hljs-number">2025</span>年<span class="hljs-number">4</span>月<span class="hljs-number">11</span>日](https:<span class="hljs-regexp">//</span>news.sina.com.cn<span class="hljs-regexp">/zx/</span>ds<span class="hljs-regexp">/2025-04-11/</span>doc-inestvsi2877509.shtml)

<span class="hljs-number">2</span>. 标题：Ai日报 - <span class="hljs-number">2025</span>年<span class="hljs-number">4</span>月<span class="hljs-number">11</span>日
   摘要：📊 趋势图谱：未来<span class="hljs-number">6</span>个月，ai在个性化营销、自动化客户服务、供应链优化方面的应用将持续深化；生成式ai在产品设计、广告创意领域的应用将增加。 <span class="hljs-number">3.3</span> 金融服务 ai. 🌐 全球视角：ai在金融领域的应用广泛，但也面临严格监管和潜在风险。
   链接：[Ai日报 - <span class="hljs-number">2025</span>年<span class="hljs-number">4</span>月<span class="hljs-number">11</span>日 - 腾讯云](https:<span class="hljs-regexp">//</span>cloud.tencent.com<span class="hljs-regexp">/developer/</span>article/<span class="hljs-number">2512975</span>)

<span class="hljs-number">3</span>. 标题：中国学者领衔研发AI肿瘤预测模型
   摘要：<span class="hljs-number">2025</span>-<span class="hljs-number">04</span>-<span class="hljs-number">11</span> <span class="hljs-number">08</span>:<span class="hljs-number">30</span> 发布于北京 人民网资讯精选官方账号 本报电(申奇)近期，由斯坦福大学医学院癌症研究所主导、中国学者领衔进行的一项研究发表于 ...
   链接：[中国学者领衔研发AI肿瘤预测模型_腾讯新闻](https:<span class="hljs-regexp">//</span>news.qq.com<span class="hljs-regexp">/rain/</span>a/<span class="hljs-number">20250411</span>A020P200)</code></pre></div>

<p>这个回复是在LLM接收到由字符串形式的搜索结果后生成的。如果没有将搜索结果转换为字符串，就会遇到前面提到的错误。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们成功构建了一个能够进行网络搜索的AI助手。相比前面的简单工具示例，这个助手可以搜索互联网上的实时信息，使其回答更加准确和有用。</p>
<p>关键改进点包括：</p>
<ol>
<li>集成了实际可用的DuckDuckGo搜索API</li>
<li>处理了工具返回结果格式兼容性问题</li>
</ol>
<p>graph图例流程和上一篇没什么变化，只是工具名称改为了一个具象的工具名：<br><img src="/img/blog/AI/langgraph/workflow_graph-2025-04-11_15-32-50.png" srcset="/img/loading.gif" lazyload></p>
<p>在下一篇中，我们将进一步扩展这个助手，让它不仅能搜索，还能抓取和分析网页内容，以提供更深入的信息处理能力。</p>
<p>完整代码：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv
load_dotenv()
<span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI
<span class="hljs-keyword">from</span> langchain_community.chat_models <span class="hljs-keyword">import</span> QianfanChatEndpoint
<span class="hljs-keyword">from</span> langchain_community.tools.tavily_search <span class="hljs-keyword">import</span> TavilySearchResults
<span class="hljs-keyword">from</span> langchain_community.tools.ddg_search.tool <span class="hljs-keyword">import</span> DuckDuckGoSearchResults
<span class="hljs-keyword">from</span> langchain_core.messages <span class="hljs-keyword">import</span> BaseMessage, HumanMessage, AIMessage, SystemMessage,ToolMessage
<span class="hljs-keyword">from</span> langgraph.graph <span class="hljs-keyword">import</span> StateGraph, START, END,MessagesState
<span class="hljs-keyword">from</span> langchain_core.utils.function_calling <span class="hljs-keyword">import</span> convert_to_openai_function
<span class="hljs-keyword">from</span> langchain_core.runnables.graph <span class="hljs-keyword">import</span> MermaidDrawMethod
<span class="hljs-keyword">from</span> langchain_core.messages <span class="hljs-keyword">import</span> ToolMessage
<span class="hljs-keyword">from</span> langchain_core.tools <span class="hljs-keyword">import</span> tool

<span class="hljs-comment"># 创建图构建器</span>
graph_builder = StateGraph(MessagesState)

os.environ[<span class="hljs-string">&#x27;TAVILY_API_KEY&#x27;</span>] = os.getenv(<span class="hljs-string">&#x27;TAVILY_API_KEY&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)

<span class="hljs-comment"># 创建工具</span>
<span class="hljs-meta">@tool</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">query: <span class="hljs-built_in">str</span></span>):</span>
    <span class="hljs-string">&quot;&quot;&quot;用于浏览网络进行搜索。&quot;&quot;&quot;</span>
    <span class="hljs-comment"># search_tool = TavilySearchResults(max_results=3)</span>
    search_tool = DuckDuckGoSearchResults(max_results=<span class="hljs-number">3</span>, output_format=<span class="hljs-string">&quot;list&quot;</span>) <span class="hljs-comment"># output_format=&quot;list&quot;</span>
    <span class="hljs-keyword">return</span> search_tool.invoke(query)
tools = [search]

<span class="hljs-comment"># llm = QianfanChatEndpoint(</span>
<span class="hljs-comment">#     model=&quot;ernie-lite-pro-128k&quot;,</span>
<span class="hljs-comment">#     api_key=os.getenv(&#x27;QIANFAN_AK&#x27;, &#x27;&#x27;),</span>
<span class="hljs-comment">#     secret_key=os.getenv(&#x27;QIANFAN_SK&#x27;, &#x27;&#x27;)</span>
<span class="hljs-comment"># )</span>

llm = ChatOpenAI(
    <span class="hljs-comment">#THUDM/glm-4-9b-chat</span>
    <span class="hljs-comment">#Qwen/Qwen2.5-7B-Instruct</span>
    model=<span class="hljs-string">&quot;Qwen/Qwen2.5-7B-Instruct&quot;</span>,
    streaming=<span class="hljs-literal">False</span>,  <span class="hljs-comment"># 启用流式输出</span>
    api_key=os.getenv(<span class="hljs-string">&#x27;SILICONFLOW_API_KEY&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>), 
    base_url=os.getenv(<span class="hljs-string">&#x27;SILICONFLOW_BASE_URL&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>),
    temperature=<span class="hljs-number">0.1</span>,
)
llm_with_tools = llm.bind_tools(tools)

<span class="hljs-comment"># 创建工具列表的函数版本</span>
functions = [convert_to_openai_function(t) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tools]

tools_by_name = &#123;tool.name: tool <span class="hljs-keyword">for</span> tool <span class="hljs-keyword">in</span> tools&#125;

<span class="hljs-comment"># 定义工具节点函数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_tool_node</span>(<span class="hljs-params">state: <span class="hljs-built_in">dict</span></span>):</span>
    result = []
    <span class="hljs-keyword">for</span> tool_call <span class="hljs-keyword">in</span> state[<span class="hljs-string">&quot;messages&quot;</span>][-<span class="hljs-number">1</span>].tool_calls:
        tool = tools_by_name[tool_call[<span class="hljs-string">&quot;name&quot;</span>]]
        observation = tool.invoke(tool_call[<span class="hljs-string">&quot;args&quot;</span>])
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;工具搜索结果的完整输出------&gt;&#x27;</span>,observation,<span class="hljs-string">&#x27;\n&#x27;</span>)
        <span class="hljs-comment"># 直接转为字符串</span>
        search_result = <span class="hljs-built_in">str</span>(observation)
        result.append(ToolMessage(content=search_result, tool_call_id=tool_call[<span class="hljs-string">&quot;id&quot;</span>]))
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;messages&quot;</span>: result&#125;

<span class="hljs-comment"># 定义流式节点函数</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chatbot_stream</span>(<span class="hljs-params">state: MessagesState</span>):</span>
    <span class="hljs-string">&quot;&quot;&quot;生成流式回复的节点函数&quot;&quot;&quot;</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;chatbot_stream收到的完整输入------&gt;&#x27;</span>,state,<span class="hljs-string">&#x27;\n&#x27;</span>)
    messages = state[<span class="hljs-string">&quot;messages&quot;</span>]
    <span class="hljs-comment"># streamed_output = []</span>
    <span class="hljs-comment"># tool_calls_detected = []  # 新增：保存检测到的工具调用</span>
    
    <span class="hljs-comment"># 使用非流式方式接收完整返回</span>
    response = llm_with_tools.invoke(
        messages,
        functions=functions,
        function_call=<span class="hljs-string">&quot;auto&quot;</span>
    )
    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;messages&quot;</span>: [response]&#125;
    
    <span class="hljs-comment"># 异步生成器不能使用return返回值</span>
    <span class="hljs-comment"># yield result_state</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">route_tools</span>(<span class="hljs-params">state: MessagesState</span>) :</span>
    <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    在条件边中使用,如果最后一条消息包含工具调用,则路由到工具节点,否则路由到结束节点。</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>
    messages = state[<span class="hljs-string">&#x27;messages&#x27;</span>]
    last_message = messages[-<span class="hljs-number">1</span>]
    <span class="hljs-comment"># 检查是否是AI消息且有工具调用</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(last_message, <span class="hljs-string">&#x27;tool_calls&#x27;</span>) <span class="hljs-keyword">and</span> last_message.tool_calls:
        <span class="hljs-comment"># print(&#x27;last_message.tool_calls------&gt;&#x27;,last_message.tool_calls,&#x27;\n&#x27;)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;search_tool&quot;</span>  <span class="hljs-comment"># 如果有工具调用，路由到工具节点</span>
    
    <span class="hljs-keyword">return</span> END

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">route_chatbot</span>(<span class="hljs-params">state: MessagesState</span>) :</span>
    <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    在条件边中使用,如果最后一条消息包含工具调用,则路由到工具节点,否则路由到结束节点。</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>
    messages = state[<span class="hljs-string">&#x27;messages&#x27;</span>]
    last_message = messages[-<span class="hljs-number">1</span>]
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(last_message, ToolMessage):
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;chatbot&quot;</span>
    <span class="hljs-keyword">return</span> END

<span class="hljs-comment"># 添加chatbot节点</span>
graph_builder.add_node(<span class="hljs-string">&quot;chatbot&quot;</span>, chatbot_stream)
<span class="hljs-comment"># 添加工具节点</span>
graph_builder.add_node(<span class="hljs-string">&quot;search_tool&quot;</span>, search_tool_node)
<span class="hljs-comment"># 设置入口点</span>
graph_builder.set_entry_point(<span class="hljs-string">&quot;chatbot&quot;</span>)
graph_builder.add_conditional_edges(
    <span class="hljs-string">&quot;chatbot&quot;</span>,
    route_tools
)
<span class="hljs-comment"># 添加从tools到chatbot的边</span>
graph_builder.add_edge(<span class="hljs-string">&quot;search_tool&quot;</span>, <span class="hljs-string">&quot;chatbot&quot;</span>)
<span class="hljs-comment"># 编译图</span>
graph = graph_builder.<span class="hljs-built_in">compile</span>()

<span class="hljs-comment"># 定义一个将图导出为PNG的函数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">export_graph_to_png</span>():</span>
    <span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">    将LangGraph图导出为PNG格式</span>
<span class="hljs-string">    </span>
<span class="hljs-string">    Returns:</span>
<span class="hljs-string">        str: 生成的PNG文件路径</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>
    <span class="hljs-keyword">try</span>:
        output_file=<span class="hljs-string">&#x27;workflow_graph-&#x27;</span> + datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%d_%H-%M-%S&quot;</span>) + <span class="hljs-string">&quot;.png&quot;</span>
        graph.get_graph().draw_mermaid_png(
            draw_method=MermaidDrawMethod.API,
            output_file_path=output_file
        )
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;导出PNG图形时出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

<span class="hljs-comment"># 异步运行函数（健壮版本）</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_demo</span>():</span>
    <span class="hljs-string">&quot;&quot;&quot;异步运行LangGraph流式输出演示&quot;&quot;&quot;</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始流式生成回答...\n&quot;</span>)
    
    today = datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%d&quot;</span>)
    <span class="hljs-comment"># print(&#x27;当前日期:&#x27;,today,&#x27;\n&#x27;)</span>
    <span class="hljs-comment"># 创建初始消息</span>
    system_message = SystemMessage(content=<span class="hljs-string">f&quot;&quot;&quot;</span>
<span class="hljs-string">        # 你是一个善于分析的AI助手。</span>
<span class="hljs-string">        ## 对于用户的所有问题，先分析是否需要调用搜索工具，再进行回复，比如查询东西，需要调用搜索工具，如果只是问问题，则不需要调用搜索工具。</span>
<span class="hljs-string">        ## 请牢记今天的日期是<span class="hljs-subst">&#123;today&#125;</span>,调用工具时，直接使用<span class="hljs-subst">&#123;today&#125;</span>的日期。</span>
<span class="hljs-string">        - 分析示例:比如用户询问日历,星座,黄历,新闻等实时查询相关;比如询问今天的新闻或今天的日历。直接把<span class="hljs-subst">&#123;today&#125;</span>的日期作为参数传给搜索工具去做搜索。</span>
<span class="hljs-string">        - 每个搜索结果都需要按照以下格式返回：</span>
<span class="hljs-string">            - 标题：</span>
<span class="hljs-string">            - 摘要：</span>
<span class="hljs-string">            - 链接：</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>)
    first_message = HumanMessage(content=<span class="hljs-string">&quot;&quot;&quot;</span>
<span class="hljs-string">        请帮我搜索下室内适合种植什么花?</span>
<span class="hljs-string">    &quot;&quot;&quot;</span>)
    
    <span class="hljs-comment"># 初始化状态</span>
    initial_state = &#123;<span class="hljs-string">&quot;messages&quot;</span>: [system_message, first_message]&#125;
    on_chat_model_stream_list = []
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 异步执行流式输出</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> graph.astream_events(initial_state, config=&#123;<span class="hljs-string">&quot;configurable&quot;</span>: &#123;<span class="hljs-string">&quot;thread_id&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;&#125;, version=<span class="hljs-string">&quot;v2&quot;</span>):
            <span class="hljs-comment"># 定义一个变量接收所有on_chat_model_stream的值</span>
            <span class="hljs-comment"># print(&#x27;event------&gt;&#x27;,event,&#x27;\n\n&#x27;)</span>
            event_type = event[<span class="hljs-string">&#x27;event&#x27;</span>]
            <span class="hljs-keyword">if</span> event_type == <span class="hljs-string">&#x27;on_tool_start&#x27;</span> <span class="hljs-keyword">and</span> event[<span class="hljs-string">&#x27;data&#x27;</span>]:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;开始调用工具查询&#x27;</span>, event[<span class="hljs-string">&#x27;data&#x27;</span>],<span class="hljs-string">&#x27;\n\n&#x27;</span>)
            <span class="hljs-keyword">elif</span> event_type == <span class="hljs-string">&#x27;on_tool_end&#x27;</span> <span class="hljs-keyword">and</span> event[<span class="hljs-string">&#x27;data&#x27;</span>]:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;工具查询结束&#x27;</span>,event[<span class="hljs-string">&#x27;data&#x27;</span>],<span class="hljs-string">&#x27;\n\n&#x27;</span>)
            <span class="hljs-keyword">elif</span> event_type == <span class="hljs-string">&#x27;on_chat_model_stream&#x27;</span>:
                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;on_chat_model_stream事件------&gt;&#x27;</span>,event[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;chunk&quot;</span>].content,<span class="hljs-string">&#x27;\n\n&#x27;</span>)
                on_chat_model_stream_list.append(event[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;chunk&quot;</span>].content)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;graph.astream_events执行出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)
    
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n生成完成！&quot;</span>,<span class="hljs-string">&quot;&quot;</span>.join(on_chat_model_stream_list),<span class="hljs-string">&#x27;\n\n&#x27;</span>)
    <span class="hljs-comment"># 展示图形</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># # 使用官方文档推荐的方法绘制Mermaid图</span>
        <span class="hljs-comment"># print(&quot;使用官方方法绘制Mermaid图...&quot;)</span>
        mermaid_diagram = graph.get_graph().draw_mermaid()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;```mermaid\n<span class="hljs-subst">&#123;mermaid_diagram&#125;</span>\n```&quot;</span>)
        
        <span class="hljs-comment"># # 导出为PNG</span>
        <span class="hljs-comment"># print(&quot;\n正在导出为PNG图片...&quot;)</span>
        export_graph_to_png()
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;图表绘制出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)
    

<span class="hljs-comment"># 执行异步函数</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:
    asyncio.run(run_demo())</code></pre></div>




            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/AI%E7%9B%B8%E5%85%B3/">AI相关</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Langgraph/">Langgraph</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/03/28/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0MCP%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81review/">
                        <span class="hidden-mobile">开发一个本地MCP Server进行code review</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/wenkil" target="_blank" rel="nofollow noopener"><span>My Github</span></a> 
  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
