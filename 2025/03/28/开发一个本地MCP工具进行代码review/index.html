

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/titleIcon.png">
  <link rel="icon" href="/img/titleIcon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="背景目前开发团队会定期使用AI提效进行code review，但由于每个开发人员使用的不同的AI编程工具，有不同的LLM和IDE，各自提交的审查报告风格和统计会因为LLM的不同而不统一。尝试开发一个本地的MCP工具，这样大家可以用统一模型、统一工具进行code review工作，以保证使用相同的AI模型输出结果的质量和风格是区别不大的。之所以开发本地的，是因为前期需要实验这个mcp工具的实际效果，">
<meta property="og:type" content="article">
<meta property="og:title" content="开发一个本地AI进行代码review的MCP Server">
<meta property="og:url" content="http://example.com/2025/03/28/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0MCP%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81review/index.html">
<meta property="og:site_name" content="Wenkil的开发笔记">
<meta property="og:description" content="背景目前开发团队会定期使用AI提效进行code review，但由于每个开发人员使用的不同的AI编程工具，有不同的LLM和IDE，各自提交的审查报告风格和统计会因为LLM的不同而不统一。尝试开发一个本地的MCP工具，这样大家可以用统一模型、统一工具进行code review工作，以保证使用相同的AI模型输出结果的质量和风格是区别不大的。之所以开发本地的，是因为前期需要实验这个mcp工具的实际效果，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/1.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/2.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/3.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/4.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/5.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/6.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/7.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/8.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/9.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/10.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/11.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/12.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/13.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/14.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/15.png">
<meta property="og:image" content="http://example.com/img/blog/AI/review_code_mcp/16.png">
<meta property="article:published_time" content="2025-03-28T09:02:40.824Z">
<meta property="article:modified_time" content="2025-03-28T12:43:59.543Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="MCP">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/blog/AI/review_code_mcp/1.png">
  
  <title>开发一个本地AI进行代码review的MCP Server - Wenkil的开发笔记</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wenkil的开发笔记</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/blog.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="开发一个本地AI进行代码review的MCP Server">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2025-03-28 17:02" pubdate>
        2025年3月28日 17:02:40
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      28k 字
    </span>
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">开发一个本地AI进行代码review的MCP Server</h1>
            
            <div class="markdown-body">
              <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前开发团队会定期使用AI提效进行code review，但由于每个开发人员使用的不同的AI编程工具，有不同的LLM和IDE，各自提交的审查报告风格和统计会因为LLM的不同而不统一。<br>尝试开发一个本地的MCP工具，这样大家可以用统一模型、统一工具进行code review工作，以保证使用相同的AI模型输出结果的质量和风格是区别不大的。<br>之所以开发本地的，是因为前期需要实验这个mcp工具的实际效果，不需要在工具中再调用git工具去线上取代码提交记录中的文件。</p>
<blockquote>
<p><strong>此工具的完整代码和使用示例已上传git，欢迎给个Star~~</strong><br>  <a target="_blank" rel="noopener" href="https://github.com/wenkil/mcp_review_code_tool">https://github.com/wenkil/mcp_review_code_tool</a></p>
</blockquote>
<h2 id="开发调试过程"><a href="#开发调试过程" class="headerlink" title="开发调试过程"></a>开发调试过程</h2><p>先通过官方文档改造一个mcp 服务器的ts代码（注意这里使用的新版SDK里的McpServer不是Server）：<br><a target="_blank" rel="noopener" href="https://github.com/modelcontextprotocol/typescript-sdk">https://github.com/modelcontextprotocol/typescript-sdk</a></p>
<details><summary>展开/收起</summary>

<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; McpServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/mcp.js&quot;</span>;
<span class="hljs-keyword">import</span> &#123; StdioServerTransport &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/stdio.js&quot;</span>;
<span class="hljs-keyword">import</span> &#123; z &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zod&quot;</span>;
<span class="hljs-keyword">import</span> &#123; promises <span class="hljs-keyword">as</span> fs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 日志级别枚举</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@enum <span class="hljs-type">&#123;string&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-built_in">enum</span> LogLevel &#123;
  DEBUG = <span class="hljs-string">&quot;DEBUG&quot;</span>,
  INFO = <span class="hljs-string">&quot;INFO&quot;</span>,
  WARN = <span class="hljs-string">&quot;WARN&quot;</span>,
  ERROR = <span class="hljs-string">&quot;ERROR&quot;</span>
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 是否启用控制台日志</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@type <span class="hljs-type">&#123;boolean&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">const</span> ENABLE_CONSOLE_LOG = <span class="hljs-literal">true</span>;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 日志文件路径</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@type <span class="hljs-type">&#123;string&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">const</span> LOG_FILE_PATH = <span class="hljs-string">&quot;code-review-mcp.log&quot;</span>;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 代码评审的结果接口</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@interface <span class="hljs-variable">ReviewResult</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">interface</span> ReviewResult &#123;
  <span class="hljs-attr">filePath</span>: <span class="hljs-built_in">string</span>;
  llmResponse: <span class="hljs-built_in">string</span>;
  message: <span class="hljs-built_in">string</span>;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 记录日志到文件和控制台</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">message</span></span> - 要记录的消息</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;LogLevel&#125;</span> <span class="hljs-variable">level</span></span> - 日志级别</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logToFile</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span>, level: LogLevel = LogLevel.INFO</span>) </span>&#123;
  <span class="hljs-keyword">const</span> timestamp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString();
  <span class="hljs-keyword">const</span> logMessage = <span class="hljs-string">`[<span class="hljs-subst">$&#123;timestamp&#125;</span>] [<span class="hljs-subst">$&#123;level&#125;</span>]: <span class="hljs-subst">$&#123;message&#125;</span>`</span>;
  
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">await</span> fs.appendFile(LOG_FILE_PATH, <span class="hljs-string">`<span class="hljs-subst">$&#123;logMessage&#125;</span>\n`</span>);
    
    <span class="hljs-comment">// 同时输出到控制台，方便调试</span>
    <span class="hljs-keyword">if</span> (ENABLE_CONSOLE_LOG) &#123;
      <span class="hljs-keyword">switch</span> (level) &#123;
        <span class="hljs-keyword">case</span> LogLevel.ERROR:
          <span class="hljs-built_in">console</span>.error(logMessage);
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> LogLevel.WARN:
          <span class="hljs-built_in">console</span>.warn(logMessage);
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> LogLevel.DEBUG:
          <span class="hljs-built_in">console</span>.debug(logMessage);
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
          <span class="hljs-built_in">console</span>.log(logMessage);
      &#125;
    &#125;
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`日志记录失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);
  &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 读取文件内容</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">filePath</span></span> - 文件的绝对路径</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;string&gt;&#125;</span> </span>文件内容</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readFileContent</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">string</span>&gt; </span>&#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`开始读取文件: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>, LogLevel.DEBUG);
    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> fs.readFile(filePath, <span class="hljs-string">&quot;utf-8&quot;</span>);
    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`成功读取文件: <span class="hljs-subst">$&#123;filePath&#125;</span>，大小: <span class="hljs-subst">$&#123;content.length&#125;</span> 字节`</span>, LogLevel.DEBUG);
    <span class="hljs-keyword">return</span> content;
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`无法读取文件 <span class="hljs-subst">$&#123;filePath&#125;</span>: <span class="hljs-subst">$&#123;error&#125;</span>`</span>, LogLevel.ERROR);
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`无法读取文件 <span class="hljs-subst">$&#123;filePath&#125;</span>: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);
  &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 检查文件是否存在</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">filePath</span></span> - 文件的绝对路径 </span>
<span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;boolean&gt;&#125;</span> </span>文件是否存在</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fileExists</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">boolean</span>&gt; </span>&#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">await</span> fs.access(filePath);
    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`文件存在: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>, LogLevel.DEBUG);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  &#125; <span class="hljs-keyword">catch</span> &#123;
    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`文件不存在: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>, LogLevel.WARN);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 使用大语言模型分析代码</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">filePath</span></span> - 文件路径</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">content</span></span> - 文件内容</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;ReviewResult&gt;&#125;</span> </span>代码分析结果</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">analyzeLLM</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span>, content: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ReviewResult</span>&gt; </span>&#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`开始使用LLM分析文件: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>, LogLevel.INFO);
    
    <span class="hljs-comment">// 提取文件类型</span>
    <span class="hljs-keyword">const</span> extension = path.extname(filePath).toLowerCase();
    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`文件类型: <span class="hljs-subst">$&#123;extension&#125;</span>`</span>, LogLevel.DEBUG);

    <span class="hljs-comment">// 构建提示词</span>
    <span class="hljs-keyword">const</span> prompt = <span class="hljs-string">`</span>
<span class="hljs-string">    ## 根据要求对以下<span class="hljs-subst">$&#123;extension&#125;</span>代码进行代码评审，识别潜在的问题。要求：</span>
<span class="hljs-string">    1.**统计代码行数及注释率**：</span>
<span class="hljs-string">      - 计算该文件的总行数。</span>
<span class="hljs-string">      - 计算注释行数（如//、#或/* */等注释方式）。</span>
<span class="hljs-string">      - 计算注释率 = 注释行数 / 总行数。</span>
<span class="hljs-string">    2.**评价代码质量**：</span>
<span class="hljs-string">      在以下六个方面进行评分（0到10分），并给出平均分：</span>
<span class="hljs-string">      - **可读性（Readability）**：代码易于理解程度。</span>
<span class="hljs-string">      - **一致性（Consistency）**：编码风格和命名的一致性。</span>
<span class="hljs-string">      - **模块化（Modularity）**：代码分块和功能单元划分。</span>
<span class="hljs-string">      - **可维护性（Maintainability）**：代码易于修改和扩展的能力。</span>
<span class="hljs-string">      - **性能（Performance）**：代码执行效率。</span>
<span class="hljs-string">      - **文档化（Documentation）**：代码附带的说明和文档质量。</span>
<span class="hljs-string">    3. **生成总体报告**：</span>
<span class="hljs-string">      - 将所有分步信息整理成一个markdown结构。</span>
<span class="hljs-string">      - 内容应包括：第一部分：文件列表汇总（每个文件的总行数、注释率评分， 6维评分，得分比较低或者行数比较多，或者注释率比较低的用颜色高亮出来，比如黄色和红色）；第二部分每一个文件的功能描述，以及在六个质量因素上的评分以及说明；第三部分，总结</span>
<span class="hljs-string"></span>
<span class="hljs-string">      以下是要评审的代码：</span>
<span class="hljs-string">      \`\`\`</span>
<span class="hljs-string">      <span class="hljs-subst">$&#123;extension&#125;</span></span>
<span class="hljs-string">      <span class="hljs-subst">$&#123;content&#125;</span></span>
<span class="hljs-string">      \`\`\`</span>
<span class="hljs-string">    `</span>;

    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`准备调用OpenRouter API`</span>, LogLevel.DEBUG);
    
    <span class="hljs-comment">// 调用免费OpenRouter API进行演示，实际可使用公司内部购买的LLM api</span>
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;https://openrouter.ai/api/v1/chat/completions&#x27;</span>, &#123;
      <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
      <span class="hljs-attr">headers</span>: &#123;
        <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer 这里需要去申请你自己的key&#x27;</span>,
        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,
      &#125;,
      <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(&#123;
        <span class="hljs-comment">// &quot;model&quot;: &quot;qwen/qwen-2.5-coder-32b-instruct:free&quot;,</span>
        <span class="hljs-string">&quot;model&quot;</span>: <span class="hljs-string">&quot;deepseek/deepseek-chat-v3-0324:free&quot;</span>,
        <span class="hljs-attr">messages</span>: [
          &#123;
            <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>,
            <span class="hljs-attr">content</span>: prompt,
          &#125;,
        ],
      &#125;),
    &#125;);

    <span class="hljs-keyword">if</span> (!response.ok) &#123;
      <span class="hljs-keyword">const</span> errorText = <span class="hljs-string">`API请求失败: <span class="hljs-subst">$&#123;response.status&#125;</span> <span class="hljs-subst">$&#123;response.statusText&#125;</span>`</span>;
      <span class="hljs-keyword">await</span> logToFile(errorText, LogLevel.ERROR);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(errorText);
    &#125;

    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`OpenRouter API响应成功`</span>, LogLevel.DEBUG);
    
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();
    <span class="hljs-keyword">const</span> llmResponse = data.choices[<span class="hljs-number">0</span>].message.content;
    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`获取到LLM响应，响应长度: <span class="hljs-subst">$&#123;llmResponse.length&#125;</span>字符`</span>, LogLevel.DEBUG);

    <span class="hljs-keyword">return</span> &#123;
      filePath,
      llmResponse,
      <span class="hljs-attr">message</span>: <span class="hljs-string">`对 <span class="hljs-subst">$&#123;path.basename(filePath)&#125;</span> 的代码评审完成`</span>,
    &#125;;
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`LLM分析失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>, LogLevel.ERROR);
    <span class="hljs-keyword">return</span> &#123;
      filePath,
      <span class="hljs-attr">llmResponse</span>: <span class="hljs-string">``</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">`LLM分析失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>,
    &#125;;
  &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 创建MCP服务器实例</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> McpServer(&#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;代码评审工具&quot;</span>,
  <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,
&#125;);

<span class="hljs-comment">// 记录服务器启动日志</span>
logToFile(<span class="hljs-string">&quot;MCP代码评审服务器正在启动...&quot;</span>, LogLevel.INFO);

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 代码评审工具</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">filePaths</span></span> - 文件的绝对路径数组</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;&#123; content: &#123; type: string, text: string &#125;</span></span>[] &#125;&gt;&#125; 代码评审结果</span>
<span class="hljs-comment"> */</span>
server.tool(
  <span class="hljs-string">&quot;reviewCode_tool&quot;</span>,
  <span class="hljs-string">&quot;根据要求进行代码评审，总结代码质量&quot;</span>,
  &#123; <span class="hljs-attr">filePaths</span>: z.array(z.string()) &#125;,
  <span class="hljs-keyword">async</span> (&#123; filePaths &#125;) =&gt; &#123;
    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`代码评审工具被调用，文件数量: <span class="hljs-subst">$&#123;filePaths.length&#125;</span>`</span>, LogLevel.INFO);
    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`文件列表: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(filePaths)&#125;</span>`</span>, LogLevel.DEBUG);

    <span class="hljs-keyword">const</span> results: ReviewResult[] = [];
    <span class="hljs-keyword">const</span> errors: <span class="hljs-built_in">string</span>[] = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> filePath <span class="hljs-keyword">of</span> filePaths) &#123;
      <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`开始处理文件: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>, LogLevel.INFO);

        <span class="hljs-comment">// 检查文件是否存在</span>
        <span class="hljs-keyword">const</span> exists = <span class="hljs-keyword">await</span> fileExists(filePath);
        <span class="hljs-keyword">if</span> (!exists) &#123;
          <span class="hljs-keyword">const</span> errorMsg = <span class="hljs-string">`文件不存在: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>;
          errors.push(errorMsg);
          <span class="hljs-keyword">await</span> logToFile(errorMsg, LogLevel.ERROR);
          <span class="hljs-keyword">continue</span>;
        &#125;

        <span class="hljs-comment">// 读取文件内容</span>
        <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> readFileContent(filePath);

        <span class="hljs-comment">// 使用LLM分析所有类型的文件</span>
        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> analyzeLLM(filePath, content);
        <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`完成文件分析: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>, LogLevel.INFO);

        results.push(result);
      &#125; <span class="hljs-keyword">catch</span> (error) &#123;
        <span class="hljs-keyword">const</span> errorMsg = <span class="hljs-string">`处理文件时出错 <span class="hljs-subst">$&#123;filePath&#125;</span>: <span class="hljs-subst">$&#123;error&#125;</span>`</span>;
        <span class="hljs-keyword">await</span> logToFile(errorMsg, LogLevel.ERROR);
        errors.push(errorMsg);
      &#125;
    &#125;

    <span class="hljs-comment">// 构建响应</span>
    <span class="hljs-keyword">const</span> response = &#123;
      results,
      errors,
      <span class="hljs-attr">message</span>: <span class="hljs-string">`已分析 <span class="hljs-subst">$&#123;results.length&#125;</span> 个文件，失败 <span class="hljs-subst">$&#123;errors.length&#125;</span> 个文件`</span>,
    &#125;;

    <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`代码评审完成，结果: <span class="hljs-subst">$&#123;response.message&#125;</span>`</span>, LogLevel.INFO);
    
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">content</span>: [&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-built_in">JSON</span>.stringify(response, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>) &#125;],
    &#125;;
  &#125;
);

<span class="hljs-comment">// 注册服务器连接事件</span>
<span class="hljs-comment">// server.on(&quot;connected&quot;, () =&gt; &#123;</span>
<span class="hljs-comment">//   logToFile(&quot;MCP服务器已连接，等待请求...&quot;, LogLevel.INFO);</span>
<span class="hljs-comment">// &#125;);</span>

<span class="hljs-comment">// server.on(&quot;error&quot;, (error) =&gt; &#123;</span>
<span class="hljs-comment">//   logToFile(`MCP服务器错误: $&#123;error&#125;`, LogLevel.ERROR);</span>
<span class="hljs-comment">// &#125;);</span>

<span class="hljs-keyword">const</span> transport = <span class="hljs-keyword">new</span> StdioServerTransport();
<span class="hljs-comment">// 连接服务器并记录日志</span>
<span class="hljs-keyword">try</span> &#123;
  <span class="hljs-keyword">await</span> server.connect(transport);
  <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">&quot;MCP服务器已启动并连接&quot;</span>, LogLevel.INFO);
&#125; <span class="hljs-keyword">catch</span> (error) &#123;
  <span class="hljs-keyword">await</span> logToFile(<span class="hljs-string">`MCP服务器连接失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>, LogLevel.ERROR);
&#125;
</code></pre></div>

</details>

<h3 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h3><p>经过多次测试，claude偶尔会出现路径主动把文件路径做了转换，导致tool找不到该文件进行读取：</p>
<details><summary>展开/收起</summary>

<div class="code-wrapper"><pre><code class="hljs json">工具参数
&#123;
  <span class="hljs-attr">&quot;filePaths&quot;</span>: [
    <span class="hljs-string">&quot;/e:/DDI/project/Leader_Coach/src/views/home/component/chatScrollButton/chatScrollButton.vue&quot;</span>,
    <span class="hljs-string">&quot;/e:/DDI/project/Leader_Coach/src/views/recommend/recommend.ts&quot;</span>
  ]
&#125;

工具的返回
&#123;
  <span class="hljs-attr">&quot;results&quot;</span>: [],
  <span class="hljs-attr">&quot;errors&quot;</span>: [
    <span class="hljs-string">&quot;文件不存在: /e:/DDI/project/Leader_Coach/src/views/home/component/chatScrollButton/chatScrollButton.vue&quot;</span>,
    <span class="hljs-string">&quot;文件不存在: /e:/DDI/project/Leader_Coach/src/views/recommend/recommend.ts&quot;</span>
  ],
  <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;已分析 0 个文件，失败 0 个文件&quot;</span>
&#125;</code></pre></div>

</details>

<br>
这时候找不到文件，message就不会显示分析了几个文件，失败了几个文件的提示;

<p>优化方式，在tool代码增加路由格式转换：</p>
<details><summary>展开/收起</summary>

<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;

<span class="hljs-comment">// 示例路径（包含不同格式）</span>
<span class="hljs-keyword">const</span> testPaths = [
    <span class="hljs-string">&quot;E:\\DDI\\project\\Leader_Coach\\src\\views\\recommend\\recommend.ts&quot;</span>, <span class="hljs-comment">// Windows原生</span>
    <span class="hljs-string">&quot;/e:/DDI/project/Leader_Coach/src/views/home/component/chatScrollButton/chatScrollButton.vue&quot;</span>, <span class="hljs-comment">// 类Unix风格</span>
];

<span class="hljs-comment">// 路径规范化函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeCrossPlatformPath</span>(<span class="hljs-params">rawPath</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (rawPath.startsWith(<span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp; <span class="hljs-regexp">/^\/[a-zA-Z]:\//</span>.test(rawPath)) &#123;
        rawPath = rawPath.substring(<span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-keyword">return</span> path.normalize(rawPath.replace(<span class="hljs-regexp">/[\\/]+/g</span>, path.sep));
&#125;

<span class="hljs-comment">// 检查文件是否存在</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkFileExists</span>(<span class="hljs-params">filePath</span>) </span>&#123;
    <span class="hljs-keyword">const</span> normalizedPath = normalizeCrossPlatformPath(filePath);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`规范化结果: <span class="hljs-subst">$&#123;normalizedPath&#125;</span>`</span>);
    <span class="hljs-keyword">return</span> fs.existsSync(normalizedPath);
&#125;

<span class="hljs-comment">// 测试所有路径</span>
testPaths.forEach(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`原始路径: <span class="hljs-subst">$&#123;p&#125;</span>`</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`是否存在: <span class="hljs-subst">$&#123;checkFileExists(p)&#125;</span>\n`</span>);
&#125;);

<span class="hljs-comment">// 打印结果</span>
<span class="hljs-comment">// 原始路径: E:\DDI\project\Leader_Coach\src\views\recommend\recommend.ts</span>
<span class="hljs-comment">// 规范化结果: E:\DDI\project\Leader_Coach\src\views\recommend\recommend.ts</span>
<span class="hljs-comment">// 是否存在: true</span>

<span class="hljs-comment">// 原始路径: /e:/DDI/project/Leader_Coach/src/views/home/component/chatScrollButton/chatScrollButton.vue</span>
<span class="hljs-comment">// 规范化结果: e:\DDI\project\Leader_Coach\src\views\home\component\chatScrollButton\chatScrollButton.vue</span>
<span class="hljs-comment">// 是否存在: true</span></code></pre></div>
</details>
<br>
此时工具的完整调用记录：
<details><summary>展开/收起</summary>

<div class="code-wrapper"><pre><code class="hljs json">ai调用工具传的参数：
&#123;
  <span class="hljs-attr">&quot;filePaths&quot;</span>: [
    <span class="hljs-string">&quot;/e:/DDI/project/Leader_Coach/src/views/home/component/chatScrollButton/chatScrollButton.vue&quot;</span>,
    <span class="hljs-string">&quot;/e:/DDI/project/Leader_Coach/src/views/recommend/recommend.ts&quot;</span>
  ]
&#125;

工具的返回
&#123;
  <span class="hljs-attr">&quot;results&quot;</span>: [
    &#123;
      <span class="hljs-attr">&quot;filePath&quot;</span>: <span class="hljs-string">&quot;e:/DDI/project/Leader_Coach/src/views/home/component/chatScrollButton/chatScrollButton.vue&quot;</span>,
      <span class="hljs-attr">&quot;llmResponse&quot;</span>: <span class="hljs-string">&quot;```markdown\n# 代码评审报告\n\n## 第一部分：文件汇总\n\n| 文件名 | 总行数 | 注释行数 | 注释率 | 可读性 | 一致性 | 模块化 | 可维护性 | 性能 | 文档化 | 平均分 |\n|--------|--------|----------|--------|--------|--------|--------|----------|------|--------|--------|\n| ChatScrollButton.vue | 56 | 7 | 12.5% | 9 | 9 | 8 | 8 | 8 | 8 | 8.3 |\n\n## 第二部分：详细评审\n\n### 文件功能描述\n这是一个Vue 3单文件组件，实现了一个带渐变边框效果的圆形滚动按钮，主要功能包括：\n- 通过`showGradient`属性控制是否显示旋转渐变边框\n- 内置悬停效果和默认边框样式\n- 包含向下的箭头图标\n\n### 质量评分说明\n\n1. **可读性（9/10）**\n   - 代码结构清晰，模板/脚本/样式分离良好\n   - CSS选择器命名语义化明确（如`.scroll-bottom-button-default`）\n   - 改进建议：动画关键帧可以添加注释说明\n\n2. **一致性（9/10）**\n   - 整体遵循Vue 3组合式API规范\n   - CSS变量命名风格统一（`--color-*`）\n   - 少量不一致：模板中同时使用了`:class`和`:style`绑定，建议统一使用一种方式\n\n3. **模块化（8/10）**\n   - 组件功能单一且完整\n   - 可以进一步拆分：将复杂的渐变边框CSS提取为mixin或工具类\n\n4. **可维护性（8/10）**\n   - 类型定义完善（TypeScript接口）\n   - 默认值处理规范\n   - 改进点：缺少emit事件定义说明\n\n5. **性能（8/10）**\n   - 使用了CSS动画而非JS动画\n   - 建议：`background-image`使用雪碧图优化\n\n6. **文档化（8/10）**\n   - 组件级注释完整（包含@description和@example）\n   - 属性有TSDoc注释\n   - 缺少：CSS复杂效果的实现原理说明\n\n## 第三部分：总结\n\n该组件整体质量较高，主要优点：\n- 良好的类型定义和文档注释\n- 视觉效果实现优雅（CSS渐变+遮罩技巧）\n- 响应式交互设计完整\n\n改进建议：\n1. 补充CSS动画实现的原理注释\n2. 统一样式控制方式（优先使用class）\n3. 考虑添加点击事件发射处理\n4. 图片资源建议使用雪碧图优化\n\n总体评分：8.3/10（优质组件，小优化空间）\n```&quot;</span>,
      <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;对 chatScrollButton.vue 的代码评审完成&quot;</span>
    &#125;,
    &#123;
      <span class="hljs-attr">&quot;filePath&quot;</span>: <span class="hljs-string">&quot;e:/DDI/project/Leader_Coach/src/views/recommend/recommend.ts&quot;</span>,
      <span class="hljs-attr">&quot;llmResponse&quot;</span>: <span class="hljs-string">&quot;## 代码评审报告\n\n### 第一部分：文件汇总\n\n| 文件类型 | 总行数 | 注释行数 | 注释率 | 可读性 | 一致性 | 模块化 | 可维护性 | 性能 | 文档化 | 平均分 |\n|----------|--------|----------|--------|--------|--------|--------|----------|------|--------|--------|\n| .ts      | 252    | 10       | 3.97%  | 7      | 8      | 6      | 7        | 8    | 5      | 6.8    |\n\n### 第二部分：详细分析\n\n#### 1. 文件功能描述\n这是一个Vue 3组件，主要功能是：\n- 实现一个推荐教练的表单页面\n- 包含职位选择、教练风格选择、管理话题选择等表单字段\n- 处理表单验证和提交\n- 与后端API交互获取推荐结果\n\n#### 2. 质量评分及说明\n\n**可读性 (7/10)**\n- 优点：变量命名清晰，基本能反映其用途\n- 缺点：长数组定义影响可读性，部分逻辑可以进一步拆分\n\n**一致性 (8/10)**\n- 优点：整体编码风格一致，使用Vue 3组合式API\n- 缺点：部分方法使用选项式API(methods)，与setup()混合使用\n\n**模块化 (6/10)**\n- 优点：组件导入清晰\n- 缺点：大量选项数据直接定义在组件中，可以考虑外部化\n\n**可维护性 (7/10)**\n- 优点：功能划分明确\n- 缺点：表单验证逻辑较复杂，可以提取为独立函数\n\n**性能 (8/10)**\n- 优点：合理使用响应式数据\n- 缺点：watch中使用JSON.parse(JSON.stringify())可能影响性能\n\n**文档化 (5/10)**\n- 优点：关键方法有注释说明\n- 缺点：整体注释率低(3.97%)，部分复杂逻辑缺乏解释\n\n### 第三部分：总结与建议\n\n1. **主要问题**：\n   - 注释率偏低(3.97%)\n   - 长数组定义影响可读性\n   - 混合使用组合式API和选项式API\n   - 表单验证逻辑可以优化\n\n2. **改进建议**：\n   - 将长数组(jobOptions等)提取到单独的文件或配置中\n   - 增加关键逻辑的注释说明\n   - 统一使用组合式API\n   - 提取表单验证逻辑为独立函数\n   - 考虑使用TypeScript接口定义复杂数据结构\n\n3. **亮点**：\n   - 整体结构清晰\n   - 响应式数据处理得当\n   - 错误处理机制完善\n\n总体评分为6.8分，是一个质量中等的组件，通过一些重构可以显著提高可维护性和可读性。&quot;</span>,
      <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;对 recommend.ts 的代码评审完成&quot;</span>
    &#125;
  ],
  <span class="hljs-attr">&quot;errors&quot;</span>: [],
  <span class="hljs-attr">&quot;message&quot;</span>: <span class="hljs-string">&quot;已分析 2 个文件，失败 0 个文件&quot;</span>
&#125;</code></pre></div>
</details>
<br>
可以看到分析结果和分析记录（分析了几个文件等）
输出结果的markdown格式：

<details><summary>展开/收起</summary>

<div class="code-wrapper"><pre><code class="hljs markdown">
<span class="hljs-section"># 代码评审报告</span>

<span class="hljs-section">## 第一部分：文件汇总</span>

| 文件名 | 总行数 | 注释行数 | 注释率 | 可读性 | 一致性 | 模块化 | 可维护性 | 性能 | 文档化 | 平均分 |
|--------|--------|----------|--------|--------|--------|--------|----------|------|--------|--------|
| ChatScrollButton.vue | 56 | 7 | 12.5% | 9 | 9 | 8 | 8 | 8 | 8 | 8.3 |

<span class="hljs-section">## 第二部分：详细评审</span>

<span class="hljs-section">### 文件功能描述</span>
这是一个Vue 3单文件组件，实现了一个带渐变边框效果的圆形滚动按钮，主要功能包括：
<span class="hljs-bullet">-</span> 通过<span class="hljs-code">`showGradient`</span>属性控制是否显示旋转渐变边框
<span class="hljs-bullet">-</span> 内置悬停效果和默认边框样式
<span class="hljs-bullet">-</span> 包含向下的箭头图标

<span class="hljs-section">### 质量评分说明</span>

<span class="hljs-bullet">1.</span> <span class="hljs-strong">**可读性（9/10）**</span>
<span class="hljs-bullet">   -</span> 代码结构清晰，模板/脚本/样式分离良好
<span class="hljs-bullet">   -</span> CSS选择器命名语义化明确（如<span class="hljs-code">`.scroll-bottom-button-default`</span>）
<span class="hljs-bullet">   -</span> 改进建议：动画关键帧可以添加注释说明

<span class="hljs-bullet">2.</span> <span class="hljs-strong">**一致性（9/10）**</span>
<span class="hljs-bullet">   -</span> 整体遵循Vue 3组合式API规范
<span class="hljs-bullet">   -</span> CSS变量命名风格统一（<span class="hljs-code">`--color-*`</span>）
<span class="hljs-bullet">   -</span> 少量不一致：模板中同时使用了<span class="hljs-code">`:class`</span>和<span class="hljs-code">`:style`</span>绑定，建议统一使用一种方式

<span class="hljs-bullet">3.</span> <span class="hljs-strong">**模块化（8/10）**</span>
<span class="hljs-bullet">   -</span> 组件功能单一且完整
<span class="hljs-bullet">   -</span> 可以进一步拆分：将复杂的渐变边框CSS提取为mixin或工具类

<span class="hljs-bullet">4.</span> <span class="hljs-strong">**可维护性（8/10）**</span>
<span class="hljs-bullet">   -</span> 类型定义完善（TypeScript接口）
<span class="hljs-bullet">   -</span> 默认值处理规范
<span class="hljs-bullet">   -</span> 改进点：缺少emit事件定义说明

<span class="hljs-bullet">5.</span> <span class="hljs-strong">**性能（8/10）**</span>
<span class="hljs-bullet">   -</span> 使用了CSS动画而非JS动画
<span class="hljs-bullet">   -</span> 建议：<span class="hljs-code">`background-image`</span>使用雪碧图优化

<span class="hljs-bullet">6.</span> <span class="hljs-strong">**文档化（8/10）**</span>
<span class="hljs-bullet">   -</span> 组件级注释完整（包含@description和@example）
<span class="hljs-bullet">   -</span> 属性有TSDoc注释
<span class="hljs-bullet">   -</span> 缺少：CSS复杂效果的实现原理说明

<span class="hljs-section">## 第三部分：总结</span>

该组件整体质量较高，主要优点：
<span class="hljs-bullet">-</span> 良好的类型定义和文档注释
<span class="hljs-bullet">-</span> 视觉效果实现优雅（CSS渐变+遮罩技巧）
<span class="hljs-bullet">-</span> 响应式交互设计完整

改进建议：
<span class="hljs-bullet">1.</span> 补充CSS动画实现的原理注释
<span class="hljs-bullet">2.</span> 统一样式控制方式（优先使用class）
<span class="hljs-bullet">3.</span> 考虑添加点击事件发射处理
<span class="hljs-bullet">4.</span> 图片资源建议使用雪碧图优化

总体评分：8.3/10（优质组件，小优化空间）

---

<span class="hljs-section">## recommend.ts 代码评审报告</span>

<span class="hljs-section">### 第一部分：文件汇总</span>

| 文件类型 | 总行数 | 注释行数 | 注释率 | 可读性 | 一致性 | 模块化 | 可维护性 | 性能 | 文档化 | 平均分 |
|----------|--------|----------|--------|--------|--------|--------|----------|------|--------|--------|
| .ts      | 252    | 10       | 3.97%  | 7      | 8      | 6      | 7        | 8    | 5      | 6.8    |

<span class="hljs-section">### 第二部分：详细分析</span>

<span class="hljs-section">#### 1. 文件功能描述</span>
这是一个Vue 3组件，主要功能是：
<span class="hljs-bullet">-</span> 实现一个推荐教练的表单页面
<span class="hljs-bullet">-</span> 包含职位选择、教练风格选择、管理话题选择等表单字段
<span class="hljs-bullet">-</span> 处理表单验证和提交
<span class="hljs-bullet">-</span> 与后端API交互获取推荐结果

<span class="hljs-section">#### 2. 质量评分及说明</span>

<span class="hljs-strong">**可读性 (7/10)**</span>
<span class="hljs-bullet">-</span> 优点：变量命名清晰，基本能反映其用途
<span class="hljs-bullet">-</span> 缺点：长数组定义影响可读性，部分逻辑可以进一步拆分

<span class="hljs-strong">**一致性 (8/10)**</span>
<span class="hljs-bullet">-</span> 优点：整体编码风格一致，使用Vue 3组合式API
<span class="hljs-bullet">-</span> 缺点：部分方法使用选项式API(methods)，与setup()混合使用

<span class="hljs-strong">**模块化 (6/10)**</span>
<span class="hljs-bullet">-</span> 优点：组件导入清晰
<span class="hljs-bullet">-</span> 缺点：大量选项数据直接定义在组件中，可以考虑外部化

<span class="hljs-strong">**可维护性 (7/10)**</span>
<span class="hljs-bullet">-</span> 优点：功能划分明确
<span class="hljs-bullet">-</span> 缺点：表单验证逻辑较复杂，可以提取为独立函数

<span class="hljs-strong">**性能 (8/10)**</span>
<span class="hljs-bullet">-</span> 优点：合理使用响应式数据
<span class="hljs-bullet">-</span> 缺点：watch中使用JSON.parse(JSON.stringify())可能影响性能

<span class="hljs-strong">**文档化 (5/10)**</span>
<span class="hljs-bullet">-</span> 优点：关键方法有注释说明
<span class="hljs-bullet">-</span> 缺点：整体注释率低(3.97%)，部分复杂逻辑缺乏解释

<span class="hljs-section">### 第三部分：总结与建议</span>

<span class="hljs-bullet">1.</span> <span class="hljs-strong">**主要问题**</span>：
<span class="hljs-bullet">   -</span> 注释率偏低(3.97%)
<span class="hljs-bullet">   -</span> 长数组定义影响可读性
<span class="hljs-bullet">   -</span> 混合使用组合式API和选项式API
<span class="hljs-bullet">   -</span> 表单验证逻辑可以优化

<span class="hljs-bullet">2.</span> <span class="hljs-strong">**改进建议**</span>：
<span class="hljs-bullet">   -</span> 将长数组(jobOptions等)提取到单独的文件或配置中
<span class="hljs-bullet">   -</span> 增加关键逻辑的注释说明
<span class="hljs-bullet">   -</span> 统一使用组合式API
<span class="hljs-bullet">   -</span> 提取表单验证逻辑为独立函数
<span class="hljs-bullet">   -</span> 考虑使用TypeScript接口定义复杂数据结构

<span class="hljs-bullet">3.</span> <span class="hljs-strong">**亮点**</span>：
<span class="hljs-bullet">   -</span> 整体结构清晰
<span class="hljs-bullet">   -</span> 响应式数据处理得当
<span class="hljs-bullet">   -</span> 错误处理机制完善

总体评分为6.8分，是一个质量中等的组件，通过一些重构可以显著提高可维护性和可读性。</code></pre></div>
</details>
<br>

<h3 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h3><p>再次经过多次测试，每次LLM统计行数和注释率都不一样，这里引入一个node-sloc的npm包进行处理文件统计的不规律的问题：</p>
<details><summary>展开/收起</summary>

<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; sloc &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node-sloc&#x27;</span>;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 代码行数统计结果接口</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">interface</span> SlocResult &#123;
  <span class="hljs-comment">/** 统计的文件路径列表 */</span>
  <span class="hljs-attr">paths</span>: <span class="hljs-built_in">string</span>[];
  <span class="hljs-comment">/** 统计的文件数量 */</span>
  files: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 代码行数（不包含注释和空行） */</span>
  sloc: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 注释行数 */</span>
  comments: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 空行数 */</span>
  blank: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 总行数（代码+注释+空行） */</span>
  loc: <span class="hljs-built_in">number</span>;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 扩展的统计结果接口，包含注释率计算</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">interface</span> ExtendedSlocResult <span class="hljs-keyword">extends</span> SlocResult &#123;
  <span class="hljs-comment">/** 注释行数占总行数的比率 */</span>
  <span class="hljs-attr">commentsToTotalRatio</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 注释行数占代码行数的比率 */</span>
  commentsToCodeRatio: <span class="hljs-built_in">number</span>;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 统计指定文件的代码行数和注释比率</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">filePath</span></span> - 需要统计的文件路径</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>Promise&lt;ExtendedSlocResult&gt; 返回统计结果，包含代码行数、注释行数、空行数及注释比率</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countCodeLines</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ExtendedSlocResult</span>&gt; </span>&#123;
  <span class="hljs-keyword">const</span> options = &#123;
    <span class="hljs-attr">path</span>: filePath
  &#125;;

  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> sloc(options);
    
    <span class="hljs-keyword">if</span>(!result) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;统计结果为空&#x27;</span>);
    &#125;
    <span class="hljs-comment">// 计算注释比率</span>
    <span class="hljs-keyword">const</span> commentsToTotalRatio = <span class="hljs-built_in">Number</span>((result.comments / result.loc).toFixed(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">const</span> commentsToCodeRatio = <span class="hljs-built_in">Number</span>((result.comments / result.sloc).toFixed(<span class="hljs-number">2</span>));

    <span class="hljs-keyword">return</span> &#123;
      ...result,
      commentsToTotalRatio,
      commentsToCodeRatio
    &#125;;
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`统计代码行数失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);
  &#125;
&#125;

<span class="hljs-keyword">export</span> &#123; countCodeLines &#125;;

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-comment">// const filePath = &#x27;E:\\DDI\\project\\Leader_Coach\\src\\views\\recommend\\recommend.ts&#x27;;</span>
<span class="hljs-comment">// countCodeLines(filePath)</span>
<span class="hljs-comment">//   .then((result) =&gt; &#123;</span>
<span class="hljs-comment">//     console.log(&#x27;文件路径:&#x27;, result.paths);</span>
<span class="hljs-comment">//     console.log(&#x27;文件数量:&#x27;, result.files);</span>
<span class="hljs-comment">//     console.log(&#x27;代码行数:&#x27;, result.sloc);</span>
<span class="hljs-comment">//     console.log(&#x27;注释行数:&#x27;, result.comments);</span>
<span class="hljs-comment">//     console.log(&#x27;空行数:&#x27;, result.blank);</span>
<span class="hljs-comment">//     console.log(&#x27;总行数:&#x27;, result.loc);</span>
<span class="hljs-comment">//     console.log(&#x27;注释行数/总行数:&#x27;, `$&#123;result.commentsToTotalRatio * 100&#125;%`);</span>
<span class="hljs-comment">//     console.log(&#x27;注释行数/代码行数:&#x27;, `$&#123;result.commentsToCodeRatio * 100&#125;%`);</span>
<span class="hljs-comment">//   &#125;)</span>
<span class="hljs-comment">//   .catch((error) =&gt; &#123;</span>
<span class="hljs-comment">//     console.error(&#x27;错误:&#x27;, error);</span>
<span class="hljs-comment">//   &#125;); </span></code></pre></div>
</details>
<br>
同一个文件两种效果对比：

<p><img src="/img/blog/AI/review_code_mcp/1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="第三个问题"><a href="#第三个问题" class="headerlink" title="第三个问题"></a>第三个问题</h3><p>再次测试，发现node-sloc默认不支持 .vue 文件，见文档地址：<a target="_blank" rel="noopener" href="https://github.com/edvinh/node-sloc">https://github.com/edvinh/node-sloc</a><br><img src="/img/blog/AI/review_code_mcp/2.png" srcset="/img/loading.gif" lazyload><br>这里经过配置，解决AI统计行数和注释率高低飘忽不定的这个问题：</p>
<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> options = &#123;
  <span class="hljs-attr">path</span>: filePath,
  <span class="hljs-comment">// 手动添加对Vue文件的支持</span>
  <span class="hljs-attr">extensions</span>: [ <span class="hljs-string">&#x27;.vue&#x27;</span>],
  <span class="hljs-attr">ignorePaths</span>: [<span class="hljs-string">&#x27;node_modules&#x27;</span>, <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-string">&#x27;build&#x27;</span>]
&#125;;</code></pre></div>
<p><img src="/img/blog/AI/review_code_mcp/3.png" srcset="/img/loading.gif" lazyload><br><img src="/img/blog/AI/review_code_mcp/4.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="第四个问题"><a href="#第四个问题" class="headerlink" title="第四个问题"></a>第四个问题</h3><p>将这个mcp server给别人使用的问题：目前vscode（需要装插件）和cursor（新版本支持）支持MCP的json配置，也有一些集成工具比如Cherry Studio支持MCP配置（<a target="_blank" rel="noopener" href="https://docs.cherry-ai.com/advanced-basic/mcp">https://docs.cherry-ai.com/advanced-basic/mcp</a> ），但目前看上去jetbrains的IDE还未支持，如果开发人员目前使用的是jetbrains公司下的IDE的话就没法使用这种json配置方式了，但可以通过本地启动一个调试工具页面来使用：</p>
<p>通过官方MCP Inspector调试工具（<a target="_blank" rel="noopener" href="https://github.com/modelcontextprotocol/inspector">https://github.com/modelcontextprotocol/inspector</a> ）进行调试和使用MCP Server</p>
<p>先build ts文件，然后运行命令（node后面的参数为构建后的js路径）：</p>
<div class="code-wrapper"><pre><code class="hljs bash">npx -y @modelcontextprotocol/inspector node <span class="hljs-string">&quot;dist/mcp_code_review_sse.js&quot;</span></code></pre></div>
<p>控制台输出：</p>
<div class="code-wrapper"><pre><code class="hljs bash">Starting MCP inspector...
Proxy server listening on port 3000

🔍 MCP Inspector is up and running at http://localhost:5173 🚀</code></pre></div>
<p>访问<a target="_blank" rel="noopener" href="http://localhost:5173/">http://localhost:5173</a></p>
<p><img src="/img/blog/AI/review_code_mcp/5.png" srcset="/img/loading.gif" lazyload><br><img src="/img/blog/AI/review_code_mcp/6.png" srcset="/img/loading.gif" lazyload><br>这里报错【文件不存在】是因为参数里有双引号：<br><img src="/img/blog/AI/review_code_mcp/7.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="第五个问题"><a href="#第五个问题" class="headerlink" title="第五个问题"></a>第五个问题</h3><p>日志调试问题：server端打印的console.log代码不生效，且cursor配置server里带有console.log的mcp后会报错，但流程不影响，可以正常调用和输出，网上搜索也没有找到相关讨论；<br>然后看下面文档的要求像是需要由客户端来进行接收打印消息来调试的；</p>
<p><img src="/img/blog/AI/review_code_mcp/8.png" srcset="/img/loading.gif" lazyload><br><img src="/img/blog/AI/review_code_mcp/9.png" srcset="/img/loading.gif" lazyload></p>
<p>开发client文档<br><a target="_blank" rel="noopener" href="https://github.com/cyanheads/model-context-protocol-resources/blob/main/guides/mcp-client-development-guide.md">https://github.com/cyanheads/model-context-protocol-resources/blob/main/guides/mcp-client-development-guide.md</a></p>
<p>开发server文档<br><a target="_blank" rel="noopener" href="https://github.com/cyanheads/model-context-protocol-resources/blob/main/guides/mcp-server-development-guide.md">https://github.com/cyanheads/model-context-protocol-resources/blob/main/guides/mcp-server-development-guide.md</a></p>
<p>通过查看文档和源码，其实默认是可以通过consoel.error打印的内容被输出在页面上的，用这种方式把执行的每一步都用error的方式打印出来；官方目前只支持’debug’ | ‘info’ | ‘warn’ | ‘error’ ；</p>
<p><strong>不同SDK的推送日志的方式</strong> ：</p>
<h4 id="McpServer-SDK"><a href="#McpServer-SDK" class="headerlink" title="McpServer SDK"></a>McpServer SDK</h4><p>如果是使用官网demo里的的McpServer sdk:</p>
<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; McpServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/mcp.js&quot;</span>;</code></pre></div>
<p>第一种方式：</p>
<p>打印error</p>
<p>如果想要有其他log level，需要自行查看源码或文档进行处理，这里只演示error</p>
<p>第二种方式，配置server的option：</p>
<p>首先对MCPserver的option进行设置：</p>
<p>设置logging 的 message 设置为true：</p>
<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> McpServer(&#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;代码评审工具&quot;</span>,
  <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;0.1.0&quot;</span>,
&#125;, &#123;
  <span class="hljs-attr">capabilities</span>: &#123;
      <span class="hljs-attr">tools</span>: &#123;&#125;,
      <span class="hljs-attr">logging</span>: &#123;
          <span class="hljs-attr">message</span>: <span class="hljs-literal">true</span>
      &#125;
  &#125;
&#125;);</code></pre></div>

<p>在代码里tool接受参数的地方打印传参：</p>
<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> exists = <span class="hljs-keyword">await</span> fileExists(filePath);
<span class="hljs-built_in">console</span>.error(filePaths);
server.server.sendLoggingMessage(&#123;
  <span class="hljs-attr">level</span>: <span class="hljs-string">&quot;info&quot;</span>,
  <span class="hljs-attr">data</span>: <span class="hljs-string">`文件存在: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>,
&#125;);</code></pre></div>
<p><img src="/img/blog/AI/review_code_mcp/10.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="低版本Server-SDK"><a href="#低版本Server-SDK" class="headerlink" title="低版本Server SDK"></a>低版本Server SDK</h4><p>然后通过查看<a target="_blank" rel="noopener" href="https://github.com/modelcontextprotocol/servers">https://github.com/modelcontextprotocol/servers</a>   一些开源的MCP Server的源码，发现他们使用的typescript sdk不是官网的方式</p>
<p>而是使用下面这种方式自行编写tool调用规则和参数校验等，这种也是支持使用console.error进行打印的，同时也可以使用推送log的方式：</p>
<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Server &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/index.js&quot;</span>;</code></pre></div>
<p>如果是使用这种SDK，和上面McpServer一样对server进行配置：</p>
<p>把logging 的 message 设置为true：</p>
<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> Server(
  &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;代码评审工具&quot;</span>,
    <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;0.1.0&quot;</span>,
  &#125;,
  &#123;
    <span class="hljs-attr">capabilities</span>: &#123;
      <span class="hljs-attr">tools</span>: &#123;&#125;,
      <span class="hljs-attr">logging</span>: &#123;
        <span class="hljs-attr">message</span>: <span class="hljs-literal">true</span>
      &#125;
    &#125;
  &#125;
);</code></pre></div>
<p>然后再使用这种方式推送log到客户端：</p>
<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> &#123; filePaths &#125; = args;
server.sendLoggingMessage(&#123;
  <span class="hljs-attr">level</span>: <span class="hljs-string">&quot;info&quot;</span>,
  <span class="hljs-attr">message</span>: <span class="hljs-string">`开始评审文件: <span class="hljs-subst">$&#123;filePaths&#125;</span>`</span>
&#125;);</code></pre></div>

<p><img src="/img/blog/AI/review_code_mcp/11.png" srcset="/img/loading.gif" lazyload></p>
<p>使用这种自定义的SDK（非上面的McpServer）在cursor里也是可以正常使用的：<br><img src="/img/blog/AI/review_code_mcp/12.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="第六个问题"><a href="#第六个问题" class="headerlink" title="第六个问题"></a>第六个问题</h3><p>这一版改完，测试时偶尔会碰到页面执行超时，但cursor里测试流程正常：<br><img src="/img/blog/AI/review_code_mcp/13.png" srcset="/img/loading.gif" lazyload></p>
<p>神奇的是再稍等几分钟就能看到服务器推送到log到调试平台，里面是有打印LLM的审查结果输出的，但在页面上却是等不到LLM的返回就报timeout了，不确定是不是这个调试工具的延迟设置的问题还是代码上的某些地方的异步调用问题；（待深入排查）</p>
<p><img src="/img/blog/AI/review_code_mcp/14.png" srcset="/img/loading.gif" lazyload></p>
<p>经过查看和运行官方调试工具的源码<a target="_blank" rel="noopener" href="https://github.com/modelcontextprotocol/inspector/tree/main">https://github.com/modelcontextprotocol/inspector/tree/main</a> </p>
<p>发现在APP.tsx里调用了工具方法，但没传超时时间，在封装的useConnection.ts脚本里设置的默认是10s，我手动改成100s，然后尝试：<br><img src="/img/blog/AI/review_code_mcp/15.png" srcset="/img/loading.gif" lazyload></p>
<p>正常的输出位置是在这里的，所以应该是官方需要解决的一个问题：<br><img src="/img/blog/AI/review_code_mcp/16.png" srcset="/img/loading.gif" lazyload></p>
<p>这个timeout暂时先忽略吧，看官方是否优化，如果要想在页面上知道是否已经结束（页面连个loading也没有，体验差劲哈哈哈），可以通过编写一个定时器，每隔一秒推送以下消息来知道当前还没结束：</p>
<div class="code-wrapper"><pre><code class="hljs typescript">server.server.sendLoggingMessage(&#123;
      <span class="hljs-attr">level</span>: <span class="hljs-string">&quot;info&quot;</span>,
      <span class="hljs-attr">data</span>: <span class="hljs-string">`等待LLM返回中`</span>
    &#125;);</code></pre></div>

<h3 id="待发展问题-："><a href="#待发展问题-：" class="headerlink" title="待发展问题 ："></a>待发展问题 ：</h3><p>1.是否要部署到公司服务器，如果部署到网上需要的优化项</p>
<ul>
<li>mcp.json需要带上token，加一层防护</li>
<li>服务器上如何读取要review的代码</li>
<li>服务器上需要将结果进行保存到某个地方</li>
</ul>
<h2 id="解决所有问题后完整代码"><a href="#解决所有问题后完整代码" class="headerlink" title="解决所有问题后完整代码"></a>解决所有问题后完整代码</h2><p>主文件：mcp_code_review.ts</p>
<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> OpenAI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;openai&#x27;</span>;
<span class="hljs-keyword">import</span> &#123; McpServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/mcp.js&quot;</span>;
<span class="hljs-keyword">import</span> &#123; StdioServerTransport &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/stdio.js&quot;</span>;
<span class="hljs-keyword">import</span> &#123; z &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zod&quot;</span>;
<span class="hljs-keyword">import</span> &#123; promises <span class="hljs-keyword">as</span> fs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;
<span class="hljs-keyword">import</span> &#123; countCodeLines &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./sloc_tool.js&quot;</span>;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 创建MCP服务器实例</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> McpServer(&#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;代码评审工具&quot;</span>,
  <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;0.1.0&quot;</span>,
&#125;, &#123;
  <span class="hljs-attr">capabilities</span>: &#123;
    <span class="hljs-attr">tools</span>: &#123;&#125;,
    <span class="hljs-attr">logging</span>: &#123;
      <span class="hljs-attr">message</span>: <span class="hljs-literal">true</span>
    &#125;
  &#125;
&#125;);


<span class="hljs-comment">// Check for API key and baseURL</span>
<span class="hljs-comment">// 这里调试时可以手动替换掉来自env的配置</span>
<span class="hljs-comment">//  || &quot;11111111111111111111111&quot;</span>
<span class="hljs-comment">//  || &quot;https://xxxxxx/api/v1&quot;</span>
<span class="hljs-comment">//  || &quot;qwen/qwen-2.5-coder-32b-instruct:free&quot;</span>
<span class="hljs-keyword">const</span> OPENAI_API_KEY = process.env.OPENAI_API_KEY!;
<span class="hljs-keyword">const</span> OPENAI_API_BASE = process.env.OPENAI_API_BASE!;
<span class="hljs-keyword">const</span> OPENAI_API_MODEL = process.env.OPENAI_API_MODEL!;
<span class="hljs-keyword">if</span> (!OPENAI_API_KEY || !OPENAI_API_BASE) &#123;
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Error: OPENAI_API_KEY or OPENAI_API_BASE environment variable is required&quot;</span>);
  process.exit(<span class="hljs-number">1</span>);
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 读取文件内容</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">filePath</span></span> - 文件的绝对路径</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;string&gt;&#125;</span> </span>文件内容</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readFileContent</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">string</span>&gt; </span>&#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> fs.readFile(filePath, <span class="hljs-string">&quot;utf-8&quot;</span>);
    <span class="hljs-keyword">return</span> content;
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`无法读取文件 <span class="hljs-subst">$&#123;filePath&#125;</span>: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);
  &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 路径规范化函数</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">rawPath</span></span> - 原始路径</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;string&#125;</span> </span>规范化后的路径</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">normalizeCrossPlatformPath</span>(<span class="hljs-params">rawPath: <span class="hljs-built_in">string</span></span>) </span>&#123;
  <span class="hljs-keyword">if</span> (rawPath.startsWith(<span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp; <span class="hljs-regexp">/^\/[a-zA-Z]:\//</span>.test(rawPath)) &#123;
    rawPath = rawPath.substring(<span class="hljs-number">1</span>);
  &#125;
  <span class="hljs-keyword">return</span> path.normalize(rawPath.replace(<span class="hljs-regexp">/[\\/]+/g</span>, path.sep));
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 检查文件是否存在</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">filePath</span></span> - 文件的绝对路径 </span>
<span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;boolean&gt;&#125;</span> </span>文件是否存在</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fileExists</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">boolean</span>&gt; </span>&#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">await</span> fs.access(filePath);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 使用大语言模型分析代码</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">filePath</span></span> - 文件路径</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">content</span></span> - 文件内容</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">analyzeLLM</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span>, content: <span class="hljs-built_in">string</span></span>) </span>&#123;
  <span class="hljs-comment">// 提取文件类型</span>
  <span class="hljs-keyword">const</span> extension = path.extname(filePath).toLowerCase();
  <span class="hljs-comment">// 统计代码行数和注释率</span>
  <span class="hljs-keyword">const</span> &#123; sloc, comments, blank, loc, commentsToTotalRatio, commentsToCodeRatio &#125; = <span class="hljs-keyword">await</span> countCodeLines(filePath);
  <span class="hljs-comment">// 构建提示词</span>
  <span class="hljs-keyword">const</span> prompt = <span class="hljs-string">`</span>
<span class="hljs-string">    ## 根据要求对以下<span class="hljs-subst">$&#123;extension&#125;</span>代码进行代码评审，识别潜在的问题。</span>
<span class="hljs-string">    以下是代码行数和注释率：</span>
<span class="hljs-string">    文件名：<span class="hljs-subst">$&#123;path.basename(filePath)&#125;</span></span>
<span class="hljs-string">    总行数：<span class="hljs-subst">$&#123;loc&#125;</span></span>
<span class="hljs-string">    注释行数：<span class="hljs-subst">$&#123;comments&#125;</span></span>
<span class="hljs-string">    代码行数：<span class="hljs-subst">$&#123;sloc&#125;</span></span>
<span class="hljs-string">    总注释率（注释行数/总行数）：<span class="hljs-subst">$&#123;commentsToTotalRatio&#125;</span></span>
<span class="hljs-string">    代码行数注释率（注释行数/代码行数）：<span class="hljs-subst">$&#123;commentsToCodeRatio&#125;</span></span>
<span class="hljs-string">    要求：</span>
<span class="hljs-string">    1.**评价代码质量**：</span>
<span class="hljs-string">      在以下六个方面进行评分（0到10分），并给出平均分：</span>
<span class="hljs-string">      - **可读性（Readability）**：代码易于理解程度。</span>
<span class="hljs-string">      - **一致性（Consistency）**：编码风格和命名的一致性。</span>
<span class="hljs-string">      - **模块化（Modularity）**：代码分块和功能单元划分。</span>
<span class="hljs-string">      - **可维护性（Maintainability）**：代码易于修改和扩展的能力。</span>
<span class="hljs-string">      - **性能（Performance）**：代码执行效率。</span>
<span class="hljs-string">      - **文档化（Documentation）**：代码附带的说明和文档质量。</span>
<span class="hljs-string">    2. **生成总体报告**：</span>
<span class="hljs-string">      - 将所有分步信息整理成一个markdown结构。</span>
<span class="hljs-string">      - 内容应包括：第一部分：文件列表汇总（每个文件的总行数、注释行数、代码行数、总注释率、代码行数注释率评分， 6维评分，得分比较低或者行数比较多；第二部分每一个文件的功能描述，以及在六个质量因素上的评分以及说明；第三部分，总结</span>
<span class="hljs-string"></span>
<span class="hljs-string">      以下是要评审的代码：</span>
<span class="hljs-string">      \`\`\`</span>
<span class="hljs-string">      <span class="hljs-subst">$&#123;extension&#125;</span></span>
<span class="hljs-string">      <span class="hljs-subst">$&#123;content&#125;</span></span>
<span class="hljs-string">      \`\`\`</span>
<span class="hljs-string">    `</span>;
  <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> OpenAI(&#123;
    <span class="hljs-attr">apiKey</span>: OPENAI_API_KEY,
    <span class="hljs-attr">baseURL</span>: OPENAI_API_BASE,
  &#125;);
  <span class="hljs-keyword">const</span> llmResponse = <span class="hljs-keyword">await</span> client.chat.completions.create(&#123;
    <span class="hljs-attr">model</span>: OPENAI_API_MODEL,
    <span class="hljs-attr">temperature</span>: <span class="hljs-number">0.1</span>,
    <span class="hljs-attr">messages</span>: [
      &#123;
        <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>,
        <span class="hljs-attr">content</span>: prompt,
      &#125;,
    ],
  &#125;);
  server.server.sendLoggingMessage(&#123;
    <span class="hljs-attr">level</span>: <span class="hljs-string">&quot;info&quot;</span>,
    <span class="hljs-attr">data</span>: <span class="hljs-string">`llm结束: <span class="hljs-subst">$&#123;llmResponse.choices[<span class="hljs-number">0</span>].message.content&#125;</span>`</span>
  &#125;);
  <span class="hljs-keyword">let</span> llmMessage = llmResponse.choices &amp;&amp; llmResponse.choices.length &gt; <span class="hljs-number">0</span> ? llmResponse.choices[<span class="hljs-number">0</span>].message.content : <span class="hljs-string">&quot;&quot;</span>;
  <span class="hljs-keyword">if</span> (!llmMessage) &#123;
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`LLM响应内容为空`</span>);
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;LLM响应为空&quot;</span>);
  &#125;
  <span class="hljs-keyword">return</span> &#123;
    filePath,
    <span class="hljs-attr">llmResponse</span>: llmMessage,
    <span class="hljs-attr">message</span>: <span class="hljs-string">`对 <span class="hljs-subst">$&#123;path.basename(filePath)&#125;</span> 的代码评审完成`</span>,
  &#125;;
&#125;

<span class="hljs-comment">// 分离结果和错误</span>
<span class="hljs-comment">// 定义结果类型</span>
<span class="hljs-keyword">type</span> ProcessResult = &#123;
  <span class="hljs-attr">filePath</span>: <span class="hljs-built_in">string</span>;
  llmResponse: <span class="hljs-built_in">string</span>;
  message: <span class="hljs-built_in">string</span>;
  error?: <span class="hljs-built_in">string</span>;
&#125;;

<span class="hljs-comment">// 将文件处理逻辑封装成独立函数</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFile</span>(<span class="hljs-params">fp: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ProcessResult</span>&gt; </span>&#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">let</span> rawPath = <span class="hljs-built_in">String</span>.raw<span class="hljs-string">`<span class="hljs-subst">$&#123;fp&#125;</span>`</span>;<span class="hljs-comment">// 使用原始字符串标记</span>
    <span class="hljs-keyword">let</span> filePath = normalizeCrossPlatformPath(rawPath);<span class="hljs-comment">// 将所有反斜杠替换为正斜杠，Node.js可以在所有平台上理解</span>

    <span class="hljs-comment">// 检查文件是否存在</span>
    <span class="hljs-keyword">const</span> exists = <span class="hljs-keyword">await</span> fileExists(filePath);
    server.server.sendLoggingMessage(&#123;
      <span class="hljs-attr">level</span>: <span class="hljs-string">&quot;info&quot;</span>,
      <span class="hljs-attr">data</span>: <span class="hljs-string">`需要review的文件是否存在: <span class="hljs-subst">$&#123;exists&#125;</span>`</span>,
    &#125;);

    <span class="hljs-keyword">if</span> (!exists) &#123;
      <span class="hljs-keyword">const</span> errorMsg = <span class="hljs-string">`文件不存在: <span class="hljs-subst">$&#123;filePath&#125;</span>`</span>;
      <span class="hljs-built_in">console</span>.error(errorMsg);
      <span class="hljs-keyword">return</span> &#123;
        <span class="hljs-attr">filePath</span>: fp,
        <span class="hljs-attr">llmResponse</span>: <span class="hljs-string">&quot;&quot;</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">`LLM分析失败: <span class="hljs-subst">$&#123;errorMsg&#125;</span>`</span>,
        <span class="hljs-attr">error</span>: errorMsg
      &#125;;
    &#125;

    <span class="hljs-comment">// 读取文件内容</span>
    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> readFileContent(filePath);
    <span class="hljs-comment">// 使用LLM分析文件</span>
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> analyzeLLM(filePath, content);
    <span class="hljs-keyword">return</span> result;
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-keyword">const</span> errorMsg = <span class="hljs-string">`LLM分析失败： <span class="hljs-subst">$&#123;fp&#125;</span>: <span class="hljs-subst">$&#123;error&#125;</span>`</span>;
    <span class="hljs-built_in">console</span>.error(errorMsg);
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">filePath</span>: fp,
      <span class="hljs-attr">llmResponse</span>: <span class="hljs-string">&quot;&quot;</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">`LLM分析失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>,
      <span class="hljs-attr">error</span>: errorMsg
    &#125;;
  &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 代码评审工具</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">filePaths</span></span> - 文件的绝对路径数组</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&lt;&#123; content: &#123; type: string, text: string &#125;</span></span>[] &#125;&gt;&#125; 代码评审结果</span>
<span class="hljs-comment"> */</span>
server.tool(
  <span class="hljs-string">&quot;reviewCode_tool&quot;</span>,
  <span class="hljs-string">&quot;工具描述：根据要求进行代码评审，总结代码质量，传参为filePaths数组，数组元素是每个文件的完整地址&quot;</span>,
  &#123; <span class="hljs-attr">filePaths</span>: z.array(z.string()) &#125;,
  <span class="hljs-keyword">async</span> (&#123; filePaths &#125;) =&gt; &#123;
    <span class="hljs-comment">// 使用 Promise.all 并行处理所有文件</span>
    <span class="hljs-keyword">const</span> processResults = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(
      filePaths.map(<span class="hljs-function"><span class="hljs-params">fp</span> =&gt;</span> processFile(fp))
    );

    <span class="hljs-keyword">const</span> results = processResults <span class="hljs-keyword">as</span> ProcessResult[];
    <span class="hljs-keyword">const</span> errors = processResults
      .filter((r: ProcessResult): r is ProcessResult &amp; &#123; <span class="hljs-attr">error</span>: <span class="hljs-built_in">string</span> &#125; =&gt; <span class="hljs-built_in">Boolean</span>(r.error))
      .map(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.error);

    server.server.sendLoggingMessage(&#123;
      <span class="hljs-attr">level</span>: <span class="hljs-string">&quot;info&quot;</span>,
      <span class="hljs-attr">data</span>: <span class="hljs-string">`当前的results：<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(results)&#125;</span>`</span>
    &#125;);

    <span class="hljs-comment">// 构建响应</span>
    <span class="hljs-keyword">const</span> failedCount = results.filter(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.llmResponse === <span class="hljs-string">&quot;&quot;</span>).length;
    <span class="hljs-keyword">const</span> response = &#123;
      results,
      errors,
      <span class="hljs-attr">message</span>: <span class="hljs-string">`已分析 <span class="hljs-subst">$&#123;results.length&#125;</span> 个文件，失败 <span class="hljs-subst">$&#123;failedCount&#125;</span> 个文件`</span>,
    &#125;;

    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-attr">content</span>: [&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-built_in">JSON</span>.stringify(response, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>) &#125;],
    &#125;;
  &#125;
);

<span class="hljs-keyword">const</span> transport = <span class="hljs-keyword">new</span> StdioServerTransport();
<span class="hljs-keyword">await</span> server.connect(transport)</code></pre></div>

<p>调用的工具：sloc_tool.ts</p>
<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; sloc &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node-sloc&#x27;</span>;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 代码行数统计结果接口</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">interface</span> SlocResult &#123;
  <span class="hljs-comment">/** 统计的文件路径列表 */</span>
  <span class="hljs-attr">paths</span>: <span class="hljs-built_in">string</span>[];
  <span class="hljs-comment">/** 统计的文件数量 */</span>
  files: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 代码行数（不包含注释和空行） */</span>
  sloc: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 注释行数 */</span>
  comments: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 空行数 */</span>
  blank: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 总行数（代码+注释+空行） */</span>
  loc: <span class="hljs-built_in">number</span>;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 扩展的统计结果接口，包含注释率计算</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">interface</span> ExtendedSlocResult <span class="hljs-keyword">extends</span> SlocResult &#123;
  <span class="hljs-comment">/** 注释行数占总行数的比率 */</span>
  <span class="hljs-attr">commentsToTotalRatio</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">/** 注释行数占代码行数的比率 */</span>
  commentsToCodeRatio: <span class="hljs-built_in">number</span>;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 统计指定文件的代码行数和注释比率</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">filePath</span></span> - 需要统计的文件路径</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@returns </span>Promise&lt;ExtendedSlocResult&gt; 返回统计结果，包含代码行数、注释行数、空行数及注释比率</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countCodeLines</span>(<span class="hljs-params">filePath: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ExtendedSlocResult</span>&gt; </span>&#123;
  <span class="hljs-keyword">const</span> options = &#123;
    <span class="hljs-attr">path</span>: filePath,
    <span class="hljs-comment">// 添加对Vue文件的支持</span>
    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.ts&#x27;</span>, <span class="hljs-string">&#x27;.jsx&#x27;</span>, <span class="hljs-string">&#x27;.tsx&#x27;</span>, <span class="hljs-string">&#x27;.vue&#x27;</span>, <span class="hljs-string">&#x27;.html&#x27;</span>, <span class="hljs-string">&#x27;.css&#x27;</span>],
    <span class="hljs-attr">ignorePaths</span>: [<span class="hljs-string">&#x27;node_modules&#x27;</span>, <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-string">&#x27;build&#x27;</span>]
  &#125;;

  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> sloc(options);
    
    <span class="hljs-keyword">if</span>(!result) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;统计结果为空&#x27;</span>);
    &#125;
    <span class="hljs-comment">// 计算注释比率</span>
    <span class="hljs-keyword">const</span> commentsToTotalRatio = <span class="hljs-built_in">Number</span>((result.comments / result.loc).toFixed(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">const</span> commentsToCodeRatio = <span class="hljs-built_in">Number</span>((result.comments / result.sloc).toFixed(<span class="hljs-number">2</span>));

    <span class="hljs-keyword">return</span> &#123;
      ...result,
      commentsToTotalRatio,
      commentsToCodeRatio
    &#125;;
  &#125; <span class="hljs-keyword">catch</span> (error) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`统计代码行数失败: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);
  &#125;
&#125;

<span class="hljs-keyword">export</span> &#123; countCodeLines &#125;;

<span class="hljs-comment">// 使用示例 控制台运行tsx src/utils/sloc_tool.ts</span>
<span class="hljs-comment">// const filePath = &#x27;E:\\DDI\\project\\Leader_Coach\\src\\views\\home\\component\\chatScrollButton\\chatScrollButton.vue&#x27;;</span>
<span class="hljs-comment">// countCodeLines(filePath)</span>
<span class="hljs-comment">//   .then((result) =&gt; &#123;</span>
<span class="hljs-comment">//     console.log(&#x27;文件统计结果:&#x27;);</span>
<span class="hljs-comment">//     console.log(&#x27;文件路径:&#x27;, result.paths);</span>
<span class="hljs-comment">//     console.log(&#x27;文件数量:&#x27;, result.files);</span>
<span class="hljs-comment">//     console.log(&#x27;代码行数:&#x27;, result.sloc);</span>
<span class="hljs-comment">//     console.log(&#x27;注释行数:&#x27;, result.comments);</span>
<span class="hljs-comment">//     console.log(&#x27;空行数:&#x27;, result.blank);</span>
<span class="hljs-comment">//     console.log(&#x27;总行数:&#x27;, result.loc);</span>
<span class="hljs-comment">//     console.log(&#x27;注释行数/总行数:&#x27;, `$&#123;result.commentsToTotalRatio * 100&#125;%`);</span>
<span class="hljs-comment">//     console.log(&#x27;注释行数/代码行数:&#x27;, `$&#123;result.commentsToCodeRatio * 100&#125;%`);</span>
<span class="hljs-comment">//   &#125;)</span>
<span class="hljs-comment">//   .catch((error) =&gt; &#123;</span>
<span class="hljs-comment">//     console.error(&#x27;错误:&#x27;, error);</span>
<span class="hljs-comment">//   &#125;); </span></code></pre></div>


<h2 id="MCP-Server使用步骤"><a href="#MCP-Server使用步骤" class="headerlink" title="MCP Server使用步骤"></a>MCP Server使用步骤</h2><ul>
<li><p>拉取MCP代码到本地</p>
</li>
<li><p>根据自己的windows和mac环境对json进行区分配置（命令路径）</p>
</li>
<li><p>然后将具体文件地址和要求给到AI</p>
</li>
<li><p>等待输出</p>
</li>
</ul>
<h2 id="Cursor使用示例"><a href="#Cursor使用示例" class="headerlink" title="Cursor使用示例"></a>Cursor使用示例</h2><p>配置json：</p>
<div class="code-wrapper"><pre><code class="hljs json">&#123;
  <span class="hljs-attr">&quot;mcpServers&quot;</span>: &#123;
    <span class="hljs-attr">&quot;代码评审工具&quot;</span>: &#123;
      <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,
      <span class="hljs-attr">&quot;args&quot;</span>: [<span class="hljs-string">&quot;your path/dist/mcp_code_review.js&quot;</span>],
      <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;your path&quot;</span>,
      <span class="hljs-attr">&quot;env&quot;</span>: &#123;
        <span class="hljs-attr">&quot;OPENAI_API_KEY&quot;</span>: <span class="hljs-string">&quot;your api key&quot;</span>,
        <span class="hljs-attr">&quot;OPENAI_API_BASE&quot;</span>: <span class="hljs-string">&quot;https://openrouter.ai/api/v1&quot;</span>,
        <span class="hljs-attr">&quot;OPENAI_API_MODEL&quot;</span>: <span class="hljs-string">&quot;qwen/qwen-2.5-coder-32b-instruct:free&quot;</span>
      &#125;
    &#125;
  &#125;
&#125;</code></pre></div>

<p>cursor中启动MCP服务，会触发一个命令行窗口，运行过程中不要关闭</p>
<p>cursor里必须使用agent模式，并且使用claude模型，prompt如下：</p>
<div class="code-wrapper"><pre><code class="hljs plantext">E:\project\Leader_Coach\src\views\home\component\chatScrollButton\chatScrollButton.vue
E:\project\Leader_Coach\src\views\recommend\recommend.ts
使用代码审查工具对这以上文件路径进行code review
调用工具的要求：
- 取出工具返回的llmResponse字段里的内容，将完整内容提取到markdown里的code标签里一起回复
- 如果工具输出里errors有值，或者message里失败n个文件，直接将errors内容输出，这种情况不要总结代码</code></pre></div>





            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/AI%E7%9B%B8%E5%85%B3/">AI相关</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/MCP/">MCP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/03/25/LLM%E5%85%8D%E8%B4%B9api%E5%B9%B3%E5%8F%B0/">
                        <span class="hidden-mobile">LLM免费api平台</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/wenkil" target="_blank" rel="nofollow noopener"><span>My Github</span></a> 
  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        沪ICP备2024081975号
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
